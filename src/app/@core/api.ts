/* tslint:disable */
/* eslint-disable */
//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v13.13.2.0 (NJsonSchema v10.5.2.0 (Newtonsoft.Json v12.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------
// ReSharper disable InconsistentNaming

import {
  mergeMap as _observableMergeMap,
  catchError as _observableCatch,
} from 'rxjs/operators';
import { Observable, throwError as _observableThrow, of as _observableOf } from 'rxjs';
import { Injectable, Inject, Optional, InjectionToken } from '@angular/core';
import {
  HttpClient,
  HttpHeaders,
  HttpResponse,
  HttpResponseBase,
} from '@angular/common/http';

export const API_BASE_URL = new InjectionToken<string>('API_BASE_URL');

export interface IAccountManagersClient {
  getPage(
    offset: number | null | undefined,
    pageIndex: number | null | undefined,
    search: string | null | undefined,
    ascending: boolean | undefined,
    sortBy: string | null | undefined
  ): Observable<PaginatedListOfAccountManagerDto>;
  getList(): Observable<AccountManagerVm[]>;
  post(command: AccountManagersPostCommand): Observable<HttpResultOfInteger>;
  put(command: AccountManagersPutCommand): Observable<void>;
  delete(id: number | undefined): Observable<void>;
}

@Injectable({
  providedIn: 'root',
})
export class AccountManagersClient implements IAccountManagersClient {
  private http: HttpClient;
  private baseUrl: string;
  protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

  constructor(
    @Inject(HttpClient) http: HttpClient,
    @Optional() @Inject(API_BASE_URL) baseUrl?: string
  ) {
    this.http = http;
    this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : '';
  }

  getPage(
    offset: number | null | undefined,
    pageIndex: number | null | undefined,
    search: string | null | undefined,
    ascending: boolean | undefined,
    sortBy: string | null | undefined
  ): Observable<PaginatedListOfAccountManagerDto> {
    let url_ = this.baseUrl + '/api/AccountManagers/GetPage?';
    if (offset !== undefined && offset !== null)
      url_ += 'Offset=' + encodeURIComponent('' + offset) + '&';
    if (pageIndex !== undefined && pageIndex !== null)
      url_ += 'PageIndex=' + encodeURIComponent('' + pageIndex) + '&';
    if (search !== undefined && search !== null)
      url_ += 'Search=' + encodeURIComponent('' + search) + '&';
    if (ascending === null) throw new Error("The parameter 'ascending' cannot be null.");
    else if (ascending !== undefined)
      url_ += 'Ascending=' + encodeURIComponent('' + ascending) + '&';
    if (sortBy !== undefined && sortBy !== null)
      url_ += 'SortBy=' + encodeURIComponent('' + sortBy) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'application/json',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetPage(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetPage(<any>response_);
            } catch (e) {
              return <Observable<PaginatedListOfAccountManagerDto>>(
                (<any>_observableThrow(e))
              );
            }
          } else
            return <Observable<PaginatedListOfAccountManagerDto>>(
              (<any>_observableThrow(response_))
            );
        })
      );
  }

  protected processGetPage(
    response: HttpResponseBase
  ): Observable<PaginatedListOfAccountManagerDto> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = PaginatedListOfAccountManagerDto.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status === 422) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result422: any = null;
          let resultData422 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result422 = ValidationProblemDetails.fromJS(resultData422);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result422
          );
        })
      );
    } else {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let resultdefault: any = null;
          let resultDatadefault =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          resultdefault = ProblemDetails.fromJS(resultDatadefault);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            resultdefault
          );
        })
      );
    }
  }

  getList(): Observable<AccountManagerVm[]> {
    let url_ = this.baseUrl + '/api/AccountManagers/GetList';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'application/json',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetList(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetList(<any>response_);
            } catch (e) {
              return <Observable<AccountManagerVm[]>>(<any>_observableThrow(e));
            }
          } else
            return <Observable<AccountManagerVm[]>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processGetList(response: HttpResponseBase): Observable<AccountManagerVm[]> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          if (Array.isArray(resultData200)) {
            result200 = [] as any;
            for (let item of resultData200)
              result200!.push(AccountManagerVm.fromJS(item));
          } else {
            result200 = <any>null;
          }
          return _observableOf(result200);
        })
      );
    } else {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let resultdefault: any = null;
          let resultDatadefault =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          resultdefault = ProblemDetails.fromJS(resultDatadefault);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            resultdefault
          );
        })
      );
    }
  }

  post(command: AccountManagersPostCommand): Observable<HttpResultOfInteger> {
    let url_ = this.baseUrl + '/api/AccountManagers';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(command);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
        Accept: 'application/json',
      }),
    };

    return this.http
      .request('post', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processPost(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processPost(<any>response_);
            } catch (e) {
              return <Observable<HttpResultOfInteger>>(<any>_observableThrow(e));
            }
          } else
            return <Observable<HttpResultOfInteger>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processPost(response: HttpResponseBase): Observable<HttpResultOfInteger> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = HttpResultOfInteger.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status === 404) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result404: any = null;
          let resultData404 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result404 = ProblemDetails.fromJS(resultData404);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result404
          );
        })
      );
    } else if (status === 400) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result400: any = null;
          let resultData400 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result400 = ProblemDetails.fromJS(resultData400);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result400
          );
        })
      );
    } else if (status === 422) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result422: any = null;
          let resultData422 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result422 = ValidationProblemDetails.fromJS(resultData422);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result422
          );
        })
      );
    } else {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let resultdefault: any = null;
          let resultDatadefault =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          resultdefault = ProblemDetails.fromJS(resultDatadefault);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            resultdefault
          );
        })
      );
    }
  }

  put(command: AccountManagersPutCommand): Observable<void> {
    let url_ = this.baseUrl + '/api/AccountManagers';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(command);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
      }),
    };

    return this.http
      .request('put', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processPut(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processPut(<any>response_);
            } catch (e) {
              return <Observable<void>>(<any>_observableThrow(e));
            }
          } else return <Observable<void>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processPut(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return _observableOf<void>(<any>null);
        })
      );
    } else if (status === 404) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result404: any = null;
          let resultData404 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result404 = ProblemDetails.fromJS(resultData404);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result404
          );
        })
      );
    } else if (status === 400) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result400: any = null;
          let resultData400 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result400 = ProblemDetails.fromJS(resultData400);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result400
          );
        })
      );
    } else if (status === 422) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result422: any = null;
          let resultData422 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result422 = ValidationProblemDetails.fromJS(resultData422);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result422
          );
        })
      );
    } else {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let resultdefault: any = null;
          let resultDatadefault =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          resultdefault = ProblemDetails.fromJS(resultDatadefault);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            resultdefault
          );
        })
      );
    }
  }

  delete(id: number | undefined): Observable<void> {
    let url_ = this.baseUrl + '/api/AccountManagers?';
    if (id === null) throw new Error("The parameter 'id' cannot be null.");
    else if (id !== undefined) url_ += 'id=' + encodeURIComponent('' + id) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({}),
    };

    return this.http
      .request('delete', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processDelete(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processDelete(<any>response_);
            } catch (e) {
              return <Observable<void>>(<any>_observableThrow(e));
            }
          } else return <Observable<void>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processDelete(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return _observableOf<void>(<any>null);
        })
      );
    } else if (status === 404) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result404: any = null;
          let resultData404 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result404 = ProblemDetails.fromJS(resultData404);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result404
          );
        })
      );
    } else if (status === 422) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result422: any = null;
          let resultData422 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result422 = ValidationProblemDetails.fromJS(resultData422);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result422
          );
        })
      );
    } else {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let resultdefault: any = null;
          let resultDatadefault =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          resultdefault = ProblemDetails.fromJS(resultDatadefault);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            resultdefault
          );
        })
      );
    }
  }
}

export interface IAccountsClient {
  getPage(
    offset: number | null | undefined,
    pageIndex: number | null | undefined,
    search: string | null | undefined,
    ascending: boolean | undefined,
    sortBy: string | null | undefined
  ): Observable<PaginatedListOfAccountVm>;
  getAdminsPage(
    serviceProviderId: number | null | undefined,
    offset: number | null | undefined,
    pageIndex: number | null | undefined,
    search: string | null | undefined,
    ascending: boolean | undefined,
    sortBy: string | null | undefined
  ): Observable<PaginatedListOfAdminVm>;
  getUser(id: string | null | undefined): Observable<AccountDashboardDto>;
  get(): Observable<AccountDto>;
  post(command: AccountsPostCommand): Observable<AccountResult>;
  put(command: AccountsPutCommand): Observable<void>;
  delete(id: string | null | undefined): Observable<FileResponse>;
  refreshToken(command: RefreshTokenCommand): Observable<AuthResponse>;
  login(command: LoginCommand): Observable<AuthResponse>;
  countersLogin(command: CountersLoginCommand): Observable<CounterAuthResponse>;
  register(command: RegisterCommand): Observable<HttpResultOfString>;
  externalLogin(command: ExternalLoginCommand): Observable<AuthResponse>;
  externalRegistration(command: ExternalRegisterCommand): Observable<HttpResultOfString>;
  resetPassword(command: ResetPasswordCommand): Observable<AuthResponse>;
  confirmPhoneNumber(command: ConfirmPhoneNumberCommand): Observable<AuthResponse>;
  confirmChangedPhoneNumber(command: ConfirmChangePhoneNumberCommand): Observable<void>;
  resendConfirmationMessage(
    command: ResendPhoneNumberConfirmationCommand
  ): Observable<void>;
  forgetPassword(command: ForgetPasswordCommand): Observable<void>;
  uploadPicture(
    userId: string | null | undefined,
    picture: FileParameter | null | undefined
  ): Observable<void>;
  changeProfile(
    picture: FileParameter | null | undefined,
    email: string | null | undefined,
    fullName_FirstName: string | null | undefined,
    fullName_LastName: string | null | undefined,
    nationalId: string | null | undefined
  ): Observable<void>;
  changePhoneNumber(command: ChangePhoneNumberCommand): Observable<void>;
  changePassword(command: ChangePasswordCommand): Observable<void>;
  changeLanguage(command: ChangeLanguageCommand): Observable<void>;
  resetUserPassword(command: ResetUserPasswordCommand): Observable<void>;
  ban(command: AccountsBanCommand): Observable<void>;
  logout(): Observable<void>;
}

@Injectable({
  providedIn: 'root',
})
export class AccountsClient implements IAccountsClient {
  private http: HttpClient;
  private baseUrl: string;
  protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

  constructor(
    @Inject(HttpClient) http: HttpClient,
    @Optional() @Inject(API_BASE_URL) baseUrl?: string
  ) {
    this.http = http;
    this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : '';
  }

  getPage(
    offset: number | null | undefined,
    pageIndex: number | null | undefined,
    search: string | null | undefined,
    ascending: boolean | undefined,
    sortBy: string | null | undefined
  ): Observable<PaginatedListOfAccountVm> {
    let url_ = this.baseUrl + '/api/Accounts/GetPage?';
    if (offset !== undefined && offset !== null)
      url_ += 'Offset=' + encodeURIComponent('' + offset) + '&';
    if (pageIndex !== undefined && pageIndex !== null)
      url_ += 'PageIndex=' + encodeURIComponent('' + pageIndex) + '&';
    if (search !== undefined && search !== null)
      url_ += 'Search=' + encodeURIComponent('' + search) + '&';
    if (ascending === null) throw new Error("The parameter 'ascending' cannot be null.");
    else if (ascending !== undefined)
      url_ += 'Ascending=' + encodeURIComponent('' + ascending) + '&';
    if (sortBy !== undefined && sortBy !== null)
      url_ += 'SortBy=' + encodeURIComponent('' + sortBy) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'application/json',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetPage(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetPage(<any>response_);
            } catch (e) {
              return <Observable<PaginatedListOfAccountVm>>(<any>_observableThrow(e));
            }
          } else
            return <Observable<PaginatedListOfAccountVm>>(
              (<any>_observableThrow(response_))
            );
        })
      );
  }

  protected processGetPage(
    response: HttpResponseBase
  ): Observable<PaginatedListOfAccountVm> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = PaginatedListOfAccountVm.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status === 422) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result422: any = null;
          let resultData422 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result422 = ValidationProblemDetails.fromJS(resultData422);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result422
          );
        })
      );
    } else {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let resultdefault: any = null;
          let resultDatadefault =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          resultdefault = ProblemDetails.fromJS(resultDatadefault);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            resultdefault
          );
        })
      );
    }
  }

  getAdminsPage(
    serviceProviderId: number | null | undefined,
    offset: number | null | undefined,
    pageIndex: number | null | undefined,
    search: string | null | undefined,
    ascending: boolean | undefined,
    sortBy: string | null | undefined
  ): Observable<PaginatedListOfAdminVm> {
    let url_ = this.baseUrl + '/api/Accounts/GetAdminsPage?';
    if (serviceProviderId !== undefined && serviceProviderId !== null)
      url_ += 'ServiceProviderId=' + encodeURIComponent('' + serviceProviderId) + '&';
    if (offset !== undefined && offset !== null)
      url_ += 'Offset=' + encodeURIComponent('' + offset) + '&';
    if (pageIndex !== undefined && pageIndex !== null)
      url_ += 'PageIndex=' + encodeURIComponent('' + pageIndex) + '&';
    if (search !== undefined && search !== null)
      url_ += 'Search=' + encodeURIComponent('' + search) + '&';
    if (ascending === null) throw new Error("The parameter 'ascending' cannot be null.");
    else if (ascending !== undefined)
      url_ += 'Ascending=' + encodeURIComponent('' + ascending) + '&';
    if (sortBy !== undefined && sortBy !== null)
      url_ += 'SortBy=' + encodeURIComponent('' + sortBy) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'application/json',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetAdminsPage(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetAdminsPage(<any>response_);
            } catch (e) {
              return <Observable<PaginatedListOfAdminVm>>(<any>_observableThrow(e));
            }
          } else
            return <Observable<PaginatedListOfAdminVm>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processGetAdminsPage(
    response: HttpResponseBase
  ): Observable<PaginatedListOfAdminVm> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = PaginatedListOfAdminVm.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status === 422) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result422: any = null;
          let resultData422 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result422 = ValidationProblemDetails.fromJS(resultData422);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result422
          );
        })
      );
    } else {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let resultdefault: any = null;
          let resultDatadefault =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          resultdefault = ProblemDetails.fromJS(resultDatadefault);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            resultdefault
          );
        })
      );
    }
  }

  getUser(id: string | null | undefined): Observable<AccountDashboardDto> {
    let url_ = this.baseUrl + '/api/Accounts/GetUser?';
    if (id !== undefined && id !== null)
      url_ += 'Id=' + encodeURIComponent('' + id) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'application/json',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetUser(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetUser(<any>response_);
            } catch (e) {
              return <Observable<AccountDashboardDto>>(<any>_observableThrow(e));
            }
          } else
            return <Observable<AccountDashboardDto>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processGetUser(response: HttpResponseBase): Observable<AccountDashboardDto> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = AccountDashboardDto.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status === 422) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result422: any = null;
          let resultData422 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result422 = ValidationProblemDetails.fromJS(resultData422);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result422
          );
        })
      );
    } else {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let resultdefault: any = null;
          let resultDatadefault =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          resultdefault = ProblemDetails.fromJS(resultDatadefault);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            resultdefault
          );
        })
      );
    }
  }

  get(): Observable<AccountDto> {
    let url_ = this.baseUrl + '/api/Accounts';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'application/json',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGet(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGet(<any>response_);
            } catch (e) {
              return <Observable<AccountDto>>(<any>_observableThrow(e));
            }
          } else return <Observable<AccountDto>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processGet(response: HttpResponseBase): Observable<AccountDto> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = AccountDto.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let resultdefault: any = null;
          let resultDatadefault =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          resultdefault = ProblemDetails.fromJS(resultDatadefault);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            resultdefault
          );
        })
      );
    }
  }

  post(command: AccountsPostCommand): Observable<AccountResult> {
    let url_ = this.baseUrl + '/api/Accounts';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(command);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
        Accept: 'application/json',
      }),
    };

    return this.http
      .request('post', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processPost(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processPost(<any>response_);
            } catch (e) {
              return <Observable<AccountResult>>(<any>_observableThrow(e));
            }
          } else return <Observable<AccountResult>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processPost(response: HttpResponseBase): Observable<AccountResult> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = AccountResult.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status === 404) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result404: any = null;
          let resultData404 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result404 = ProblemDetails.fromJS(resultData404);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result404
          );
        })
      );
    } else if (status === 400) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result400: any = null;
          let resultData400 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result400 = ProblemDetails.fromJS(resultData400);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result400
          );
        })
      );
    } else if (status === 422) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result422: any = null;
          let resultData422 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result422 = ValidationProblemDetails.fromJS(resultData422);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result422
          );
        })
      );
    } else {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let resultdefault: any = null;
          let resultDatadefault =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          resultdefault = ProblemDetails.fromJS(resultDatadefault);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            resultdefault
          );
        })
      );
    }
  }

  put(command: AccountsPutCommand): Observable<void> {
    let url_ = this.baseUrl + '/api/Accounts';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(command);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
      }),
    };

    return this.http
      .request('put', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processPut(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processPut(<any>response_);
            } catch (e) {
              return <Observable<void>>(<any>_observableThrow(e));
            }
          } else return <Observable<void>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processPut(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return _observableOf<void>(<any>null);
        })
      );
    } else if (status === 404) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result404: any = null;
          let resultData404 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result404 = ProblemDetails.fromJS(resultData404);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result404
          );
        })
      );
    } else if (status === 400) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result400: any = null;
          let resultData400 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result400 = ProblemDetails.fromJS(resultData400);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result400
          );
        })
      );
    } else if (status === 422) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result422: any = null;
          let resultData422 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result422 = ValidationProblemDetails.fromJS(resultData422);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result422
          );
        })
      );
    } else {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let resultdefault: any = null;
          let resultDatadefault =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          resultdefault = ProblemDetails.fromJS(resultDatadefault);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            resultdefault
          );
        })
      );
    }
  }

  delete(id: string | null | undefined): Observable<FileResponse> {
    let url_ = this.baseUrl + '/api/Accounts?';
    if (id !== undefined && id !== null)
      url_ += 'Id=' + encodeURIComponent('' + id) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'application/octet-stream',
      }),
    };

    return this.http
      .request('delete', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processDelete(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processDelete(<any>response_);
            } catch (e) {
              return <Observable<FileResponse>>(<any>_observableThrow(e));
            }
          } else return <Observable<FileResponse>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processDelete(response: HttpResponseBase): Observable<FileResponse> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200 || status === 206) {
      const contentDisposition = response.headers
        ? response.headers.get('content-disposition')
        : undefined;
      const fileNameMatch = contentDisposition
        ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition)
        : undefined;
      const fileName =
        fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
      return _observableOf({
        fileName: fileName,
        data: <any>responseBlob,
        status: status,
        headers: _headers,
      });
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<FileResponse>(<any>null);
  }

  refreshToken(command: RefreshTokenCommand): Observable<AuthResponse> {
    let url_ = this.baseUrl + '/api/Accounts/RefreshToken';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(command);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
        Accept: 'application/json',
      }),
    };

    return this.http
      .request('post', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processRefreshToken(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processRefreshToken(<any>response_);
            } catch (e) {
              return <Observable<AuthResponse>>(<any>_observableThrow(e));
            }
          } else return <Observable<AuthResponse>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processRefreshToken(response: HttpResponseBase): Observable<AuthResponse> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = AuthResponse.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status === 404) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result404: any = null;
          let resultData404 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result404 = ProblemDetails.fromJS(resultData404);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result404
          );
        })
      );
    } else {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let resultdefault: any = null;
          let resultDatadefault =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          resultdefault = ProblemDetails.fromJS(resultDatadefault);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            resultdefault
          );
        })
      );
    }
  }

  login(command: LoginCommand): Observable<AuthResponse> {
    let url_ = this.baseUrl + '/api/Accounts/Login';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(command);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
        Accept: 'application/json',
      }),
    };

    return this.http
      .request('post', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processLogin(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processLogin(<any>response_);
            } catch (e) {
              return <Observable<AuthResponse>>(<any>_observableThrow(e));
            }
          } else return <Observable<AuthResponse>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processLogin(response: HttpResponseBase): Observable<AuthResponse> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = AuthResponse.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status === 404) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result404: any = null;
          let resultData404 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result404 = ProblemDetails.fromJS(resultData404);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result404
          );
        })
      );
    } else if (status === 400) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result400: any = null;
          let resultData400 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result400 = ProblemDetails.fromJS(resultData400);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result400
          );
        })
      );
    } else if (status === 422) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result422: any = null;
          let resultData422 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result422 = ValidationProblemDetails.fromJS(resultData422);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result422
          );
        })
      );
    } else {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let resultdefault: any = null;
          let resultDatadefault =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          resultdefault = ProblemDetails.fromJS(resultDatadefault);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            resultdefault
          );
        })
      );
    }
  }

  countersLogin(command: CountersLoginCommand): Observable<CounterAuthResponse> {
    let url_ = this.baseUrl + '/api/Accounts/CountersLogin';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(command);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
        Accept: 'application/json',
      }),
    };

    return this.http
      .request('post', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processCountersLogin(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processCountersLogin(<any>response_);
            } catch (e) {
              return <Observable<CounterAuthResponse>>(<any>_observableThrow(e));
            }
          } else
            return <Observable<CounterAuthResponse>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processCountersLogin(
    response: HttpResponseBase
  ): Observable<CounterAuthResponse> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = CounterAuthResponse.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status === 404) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result404: any = null;
          let resultData404 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result404 = ProblemDetails.fromJS(resultData404);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result404
          );
        })
      );
    } else if (status === 400) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result400: any = null;
          let resultData400 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result400 = ProblemDetails.fromJS(resultData400);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result400
          );
        })
      );
    } else if (status === 422) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result422: any = null;
          let resultData422 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result422 = ValidationProblemDetails.fromJS(resultData422);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result422
          );
        })
      );
    } else {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let resultdefault: any = null;
          let resultDatadefault =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          resultdefault = ProblemDetails.fromJS(resultDatadefault);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            resultdefault
          );
        })
      );
    }
  }

  register(command: RegisterCommand): Observable<HttpResultOfString> {
    let url_ = this.baseUrl + '/api/Accounts/Register';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(command);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
        Accept: 'application/json',
      }),
    };

    return this.http
      .request('post', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processRegister(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processRegister(<any>response_);
            } catch (e) {
              return <Observable<HttpResultOfString>>(<any>_observableThrow(e));
            }
          } else
            return <Observable<HttpResultOfString>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processRegister(response: HttpResponseBase): Observable<HttpResultOfString> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = HttpResultOfString.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status === 400) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result400: any = null;
          let resultData400 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result400 = ProblemDetails.fromJS(resultData400);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result400
          );
        })
      );
    } else if (status === 422) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result422: any = null;
          let resultData422 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result422 = ValidationProblemDetails.fromJS(resultData422);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result422
          );
        })
      );
    } else {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let resultdefault: any = null;
          let resultDatadefault =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          resultdefault = ProblemDetails.fromJS(resultDatadefault);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            resultdefault
          );
        })
      );
    }
  }

  externalLogin(command: ExternalLoginCommand): Observable<AuthResponse> {
    let url_ = this.baseUrl + '/api/Accounts/ExternalLogin';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(command);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
        Accept: 'application/json',
      }),
    };

    return this.http
      .request('post', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processExternalLogin(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processExternalLogin(<any>response_);
            } catch (e) {
              return <Observable<AuthResponse>>(<any>_observableThrow(e));
            }
          } else return <Observable<AuthResponse>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processExternalLogin(response: HttpResponseBase): Observable<AuthResponse> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = AuthResponse.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status === 404) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result404: any = null;
          let resultData404 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result404 = ProblemDetails.fromJS(resultData404);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result404
          );
        })
      );
    } else if (status === 400) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result400: any = null;
          let resultData400 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result400 = ProblemDetails.fromJS(resultData400);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result400
          );
        })
      );
    } else if (status === 422) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result422: any = null;
          let resultData422 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result422 = ValidationProblemDetails.fromJS(resultData422);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result422
          );
        })
      );
    } else {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let resultdefault: any = null;
          let resultDatadefault =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          resultdefault = ProblemDetails.fromJS(resultDatadefault);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            resultdefault
          );
        })
      );
    }
  }

  externalRegistration(command: ExternalRegisterCommand): Observable<HttpResultOfString> {
    let url_ = this.baseUrl + '/api/Accounts/ExternalRegistration';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(command);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
        Accept: 'application/json',
      }),
    };

    return this.http
      .request('post', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processExternalRegistration(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processExternalRegistration(<any>response_);
            } catch (e) {
              return <Observable<HttpResultOfString>>(<any>_observableThrow(e));
            }
          } else
            return <Observable<HttpResultOfString>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processExternalRegistration(
    response: HttpResponseBase
  ): Observable<HttpResultOfString> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = HttpResultOfString.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status === 400) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result400: any = null;
          let resultData400 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result400 = ProblemDetails.fromJS(resultData400);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result400
          );
        })
      );
    } else if (status === 422) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result422: any = null;
          let resultData422 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result422 = ValidationProblemDetails.fromJS(resultData422);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result422
          );
        })
      );
    } else {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let resultdefault: any = null;
          let resultDatadefault =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          resultdefault = ProblemDetails.fromJS(resultDatadefault);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            resultdefault
          );
        })
      );
    }
  }

  resetPassword(command: ResetPasswordCommand): Observable<AuthResponse> {
    let url_ = this.baseUrl + '/api/Accounts/ResetPassword';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(command);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
        Accept: 'application/json',
      }),
    };

    return this.http
      .request('post', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processResetPassword(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processResetPassword(<any>response_);
            } catch (e) {
              return <Observable<AuthResponse>>(<any>_observableThrow(e));
            }
          } else return <Observable<AuthResponse>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processResetPassword(response: HttpResponseBase): Observable<AuthResponse> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = AuthResponse.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status === 404) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result404: any = null;
          let resultData404 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result404 = ProblemDetails.fromJS(resultData404);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result404
          );
        })
      );
    } else if (status === 400) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result400: any = null;
          let resultData400 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result400 = ProblemDetails.fromJS(resultData400);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result400
          );
        })
      );
    } else if (status === 422) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result422: any = null;
          let resultData422 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result422 = ValidationProblemDetails.fromJS(resultData422);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result422
          );
        })
      );
    } else {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let resultdefault: any = null;
          let resultDatadefault =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          resultdefault = ProblemDetails.fromJS(resultDatadefault);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            resultdefault
          );
        })
      );
    }
  }

  confirmPhoneNumber(command: ConfirmPhoneNumberCommand): Observable<AuthResponse> {
    let url_ = this.baseUrl + '/api/Accounts/ConfirmPhoneNumber';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(command);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
        Accept: 'application/json',
      }),
    };

    return this.http
      .request('post', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processConfirmPhoneNumber(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processConfirmPhoneNumber(<any>response_);
            } catch (e) {
              return <Observable<AuthResponse>>(<any>_observableThrow(e));
            }
          } else return <Observable<AuthResponse>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processConfirmPhoneNumber(
    response: HttpResponseBase
  ): Observable<AuthResponse> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = AuthResponse.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status === 404) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result404: any = null;
          let resultData404 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result404 = ProblemDetails.fromJS(resultData404);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result404
          );
        })
      );
    } else if (status === 400) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result400: any = null;
          let resultData400 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result400 = ProblemDetails.fromJS(resultData400);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result400
          );
        })
      );
    } else if (status === 422) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result422: any = null;
          let resultData422 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result422 = ValidationProblemDetails.fromJS(resultData422);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result422
          );
        })
      );
    } else {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let resultdefault: any = null;
          let resultDatadefault =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          resultdefault = ProblemDetails.fromJS(resultDatadefault);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            resultdefault
          );
        })
      );
    }
  }

  confirmChangedPhoneNumber(command: ConfirmChangePhoneNumberCommand): Observable<void> {
    let url_ = this.baseUrl + '/api/Accounts/ConfirmChangedPhoneNumber';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(command);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
      }),
    };

    return this.http
      .request('post', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processConfirmChangedPhoneNumber(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processConfirmChangedPhoneNumber(<any>response_);
            } catch (e) {
              return <Observable<void>>(<any>_observableThrow(e));
            }
          } else return <Observable<void>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processConfirmChangedPhoneNumber(
    response: HttpResponseBase
  ): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return _observableOf<void>(<any>null);
        })
      );
    } else if (status === 404) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result404: any = null;
          let resultData404 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result404 = ProblemDetails.fromJS(resultData404);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result404
          );
        })
      );
    } else if (status === 400) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result400: any = null;
          let resultData400 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result400 = ProblemDetails.fromJS(resultData400);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result400
          );
        })
      );
    } else if (status === 422) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result422: any = null;
          let resultData422 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result422 = ValidationProblemDetails.fromJS(resultData422);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result422
          );
        })
      );
    } else {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let resultdefault: any = null;
          let resultDatadefault =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          resultdefault = ProblemDetails.fromJS(resultDatadefault);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            resultdefault
          );
        })
      );
    }
  }

  resendConfirmationMessage(
    command: ResendPhoneNumberConfirmationCommand
  ): Observable<void> {
    let url_ = this.baseUrl + '/api/Accounts/ResendConfirmationMessage';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(command);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
      }),
    };

    return this.http
      .request('post', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processResendConfirmationMessage(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processResendConfirmationMessage(<any>response_);
            } catch (e) {
              return <Observable<void>>(<any>_observableThrow(e));
            }
          } else return <Observable<void>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processResendConfirmationMessage(
    response: HttpResponseBase
  ): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return _observableOf<void>(<any>null);
        })
      );
    } else if (status === 404) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result404: any = null;
          let resultData404 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result404 = ProblemDetails.fromJS(resultData404);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result404
          );
        })
      );
    } else if (status === 400) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result400: any = null;
          let resultData400 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result400 = ProblemDetails.fromJS(resultData400);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result400
          );
        })
      );
    } else if (status === 422) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result422: any = null;
          let resultData422 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result422 = ValidationProblemDetails.fromJS(resultData422);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result422
          );
        })
      );
    } else {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let resultdefault: any = null;
          let resultDatadefault =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          resultdefault = ProblemDetails.fromJS(resultDatadefault);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            resultdefault
          );
        })
      );
    }
  }

  forgetPassword(command: ForgetPasswordCommand): Observable<void> {
    let url_ = this.baseUrl + '/api/Accounts/ForgetPassword';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(command);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
      }),
    };

    return this.http
      .request('post', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processForgetPassword(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processForgetPassword(<any>response_);
            } catch (e) {
              return <Observable<void>>(<any>_observableThrow(e));
            }
          } else return <Observable<void>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processForgetPassword(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return _observableOf<void>(<any>null);
        })
      );
    } else if (status === 404) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result404: any = null;
          let resultData404 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result404 = ProblemDetails.fromJS(resultData404);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result404
          );
        })
      );
    } else if (status === 400) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result400: any = null;
          let resultData400 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result400 = ProblemDetails.fromJS(resultData400);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result400
          );
        })
      );
    } else if (status === 422) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result422: any = null;
          let resultData422 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result422 = ValidationProblemDetails.fromJS(resultData422);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result422
          );
        })
      );
    } else {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let resultdefault: any = null;
          let resultDatadefault =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          resultdefault = ProblemDetails.fromJS(resultDatadefault);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            resultdefault
          );
        })
      );
    }
  }

  uploadPicture(
    userId: string | null | undefined,
    picture: FileParameter | null | undefined
  ): Observable<void> {
    let url_ = this.baseUrl + '/api/Accounts/UploadPicture';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = new FormData();
    if (userId !== null && userId !== undefined)
      content_.append('UserId', userId.toString());
    if (picture !== null && picture !== undefined)
      content_.append(
        'Picture',
        picture.data,
        picture.fileName ? picture.fileName : 'Picture'
      );

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({}),
    };

    return this.http
      .request('put', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processUploadPicture(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processUploadPicture(<any>response_);
            } catch (e) {
              return <Observable<void>>(<any>_observableThrow(e));
            }
          } else return <Observable<void>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processUploadPicture(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return _observableOf<void>(<any>null);
        })
      );
    } else if (status === 404) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result404: any = null;
          let resultData404 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result404 = ProblemDetails.fromJS(resultData404);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result404
          );
        })
      );
    } else if (status === 400) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result400: any = null;
          let resultData400 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result400 = ProblemDetails.fromJS(resultData400);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result400
          );
        })
      );
    } else if (status === 422) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result422: any = null;
          let resultData422 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result422 = ValidationProblemDetails.fromJS(resultData422);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result422
          );
        })
      );
    } else {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let resultdefault: any = null;
          let resultDatadefault =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          resultdefault = ProblemDetails.fromJS(resultDatadefault);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            resultdefault
          );
        })
      );
    }
  }

  changeProfile(
    picture: FileParameter | null | undefined,
    email: string | null | undefined,
    fullName_FirstName: string | null | undefined,
    fullName_LastName: string | null | undefined,
    nationalId: string | null | undefined
  ): Observable<void> {
    let url_ = this.baseUrl + '/api/Accounts/ChangeProfile';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = new FormData();
    if (picture !== null && picture !== undefined)
      content_.append(
        'Picture',
        picture.data,
        picture.fileName ? picture.fileName : 'Picture'
      );
    if (email !== null && email !== undefined) content_.append('Email', email.toString());
    if (fullName_FirstName !== null && fullName_FirstName !== undefined)
      content_.append('FullName.FirstName', fullName_FirstName.toString());
    if (fullName_LastName !== null && fullName_LastName !== undefined)
      content_.append('FullName.LastName', fullName_LastName.toString());
    if (nationalId !== null && nationalId !== undefined)
      content_.append('NationalId', nationalId.toString());

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({}),
    };

    return this.http
      .request('put', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processChangeProfile(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processChangeProfile(<any>response_);
            } catch (e) {
              return <Observable<void>>(<any>_observableThrow(e));
            }
          } else return <Observable<void>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processChangeProfile(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return _observableOf<void>(<any>null);
        })
      );
    } else if (status === 404) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result404: any = null;
          let resultData404 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result404 = ProblemDetails.fromJS(resultData404);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result404
          );
        })
      );
    } else if (status === 400) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result400: any = null;
          let resultData400 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result400 = ProblemDetails.fromJS(resultData400);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result400
          );
        })
      );
    } else if (status === 422) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result422: any = null;
          let resultData422 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result422 = ValidationProblemDetails.fromJS(resultData422);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result422
          );
        })
      );
    } else {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let resultdefault: any = null;
          let resultDatadefault =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          resultdefault = ProblemDetails.fromJS(resultDatadefault);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            resultdefault
          );
        })
      );
    }
  }

  changePhoneNumber(command: ChangePhoneNumberCommand): Observable<void> {
    let url_ = this.baseUrl + '/api/Accounts/ChangePhoneNumber';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(command);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
      }),
    };

    return this.http
      .request('put', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processChangePhoneNumber(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processChangePhoneNumber(<any>response_);
            } catch (e) {
              return <Observable<void>>(<any>_observableThrow(e));
            }
          } else return <Observable<void>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processChangePhoneNumber(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return _observableOf<void>(<any>null);
        })
      );
    } else if (status === 404) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result404: any = null;
          let resultData404 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result404 = ProblemDetails.fromJS(resultData404);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result404
          );
        })
      );
    } else if (status === 400) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result400: any = null;
          let resultData400 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result400 = ProblemDetails.fromJS(resultData400);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result400
          );
        })
      );
    } else if (status === 422) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result422: any = null;
          let resultData422 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result422 = ValidationProblemDetails.fromJS(resultData422);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result422
          );
        })
      );
    } else {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let resultdefault: any = null;
          let resultDatadefault =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          resultdefault = ProblemDetails.fromJS(resultDatadefault);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            resultdefault
          );
        })
      );
    }
  }

  changePassword(command: ChangePasswordCommand): Observable<void> {
    let url_ = this.baseUrl + '/api/Accounts/ChangePassword';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(command);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
      }),
    };

    return this.http
      .request('put', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processChangePassword(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processChangePassword(<any>response_);
            } catch (e) {
              return <Observable<void>>(<any>_observableThrow(e));
            }
          } else return <Observable<void>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processChangePassword(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return _observableOf<void>(<any>null);
        })
      );
    } else if (status === 404) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result404: any = null;
          let resultData404 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result404 = ProblemDetails.fromJS(resultData404);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result404
          );
        })
      );
    } else if (status === 400) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result400: any = null;
          let resultData400 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result400 = ProblemDetails.fromJS(resultData400);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result400
          );
        })
      );
    } else if (status === 422) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result422: any = null;
          let resultData422 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result422 = ValidationProblemDetails.fromJS(resultData422);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result422
          );
        })
      );
    } else {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let resultdefault: any = null;
          let resultDatadefault =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          resultdefault = ProblemDetails.fromJS(resultDatadefault);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            resultdefault
          );
        })
      );
    }
  }

  changeLanguage(command: ChangeLanguageCommand): Observable<void> {
    let url_ = this.baseUrl + '/api/Accounts/ChangeLanguage';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(command);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
      }),
    };

    return this.http
      .request('put', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processChangeLanguage(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processChangeLanguage(<any>response_);
            } catch (e) {
              return <Observable<void>>(<any>_observableThrow(e));
            }
          } else return <Observable<void>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processChangeLanguage(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return _observableOf<void>(<any>null);
        })
      );
    } else if (status === 404) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result404: any = null;
          let resultData404 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result404 = ProblemDetails.fromJS(resultData404);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result404
          );
        })
      );
    } else if (status === 400) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result400: any = null;
          let resultData400 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result400 = ProblemDetails.fromJS(resultData400);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result400
          );
        })
      );
    } else if (status === 422) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result422: any = null;
          let resultData422 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result422 = ValidationProblemDetails.fromJS(resultData422);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result422
          );
        })
      );
    } else {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let resultdefault: any = null;
          let resultDatadefault =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          resultdefault = ProblemDetails.fromJS(resultDatadefault);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            resultdefault
          );
        })
      );
    }
  }

  resetUserPassword(command: ResetUserPasswordCommand): Observable<void> {
    let url_ = this.baseUrl + '/api/Accounts/ResetUserPassword';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(command);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
      }),
    };

    return this.http
      .request('put', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processResetUserPassword(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processResetUserPassword(<any>response_);
            } catch (e) {
              return <Observable<void>>(<any>_observableThrow(e));
            }
          } else return <Observable<void>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processResetUserPassword(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return _observableOf<void>(<any>null);
        })
      );
    } else if (status === 404) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result404: any = null;
          let resultData404 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result404 = ProblemDetails.fromJS(resultData404);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result404
          );
        })
      );
    } else if (status === 400) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result400: any = null;
          let resultData400 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result400 = ProblemDetails.fromJS(resultData400);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result400
          );
        })
      );
    } else if (status === 422) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result422: any = null;
          let resultData422 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result422 = ValidationProblemDetails.fromJS(resultData422);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result422
          );
        })
      );
    } else {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let resultdefault: any = null;
          let resultDatadefault =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          resultdefault = ProblemDetails.fromJS(resultDatadefault);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            resultdefault
          );
        })
      );
    }
  }

  ban(command: AccountsBanCommand): Observable<void> {
    let url_ = this.baseUrl + '/api/Accounts/Ban';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(command);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
      }),
    };

    return this.http
      .request('put', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processBan(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processBan(<any>response_);
            } catch (e) {
              return <Observable<void>>(<any>_observableThrow(e));
            }
          } else return <Observable<void>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processBan(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return _observableOf<void>(<any>null);
        })
      );
    } else if (status === 404) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result404: any = null;
          let resultData404 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result404 = ProblemDetails.fromJS(resultData404);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result404
          );
        })
      );
    } else if (status === 400) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result400: any = null;
          let resultData400 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result400 = ProblemDetails.fromJS(resultData400);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result400
          );
        })
      );
    } else if (status === 422) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result422: any = null;
          let resultData422 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result422 = ValidationProblemDetails.fromJS(resultData422);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result422
          );
        })
      );
    } else {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let resultdefault: any = null;
          let resultDatadefault =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          resultdefault = ProblemDetails.fromJS(resultDatadefault);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            resultdefault
          );
        })
      );
    }
  }

  logout(): Observable<void> {
    let url_ = this.baseUrl + '/api/Accounts/Logout';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({}),
    };

    return this.http
      .request('delete', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processLogout(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processLogout(<any>response_);
            } catch (e) {
              return <Observable<void>>(<any>_observableThrow(e));
            }
          } else return <Observable<void>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processLogout(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return _observableOf<void>(<any>null);
        })
      );
    } else if (status === 404) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result404: any = null;
          let resultData404 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result404 = ProblemDetails.fromJS(resultData404);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result404
          );
        })
      );
    } else if (status === 422) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result422: any = null;
          let resultData422 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result422 = ValidationProblemDetails.fromJS(resultData422);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result422
          );
        })
      );
    } else {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let resultdefault: any = null;
          let resultDatadefault =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          resultdefault = ProblemDetails.fromJS(resultDatadefault);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            resultdefault
          );
        })
      );
    }
  }
}

export interface IAppointmentsClient {
  getServiceProviders(): Observable<ServiceProviderVm[]>;
  getServiceData(serviceId: number | undefined): Observable<ServiceDataVm>;
  getAvailableAppointments(
    branchId: number | undefined,
    serviceId: number | undefined
  ): Observable<AvailableAppointmentVm>;
  getDateReservations(
    branchId: number | undefined,
    serviceId: number | undefined,
    date: Date | undefined
  ): Observable<ReservationVm[]>;
  getReservations(): Observable<ReservationFullVm[]>;
  addReservation(command: AppointmentsPostCommand): Observable<AppointmentResponse>;
  cancelReservation(reservationId: number | undefined): Observable<FileResponse>;
}

@Injectable({
  providedIn: 'root',
})
export class AppointmentsClient implements IAppointmentsClient {
  private http: HttpClient;
  private baseUrl: string;
  protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

  constructor(
    @Inject(HttpClient) http: HttpClient,
    @Optional() @Inject(API_BASE_URL) baseUrl?: string
  ) {
    this.http = http;
    this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : '';
  }

  getServiceProviders(): Observable<ServiceProviderVm[]> {
    let url_ = this.baseUrl + '/api/Appointments/GetServiceProviders';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'application/json',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetServiceProviders(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetServiceProviders(<any>response_);
            } catch (e) {
              return <Observable<ServiceProviderVm[]>>(<any>_observableThrow(e));
            }
          } else
            return <Observable<ServiceProviderVm[]>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processGetServiceProviders(
    response: HttpResponseBase
  ): Observable<ServiceProviderVm[]> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          if (Array.isArray(resultData200)) {
            result200 = [] as any;
            for (let item of resultData200)
              result200!.push(ServiceProviderVm.fromJS(item));
          } else {
            result200 = <any>null;
          }
          return _observableOf(result200);
        })
      );
    } else {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let resultdefault: any = null;
          let resultDatadefault =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          resultdefault = ProblemDetails.fromJS(resultDatadefault);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            resultdefault
          );
        })
      );
    }
  }

  getServiceData(serviceId: number | undefined): Observable<ServiceDataVm> {
    let url_ = this.baseUrl + '/api/Appointments/GetServiceData?';
    if (serviceId === null) throw new Error("The parameter 'serviceId' cannot be null.");
    else if (serviceId !== undefined)
      url_ += 'serviceId=' + encodeURIComponent('' + serviceId) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'application/json',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetServiceData(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetServiceData(<any>response_);
            } catch (e) {
              return <Observable<ServiceDataVm>>(<any>_observableThrow(e));
            }
          } else return <Observable<ServiceDataVm>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processGetServiceData(response: HttpResponseBase): Observable<ServiceDataVm> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = ServiceDataVm.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status === 422) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result422: any = null;
          let resultData422 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result422 = ValidationProblemDetails.fromJS(resultData422);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result422
          );
        })
      );
    } else {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let resultdefault: any = null;
          let resultDatadefault =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          resultdefault = ProblemDetails.fromJS(resultDatadefault);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            resultdefault
          );
        })
      );
    }
  }

  getAvailableAppointments(
    branchId: number | undefined,
    serviceId: number | undefined
  ): Observable<AvailableAppointmentVm> {
    let url_ = this.baseUrl + '/api/Appointments/GetAvailableAppointments?';
    if (branchId === null) throw new Error("The parameter 'branchId' cannot be null.");
    else if (branchId !== undefined)
      url_ += 'BranchId=' + encodeURIComponent('' + branchId) + '&';
    if (serviceId === null) throw new Error("The parameter 'serviceId' cannot be null.");
    else if (serviceId !== undefined)
      url_ += 'ServiceId=' + encodeURIComponent('' + serviceId) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'application/json',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetAvailableAppointments(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetAvailableAppointments(<any>response_);
            } catch (e) {
              return <Observable<AvailableAppointmentVm>>(<any>_observableThrow(e));
            }
          } else
            return <Observable<AvailableAppointmentVm>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processGetAvailableAppointments(
    response: HttpResponseBase
  ): Observable<AvailableAppointmentVm> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = AvailableAppointmentVm.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status === 422) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result422: any = null;
          let resultData422 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result422 = ValidationProblemDetails.fromJS(resultData422);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result422
          );
        })
      );
    } else {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let resultdefault: any = null;
          let resultDatadefault =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          resultdefault = ProblemDetails.fromJS(resultDatadefault);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            resultdefault
          );
        })
      );
    }
  }

  getDateReservations(
    branchId: number | undefined,
    serviceId: number | undefined,
    date: Date | undefined
  ): Observable<ReservationVm[]> {
    let url_ = this.baseUrl + '/api/Appointments/GetDateReservations?';
    if (branchId === null) throw new Error("The parameter 'branchId' cannot be null.");
    else if (branchId !== undefined)
      url_ += 'BranchId=' + encodeURIComponent('' + branchId) + '&';
    if (serviceId === null) throw new Error("The parameter 'serviceId' cannot be null.");
    else if (serviceId !== undefined)
      url_ += 'ServiceId=' + encodeURIComponent('' + serviceId) + '&';
    if (date === null) throw new Error("The parameter 'date' cannot be null.");
    else if (date !== undefined)
      url_ += 'Date=' + encodeURIComponent(date ? '' + date.toJSON() : '') + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'application/json',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetDateReservations(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetDateReservations(<any>response_);
            } catch (e) {
              return <Observable<ReservationVm[]>>(<any>_observableThrow(e));
            }
          } else return <Observable<ReservationVm[]>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processGetDateReservations(
    response: HttpResponseBase
  ): Observable<ReservationVm[]> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          if (Array.isArray(resultData200)) {
            result200 = [] as any;
            for (let item of resultData200) result200!.push(ReservationVm.fromJS(item));
          } else {
            result200 = <any>null;
          }
          return _observableOf(result200);
        })
      );
    } else if (status === 422) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result422: any = null;
          let resultData422 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result422 = ValidationProblemDetails.fromJS(resultData422);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result422
          );
        })
      );
    } else {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let resultdefault: any = null;
          let resultDatadefault =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          resultdefault = ProblemDetails.fromJS(resultDatadefault);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            resultdefault
          );
        })
      );
    }
  }

  getReservations(): Observable<ReservationFullVm[]> {
    let url_ = this.baseUrl + '/api/Appointments/GetReservations';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'application/json',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetReservations(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetReservations(<any>response_);
            } catch (e) {
              return <Observable<ReservationFullVm[]>>(<any>_observableThrow(e));
            }
          } else
            return <Observable<ReservationFullVm[]>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processGetReservations(
    response: HttpResponseBase
  ): Observable<ReservationFullVm[]> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          if (Array.isArray(resultData200)) {
            result200 = [] as any;
            for (let item of resultData200)
              result200!.push(ReservationFullVm.fromJS(item));
          } else {
            result200 = <any>null;
          }
          return _observableOf(result200);
        })
      );
    } else {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let resultdefault: any = null;
          let resultDatadefault =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          resultdefault = ProblemDetails.fromJS(resultDatadefault);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            resultdefault
          );
        })
      );
    }
  }

  addReservation(command: AppointmentsPostCommand): Observable<AppointmentResponse> {
    let url_ = this.baseUrl + '/api/Appointments/AddReservation';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(command);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
        Accept: 'application/json',
      }),
    };

    return this.http
      .request('post', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processAddReservation(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processAddReservation(<any>response_);
            } catch (e) {
              return <Observable<AppointmentResponse>>(<any>_observableThrow(e));
            }
          } else
            return <Observable<AppointmentResponse>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processAddReservation(
    response: HttpResponseBase
  ): Observable<AppointmentResponse> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = AppointmentResponse.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<AppointmentResponse>(<any>null);
  }

  cancelReservation(reservationId: number | undefined): Observable<FileResponse> {
    let url_ = this.baseUrl + '/api/Appointments/CancelReservation?';
    if (reservationId === null)
      throw new Error("The parameter 'reservationId' cannot be null.");
    else if (reservationId !== undefined)
      url_ += 'reservationId=' + encodeURIComponent('' + reservationId) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'application/octet-stream',
      }),
    };

    return this.http
      .request('delete', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processCancelReservation(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processCancelReservation(<any>response_);
            } catch (e) {
              return <Observable<FileResponse>>(<any>_observableThrow(e));
            }
          } else return <Observable<FileResponse>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processCancelReservation(
    response: HttpResponseBase
  ): Observable<FileResponse> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200 || status === 206) {
      const contentDisposition = response.headers
        ? response.headers.get('content-disposition')
        : undefined;
      const fileNameMatch = contentDisposition
        ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition)
        : undefined;
      const fileName =
        fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
      return _observableOf({
        fileName: fileName,
        data: <any>responseBlob,
        status: status,
        headers: _headers,
      });
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<FileResponse>(<any>null);
  }
}

export interface IBranchesClient {
  getPage(
    serviceProviderId: number | null | undefined,
    offset: number | null | undefined,
    pageIndex: number | null | undefined,
    search: string | null | undefined,
    ascending: boolean | undefined,
    sortBy: string | null | undefined
  ): Observable<PaginatedListOfBranchDashboardVm>;
  getCounterData(id: number | undefined): Observable<CounterDataDto>;
  get(id: number | undefined): Observable<BranchDto>;
  post(
    code: string | null | undefined,
    name_Ar: string | null | undefined,
    name_En: string | null | undefined,
    contactInfo_Name: string | null | undefined,
    contactInfo_Email: string | null | undefined,
    contactInfo_PhoneNumber: string | null | undefined,
    address_DistrictId: number | undefined,
    address_Street_Ar: string | null | undefined,
    address_Street_En: string | null | undefined,
    address_Longitude: number | undefined,
    address_Latitude: number | undefined,
    logo: FileParameter | null | undefined,
    isActive: boolean | undefined,
    serviceProviderId: number | undefined
  ): Observable<HttpResultOfInteger>;
  put(
    id: number | undefined,
    code: string | null | undefined,
    name_Ar: string | null | undefined,
    name_En: string | null | undefined,
    contactInfo_Name: string | null | undefined,
    contactInfo_Email: string | null | undefined,
    contactInfo_PhoneNumber: string | null | undefined,
    address_DistrictId: number | undefined,
    address_Street_Ar: string | null | undefined,
    address_Street_En: string | null | undefined,
    address_Longitude: number | undefined,
    address_Latitude: number | undefined,
    logo: FileParameter | null | undefined,
    isActive: boolean | undefined,
    serviceProviderId: number | undefined
  ): Observable<void>;
  delete(id: number | undefined): Observable<void>;
  putCounterData(command: BranchesPutCounterDataCommand): Observable<void>;
}

@Injectable({
  providedIn: 'root',
})
export class BranchesClient implements IBranchesClient {
  private http: HttpClient;
  private baseUrl: string;
  protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

  constructor(
    @Inject(HttpClient) http: HttpClient,
    @Optional() @Inject(API_BASE_URL) baseUrl?: string
  ) {
    this.http = http;
    this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : '';
  }

  getPage(
    serviceProviderId: number | null | undefined,
    offset: number | null | undefined,
    pageIndex: number | null | undefined,
    search: string | null | undefined,
    ascending: boolean | undefined,
    sortBy: string | null | undefined
  ): Observable<PaginatedListOfBranchDashboardVm> {
    let url_ = this.baseUrl + '/api/Branches/GetPage?';
    if (serviceProviderId !== undefined && serviceProviderId !== null)
      url_ += 'ServiceProviderId=' + encodeURIComponent('' + serviceProviderId) + '&';
    if (offset !== undefined && offset !== null)
      url_ += 'Offset=' + encodeURIComponent('' + offset) + '&';
    if (pageIndex !== undefined && pageIndex !== null)
      url_ += 'PageIndex=' + encodeURIComponent('' + pageIndex) + '&';
    if (search !== undefined && search !== null)
      url_ += 'Search=' + encodeURIComponent('' + search) + '&';
    if (ascending === null) throw new Error("The parameter 'ascending' cannot be null.");
    else if (ascending !== undefined)
      url_ += 'Ascending=' + encodeURIComponent('' + ascending) + '&';
    if (sortBy !== undefined && sortBy !== null)
      url_ += 'SortBy=' + encodeURIComponent('' + sortBy) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'application/json',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetPage(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetPage(<any>response_);
            } catch (e) {
              return <Observable<PaginatedListOfBranchDashboardVm>>(
                (<any>_observableThrow(e))
              );
            }
          } else
            return <Observable<PaginatedListOfBranchDashboardVm>>(
              (<any>_observableThrow(response_))
            );
        })
      );
  }

  protected processGetPage(
    response: HttpResponseBase
  ): Observable<PaginatedListOfBranchDashboardVm> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = PaginatedListOfBranchDashboardVm.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status === 422) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result422: any = null;
          let resultData422 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result422 = ValidationProblemDetails.fromJS(resultData422);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result422
          );
        })
      );
    } else {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let resultdefault: any = null;
          let resultDatadefault =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          resultdefault = ProblemDetails.fromJS(resultDatadefault);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            resultdefault
          );
        })
      );
    }
  }

  getCounterData(id: number | undefined): Observable<CounterDataDto> {
    let url_ = this.baseUrl + '/api/Branches/GetCounterData?';
    if (id === null) throw new Error("The parameter 'id' cannot be null.");
    else if (id !== undefined) url_ += 'id=' + encodeURIComponent('' + id) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'application/json',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetCounterData(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetCounterData(<any>response_);
            } catch (e) {
              return <Observable<CounterDataDto>>(<any>_observableThrow(e));
            }
          } else return <Observable<CounterDataDto>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processGetCounterData(
    response: HttpResponseBase
  ): Observable<CounterDataDto> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = CounterDataDto.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status === 422) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result422: any = null;
          let resultData422 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result422 = ValidationProblemDetails.fromJS(resultData422);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result422
          );
        })
      );
    } else {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let resultdefault: any = null;
          let resultDatadefault =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          resultdefault = ProblemDetails.fromJS(resultDatadefault);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            resultdefault
          );
        })
      );
    }
  }

  get(id: number | undefined): Observable<BranchDto> {
    let url_ = this.baseUrl + '/api/Branches?';
    if (id === null) throw new Error("The parameter 'id' cannot be null.");
    else if (id !== undefined) url_ += 'id=' + encodeURIComponent('' + id) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'application/json',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGet(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGet(<any>response_);
            } catch (e) {
              return <Observable<BranchDto>>(<any>_observableThrow(e));
            }
          } else return <Observable<BranchDto>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processGet(response: HttpResponseBase): Observable<BranchDto> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = BranchDto.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status === 422) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result422: any = null;
          let resultData422 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result422 = ValidationProblemDetails.fromJS(resultData422);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result422
          );
        })
      );
    } else {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let resultdefault: any = null;
          let resultDatadefault =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          resultdefault = ProblemDetails.fromJS(resultDatadefault);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            resultdefault
          );
        })
      );
    }
  }

  post(
    code: string | null | undefined,
    name_Ar: string | null | undefined,
    name_En: string | null | undefined,
    contactInfo_Name: string | null | undefined,
    contactInfo_Email: string | null | undefined,
    contactInfo_PhoneNumber: string | null | undefined,
    address_DistrictId: number | undefined,
    address_Street_Ar: string | null | undefined,
    address_Street_En: string | null | undefined,
    address_Longitude: number | undefined,
    address_Latitude: number | undefined,
    logo: FileParameter | null | undefined,
    isActive: boolean | undefined,
    serviceProviderId: number | undefined
  ): Observable<HttpResultOfInteger> {
    let url_ = this.baseUrl + '/api/Branches';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = new FormData();
    if (code !== null && code !== undefined) content_.append('Code', code.toString());
    if (name_Ar !== null && name_Ar !== undefined)
      content_.append('Name.Ar', name_Ar.toString());
    if (name_En !== null && name_En !== undefined)
      content_.append('Name.En', name_En.toString());
    if (contactInfo_Name !== null && contactInfo_Name !== undefined)
      content_.append('ContactInfo.Name', contactInfo_Name.toString());
    if (contactInfo_Email !== null && contactInfo_Email !== undefined)
      content_.append('ContactInfo.Email', contactInfo_Email.toString());
    if (contactInfo_PhoneNumber !== null && contactInfo_PhoneNumber !== undefined)
      content_.append('ContactInfo.PhoneNumber', contactInfo_PhoneNumber.toString());
    if (address_DistrictId === null || address_DistrictId === undefined)
      throw new Error("The parameter 'address_DistrictId' cannot be null.");
    else content_.append('Address.DistrictId', address_DistrictId.toString());
    if (address_Street_Ar !== null && address_Street_Ar !== undefined)
      content_.append('Address.Street.Ar', address_Street_Ar.toString());
    if (address_Street_En !== null && address_Street_En !== undefined)
      content_.append('Address.Street.En', address_Street_En.toString());
    if (address_Longitude === null || address_Longitude === undefined)
      throw new Error("The parameter 'address_Longitude' cannot be null.");
    else content_.append('Address.Longitude', address_Longitude.toString());
    if (address_Latitude === null || address_Latitude === undefined)
      throw new Error("The parameter 'address_Latitude' cannot be null.");
    else content_.append('Address.Latitude', address_Latitude.toString());
    if (logo !== null && logo !== undefined)
      content_.append('Logo', logo.data, logo.fileName ? logo.fileName : 'Logo');
    if (isActive === null || isActive === undefined)
      throw new Error("The parameter 'isActive' cannot be null.");
    else content_.append('IsActive', isActive.toString());
    if (serviceProviderId === null || serviceProviderId === undefined)
      throw new Error("The parameter 'serviceProviderId' cannot be null.");
    else content_.append('ServiceProviderId', serviceProviderId.toString());

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'application/json',
      }),
    };

    return this.http
      .request('post', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processPost(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processPost(<any>response_);
            } catch (e) {
              return <Observable<HttpResultOfInteger>>(<any>_observableThrow(e));
            }
          } else
            return <Observable<HttpResultOfInteger>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processPost(response: HttpResponseBase): Observable<HttpResultOfInteger> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = HttpResultOfInteger.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status === 404) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result404: any = null;
          let resultData404 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result404 = ProblemDetails.fromJS(resultData404);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result404
          );
        })
      );
    } else if (status === 400) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result400: any = null;
          let resultData400 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result400 = ProblemDetails.fromJS(resultData400);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result400
          );
        })
      );
    } else if (status === 422) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result422: any = null;
          let resultData422 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result422 = ValidationProblemDetails.fromJS(resultData422);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result422
          );
        })
      );
    } else {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let resultdefault: any = null;
          let resultDatadefault =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          resultdefault = ProblemDetails.fromJS(resultDatadefault);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            resultdefault
          );
        })
      );
    }
  }

  put(
    id: number | undefined,
    code: string | null | undefined,
    name_Ar: string | null | undefined,
    name_En: string | null | undefined,
    contactInfo_Name: string | null | undefined,
    contactInfo_Email: string | null | undefined,
    contactInfo_PhoneNumber: string | null | undefined,
    address_DistrictId: number | undefined,
    address_Street_Ar: string | null | undefined,
    address_Street_En: string | null | undefined,
    address_Longitude: number | undefined,
    address_Latitude: number | undefined,
    logo: FileParameter | null | undefined,
    isActive: boolean | undefined,
    serviceProviderId: number | undefined
  ): Observable<void> {
    let url_ = this.baseUrl + '/api/Branches';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = new FormData();
    if (id === null || id === undefined)
      throw new Error("The parameter 'id' cannot be null.");
    else content_.append('Id', id.toString());
    if (code !== null && code !== undefined) content_.append('Code', code.toString());
    if (name_Ar !== null && name_Ar !== undefined)
      content_.append('Name.Ar', name_Ar.toString());
    if (name_En !== null && name_En !== undefined)
      content_.append('Name.En', name_En.toString());
    if (contactInfo_Name !== null && contactInfo_Name !== undefined)
      content_.append('ContactInfo.Name', contactInfo_Name.toString());
    if (contactInfo_Email !== null && contactInfo_Email !== undefined)
      content_.append('ContactInfo.Email', contactInfo_Email.toString());
    if (contactInfo_PhoneNumber !== null && contactInfo_PhoneNumber !== undefined)
      content_.append('ContactInfo.PhoneNumber', contactInfo_PhoneNumber.toString());
    if (address_DistrictId === null || address_DistrictId === undefined)
      throw new Error("The parameter 'address_DistrictId' cannot be null.");
    else content_.append('Address.DistrictId', address_DistrictId.toString());
    if (address_Street_Ar !== null && address_Street_Ar !== undefined)
      content_.append('Address.Street.Ar', address_Street_Ar.toString());
    if (address_Street_En !== null && address_Street_En !== undefined)
      content_.append('Address.Street.En', address_Street_En.toString());
    if (address_Longitude === null || address_Longitude === undefined)
      throw new Error("The parameter 'address_Longitude' cannot be null.");
    else content_.append('Address.Longitude', address_Longitude.toString());
    if (address_Latitude === null || address_Latitude === undefined)
      throw new Error("The parameter 'address_Latitude' cannot be null.");
    else content_.append('Address.Latitude', address_Latitude.toString());
    if (logo !== null && logo !== undefined)
      content_.append('Logo', logo.data, logo.fileName ? logo.fileName : 'Logo');
    if (isActive === null || isActive === undefined)
      throw new Error("The parameter 'isActive' cannot be null.");
    else content_.append('IsActive', isActive.toString());
    if (serviceProviderId === null || serviceProviderId === undefined)
      throw new Error("The parameter 'serviceProviderId' cannot be null.");
    else content_.append('ServiceProviderId', serviceProviderId.toString());

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({}),
    };

    return this.http
      .request('put', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processPut(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processPut(<any>response_);
            } catch (e) {
              return <Observable<void>>(<any>_observableThrow(e));
            }
          } else return <Observable<void>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processPut(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return _observableOf<void>(<any>null);
        })
      );
    } else if (status === 404) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result404: any = null;
          let resultData404 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result404 = ProblemDetails.fromJS(resultData404);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result404
          );
        })
      );
    } else if (status === 400) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result400: any = null;
          let resultData400 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result400 = ProblemDetails.fromJS(resultData400);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result400
          );
        })
      );
    } else if (status === 422) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result422: any = null;
          let resultData422 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result422 = ValidationProblemDetails.fromJS(resultData422);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result422
          );
        })
      );
    } else {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let resultdefault: any = null;
          let resultDatadefault =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          resultdefault = ProblemDetails.fromJS(resultDatadefault);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            resultdefault
          );
        })
      );
    }
  }

  delete(id: number | undefined): Observable<void> {
    let url_ = this.baseUrl + '/api/Branches?';
    if (id === null) throw new Error("The parameter 'id' cannot be null.");
    else if (id !== undefined) url_ += 'id=' + encodeURIComponent('' + id) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({}),
    };

    return this.http
      .request('delete', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processDelete(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processDelete(<any>response_);
            } catch (e) {
              return <Observable<void>>(<any>_observableThrow(e));
            }
          } else return <Observable<void>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processDelete(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return _observableOf<void>(<any>null);
        })
      );
    } else if (status === 404) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result404: any = null;
          let resultData404 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result404 = ProblemDetails.fromJS(resultData404);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result404
          );
        })
      );
    } else if (status === 422) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result422: any = null;
          let resultData422 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result422 = ValidationProblemDetails.fromJS(resultData422);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result422
          );
        })
      );
    } else {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let resultdefault: any = null;
          let resultDatadefault =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          resultdefault = ProblemDetails.fromJS(resultDatadefault);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            resultdefault
          );
        })
      );
    }
  }

  putCounterData(command: BranchesPutCounterDataCommand): Observable<void> {
    let url_ = this.baseUrl + '/api/Branches/PutCounterData';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(command);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
      }),
    };

    return this.http
      .request('put', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processPutCounterData(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processPutCounterData(<any>response_);
            } catch (e) {
              return <Observable<void>>(<any>_observableThrow(e));
            }
          } else return <Observable<void>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processPutCounterData(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return _observableOf<void>(<any>null);
        })
      );
    } else if (status === 404) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result404: any = null;
          let resultData404 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result404 = ProblemDetails.fromJS(resultData404);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result404
          );
        })
      );
    } else if (status === 400) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result400: any = null;
          let resultData400 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result400 = ProblemDetails.fromJS(resultData400);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result400
          );
        })
      );
    } else if (status === 422) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result422: any = null;
          let resultData422 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result422 = ValidationProblemDetails.fromJS(resultData422);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result422
          );
        })
      );
    } else {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let resultdefault: any = null;
          let resultDatadefault =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          resultdefault = ProblemDetails.fromJS(resultDatadefault);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            resultdefault
          );
        })
      );
    }
  }
}

export interface ICategoriesClient {
  getPage(
    offset: number | null | undefined,
    pageIndex: number | null | undefined,
    search: string | null | undefined,
    ascending: boolean | undefined,
    sortBy: string | null | undefined
  ): Observable<PaginatedListOfCategoryDto>;
  getList(): Observable<CategoryVm[]>;
  post(command: CategoriesPostCommand): Observable<HttpResultOfInteger>;
  put(command: CategoriesPutCommand): Observable<void>;
  delete(id: number | undefined): Observable<void>;
}

@Injectable({
  providedIn: 'root',
})
export class CategoriesClient implements ICategoriesClient {
  private http: HttpClient;
  private baseUrl: string;
  protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

  constructor(
    @Inject(HttpClient) http: HttpClient,
    @Optional() @Inject(API_BASE_URL) baseUrl?: string
  ) {
    this.http = http;
    this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : '';
  }

  getPage(
    offset: number | null | undefined,
    pageIndex: number | null | undefined,
    search: string | null | undefined,
    ascending: boolean | undefined,
    sortBy: string | null | undefined
  ): Observable<PaginatedListOfCategoryDto> {
    let url_ = this.baseUrl + '/api/Categories/GetPage?';
    if (offset !== undefined && offset !== null)
      url_ += 'Offset=' + encodeURIComponent('' + offset) + '&';
    if (pageIndex !== undefined && pageIndex !== null)
      url_ += 'PageIndex=' + encodeURIComponent('' + pageIndex) + '&';
    if (search !== undefined && search !== null)
      url_ += 'Search=' + encodeURIComponent('' + search) + '&';
    if (ascending === null) throw new Error("The parameter 'ascending' cannot be null.");
    else if (ascending !== undefined)
      url_ += 'Ascending=' + encodeURIComponent('' + ascending) + '&';
    if (sortBy !== undefined && sortBy !== null)
      url_ += 'SortBy=' + encodeURIComponent('' + sortBy) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'application/json',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetPage(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetPage(<any>response_);
            } catch (e) {
              return <Observable<PaginatedListOfCategoryDto>>(<any>_observableThrow(e));
            }
          } else
            return <Observable<PaginatedListOfCategoryDto>>(
              (<any>_observableThrow(response_))
            );
        })
      );
  }

  protected processGetPage(
    response: HttpResponseBase
  ): Observable<PaginatedListOfCategoryDto> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = PaginatedListOfCategoryDto.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status === 422) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result422: any = null;
          let resultData422 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result422 = ValidationProblemDetails.fromJS(resultData422);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result422
          );
        })
      );
    } else {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let resultdefault: any = null;
          let resultDatadefault =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          resultdefault = ProblemDetails.fromJS(resultDatadefault);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            resultdefault
          );
        })
      );
    }
  }

  getList(): Observable<CategoryVm[]> {
    let url_ = this.baseUrl + '/api/Categories/GetList';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'application/json',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetList(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetList(<any>response_);
            } catch (e) {
              return <Observable<CategoryVm[]>>(<any>_observableThrow(e));
            }
          } else return <Observable<CategoryVm[]>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processGetList(response: HttpResponseBase): Observable<CategoryVm[]> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          if (Array.isArray(resultData200)) {
            result200 = [] as any;
            for (let item of resultData200) result200!.push(CategoryVm.fromJS(item));
          } else {
            result200 = <any>null;
          }
          return _observableOf(result200);
        })
      );
    } else {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let resultdefault: any = null;
          let resultDatadefault =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          resultdefault = ProblemDetails.fromJS(resultDatadefault);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            resultdefault
          );
        })
      );
    }
  }

  post(command: CategoriesPostCommand): Observable<HttpResultOfInteger> {
    let url_ = this.baseUrl + '/api/Categories';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(command);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
        Accept: 'application/json',
      }),
    };

    return this.http
      .request('post', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processPost(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processPost(<any>response_);
            } catch (e) {
              return <Observable<HttpResultOfInteger>>(<any>_observableThrow(e));
            }
          } else
            return <Observable<HttpResultOfInteger>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processPost(response: HttpResponseBase): Observable<HttpResultOfInteger> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = HttpResultOfInteger.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status === 404) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result404: any = null;
          let resultData404 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result404 = ProblemDetails.fromJS(resultData404);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result404
          );
        })
      );
    } else if (status === 400) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result400: any = null;
          let resultData400 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result400 = ProblemDetails.fromJS(resultData400);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result400
          );
        })
      );
    } else if (status === 422) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result422: any = null;
          let resultData422 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result422 = ValidationProblemDetails.fromJS(resultData422);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result422
          );
        })
      );
    } else {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let resultdefault: any = null;
          let resultDatadefault =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          resultdefault = ProblemDetails.fromJS(resultDatadefault);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            resultdefault
          );
        })
      );
    }
  }

  put(command: CategoriesPutCommand): Observable<void> {
    let url_ = this.baseUrl + '/api/Categories';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(command);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
      }),
    };

    return this.http
      .request('put', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processPut(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processPut(<any>response_);
            } catch (e) {
              return <Observable<void>>(<any>_observableThrow(e));
            }
          } else return <Observable<void>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processPut(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return _observableOf<void>(<any>null);
        })
      );
    } else if (status === 404) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result404: any = null;
          let resultData404 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result404 = ProblemDetails.fromJS(resultData404);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result404
          );
        })
      );
    } else if (status === 400) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result400: any = null;
          let resultData400 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result400 = ProblemDetails.fromJS(resultData400);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result400
          );
        })
      );
    } else if (status === 422) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result422: any = null;
          let resultData422 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result422 = ValidationProblemDetails.fromJS(resultData422);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result422
          );
        })
      );
    } else {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let resultdefault: any = null;
          let resultDatadefault =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          resultdefault = ProblemDetails.fromJS(resultDatadefault);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            resultdefault
          );
        })
      );
    }
  }

  delete(id: number | undefined): Observable<void> {
    let url_ = this.baseUrl + '/api/Categories?';
    if (id === null) throw new Error("The parameter 'id' cannot be null.");
    else if (id !== undefined) url_ += 'id=' + encodeURIComponent('' + id) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({}),
    };

    return this.http
      .request('delete', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processDelete(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processDelete(<any>response_);
            } catch (e) {
              return <Observable<void>>(<any>_observableThrow(e));
            }
          } else return <Observable<void>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processDelete(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return _observableOf<void>(<any>null);
        })
      );
    } else if (status === 404) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result404: any = null;
          let resultData404 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result404 = ProblemDetails.fromJS(resultData404);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result404
          );
        })
      );
    } else if (status === 422) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result422: any = null;
          let resultData422 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result422 = ValidationProblemDetails.fromJS(resultData422);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result422
          );
        })
      );
    } else {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let resultdefault: any = null;
          let resultDatadefault =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          resultdefault = ProblemDetails.fromJS(resultDatadefault);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            resultdefault
          );
        })
      );
    }
  }
}

export interface IConfigsClient {
  get(): Observable<ConfigDto>;
  put(command: ConfigsPutCommand): Observable<void>;
}

@Injectable({
  providedIn: 'root',
})
export class ConfigsClient implements IConfigsClient {
  private http: HttpClient;
  private baseUrl: string;
  protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

  constructor(
    @Inject(HttpClient) http: HttpClient,
    @Optional() @Inject(API_BASE_URL) baseUrl?: string
  ) {
    this.http = http;
    this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : '';
  }

  get(): Observable<ConfigDto> {
    let url_ = this.baseUrl + '/api/Configs';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'application/json',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGet(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGet(<any>response_);
            } catch (e) {
              return <Observable<ConfigDto>>(<any>_observableThrow(e));
            }
          } else return <Observable<ConfigDto>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processGet(response: HttpResponseBase): Observable<ConfigDto> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = ConfigDto.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let resultdefault: any = null;
          let resultDatadefault =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          resultdefault = ProblemDetails.fromJS(resultDatadefault);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            resultdefault
          );
        })
      );
    }
  }

  put(command: ConfigsPutCommand): Observable<void> {
    let url_ = this.baseUrl + '/api/Configs';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(command);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
      }),
    };

    return this.http
      .request('put', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processPut(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processPut(<any>response_);
            } catch (e) {
              return <Observable<void>>(<any>_observableThrow(e));
            }
          } else return <Observable<void>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processPut(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return _observableOf<void>(<any>null);
        })
      );
    } else if (status === 404) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result404: any = null;
          let resultData404 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result404 = ProblemDetails.fromJS(resultData404);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result404
          );
        })
      );
    } else if (status === 400) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result400: any = null;
          let resultData400 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result400 = ProblemDetails.fromJS(resultData400);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result400
          );
        })
      );
    } else if (status === 422) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result422: any = null;
          let resultData422 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result422 = ValidationProblemDetails.fromJS(resultData422);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result422
          );
        })
      );
    } else {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let resultdefault: any = null;
          let resultDatadefault =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          resultdefault = ProblemDetails.fromJS(resultDatadefault);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            resultdefault
          );
        })
      );
    }
  }
}

export interface IContentsClient {
  getTnc(): Observable<ContentVm>;
  getPnp(): Observable<ContentVm>;
  get(lang: Language | undefined, type: ContentType | undefined): Observable<ContentVm>;
  put(command: ContentsPutCommand): Observable<void>;
}

@Injectable({
  providedIn: 'root',
})
export class ContentsClient implements IContentsClient {
  private http: HttpClient;
  private baseUrl: string;
  protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

  constructor(
    @Inject(HttpClient) http: HttpClient,
    @Optional() @Inject(API_BASE_URL) baseUrl?: string
  ) {
    this.http = http;
    this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : '';
  }

  getTnc(): Observable<ContentVm> {
    let url_ = this.baseUrl + '/api/Contents/GetTnc';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'application/json',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetTnc(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetTnc(<any>response_);
            } catch (e) {
              return <Observable<ContentVm>>(<any>_observableThrow(e));
            }
          } else return <Observable<ContentVm>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processGetTnc(response: HttpResponseBase): Observable<ContentVm> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = ContentVm.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let resultdefault: any = null;
          let resultDatadefault =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          resultdefault = ProblemDetails.fromJS(resultDatadefault);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            resultdefault
          );
        })
      );
    }
  }

  getPnp(): Observable<ContentVm> {
    let url_ = this.baseUrl + '/api/Contents/GetPnp';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'application/json',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetPnp(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetPnp(<any>response_);
            } catch (e) {
              return <Observable<ContentVm>>(<any>_observableThrow(e));
            }
          } else return <Observable<ContentVm>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processGetPnp(response: HttpResponseBase): Observable<ContentVm> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = ContentVm.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let resultdefault: any = null;
          let resultDatadefault =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          resultdefault = ProblemDetails.fromJS(resultDatadefault);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            resultdefault
          );
        })
      );
    }
  }

  get(lang: Language | undefined, type: ContentType | undefined): Observable<ContentVm> {
    let url_ = this.baseUrl + '/api/Contents?';
    if (lang === null) throw new Error("The parameter 'lang' cannot be null.");
    else if (lang !== undefined) url_ += 'Lang=' + encodeURIComponent('' + lang) + '&';
    if (type === null) throw new Error("The parameter 'type' cannot be null.");
    else if (type !== undefined) url_ += 'Type=' + encodeURIComponent('' + type) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'application/json',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGet(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGet(<any>response_);
            } catch (e) {
              return <Observable<ContentVm>>(<any>_observableThrow(e));
            }
          } else return <Observable<ContentVm>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processGet(response: HttpResponseBase): Observable<ContentVm> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = ContentVm.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status === 422) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result422: any = null;
          let resultData422 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result422 = ValidationProblemDetails.fromJS(resultData422);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result422
          );
        })
      );
    } else {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let resultdefault: any = null;
          let resultDatadefault =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          resultdefault = ProblemDetails.fromJS(resultDatadefault);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            resultdefault
          );
        })
      );
    }
  }

  put(command: ContentsPutCommand): Observable<void> {
    let url_ = this.baseUrl + '/api/Contents/Put';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(command);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
      }),
    };

    return this.http
      .request('put', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processPut(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processPut(<any>response_);
            } catch (e) {
              return <Observable<void>>(<any>_observableThrow(e));
            }
          } else return <Observable<void>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processPut(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return _observableOf<void>(<any>null);
        })
      );
    } else if (status === 404) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result404: any = null;
          let resultData404 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result404 = ProblemDetails.fromJS(resultData404);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result404
          );
        })
      );
    } else if (status === 400) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result400: any = null;
          let resultData400 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result400 = ProblemDetails.fromJS(resultData400);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result400
          );
        })
      );
    } else if (status === 422) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result422: any = null;
          let resultData422 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result422 = ValidationProblemDetails.fromJS(resultData422);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result422
          );
        })
      );
    } else {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let resultdefault: any = null;
          let resultDatadefault =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          resultdefault = ProblemDetails.fromJS(resultDatadefault);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            resultdefault
          );
        })
      );
    }
  }
}

export interface IControlsClient {
  getTodayStatus(): Observable<TodayStatusVm>;
  getWeekStatus(count: number | undefined): Observable<WeekStatusVm>;
  getDayStatus(date: Date | undefined): Observable<DayStatusVm>;
  getMonthStatus(date: Date | undefined): Observable<MonthStatusVm>;
  getProfile(): Observable<ControlsProfileVm>;
  updateWorkingDay(query: ControlsUpdateWorkingDayCommand): Observable<FileResponse>;
  postComment(query: ControlsPostCommentCommand): Observable<HttpResultOfInteger>;
  deleteComment(id: number | undefined): Observable<void>;
}

@Injectable({
  providedIn: 'root',
})
export class ControlsClient implements IControlsClient {
  private http: HttpClient;
  private baseUrl: string;
  protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

  constructor(
    @Inject(HttpClient) http: HttpClient,
    @Optional() @Inject(API_BASE_URL) baseUrl?: string
  ) {
    this.http = http;
    this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : '';
  }

  getTodayStatus(): Observable<TodayStatusVm> {
    let url_ = this.baseUrl + '/api/Controls/GetTodayStatus';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'application/json',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetTodayStatus(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetTodayStatus(<any>response_);
            } catch (e) {
              return <Observable<TodayStatusVm>>(<any>_observableThrow(e));
            }
          } else return <Observable<TodayStatusVm>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processGetTodayStatus(response: HttpResponseBase): Observable<TodayStatusVm> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = TodayStatusVm.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let resultdefault: any = null;
          let resultDatadefault =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          resultdefault = ProblemDetails.fromJS(resultDatadefault);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            resultdefault
          );
        })
      );
    }
  }

  getWeekStatus(count: number | undefined): Observable<WeekStatusVm> {
    let url_ = this.baseUrl + '/api/Controls/GetWeekStatus?';
    if (count === null) throw new Error("The parameter 'count' cannot be null.");
    else if (count !== undefined) url_ += 'Count=' + encodeURIComponent('' + count) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'application/json',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetWeekStatus(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetWeekStatus(<any>response_);
            } catch (e) {
              return <Observable<WeekStatusVm>>(<any>_observableThrow(e));
            }
          } else return <Observable<WeekStatusVm>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processGetWeekStatus(response: HttpResponseBase): Observable<WeekStatusVm> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = WeekStatusVm.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status === 422) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result422: any = null;
          let resultData422 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result422 = ValidationProblemDetails.fromJS(resultData422);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result422
          );
        })
      );
    } else {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let resultdefault: any = null;
          let resultDatadefault =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          resultdefault = ProblemDetails.fromJS(resultDatadefault);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            resultdefault
          );
        })
      );
    }
  }

  getDayStatus(date: Date | undefined): Observable<DayStatusVm> {
    let url_ = this.baseUrl + '/api/Controls/GetDayStatus?';
    if (date === null) throw new Error("The parameter 'date' cannot be null.");
    else if (date !== undefined)
      url_ += 'Date=' + encodeURIComponent(date ? '' + date.toJSON() : '') + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'application/json',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetDayStatus(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetDayStatus(<any>response_);
            } catch (e) {
              return <Observable<DayStatusVm>>(<any>_observableThrow(e));
            }
          } else return <Observable<DayStatusVm>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processGetDayStatus(response: HttpResponseBase): Observable<DayStatusVm> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = DayStatusVm.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status === 422) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result422: any = null;
          let resultData422 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result422 = ValidationProblemDetails.fromJS(resultData422);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result422
          );
        })
      );
    } else {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let resultdefault: any = null;
          let resultDatadefault =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          resultdefault = ProblemDetails.fromJS(resultDatadefault);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            resultdefault
          );
        })
      );
    }
  }

  getMonthStatus(date: Date | undefined): Observable<MonthStatusVm> {
    let url_ = this.baseUrl + '/api/Controls/GetMonthStatus?';
    if (date === null) throw new Error("The parameter 'date' cannot be null.");
    else if (date !== undefined)
      url_ += 'Date=' + encodeURIComponent(date ? '' + date.toJSON() : '') + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'application/json',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetMonthStatus(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetMonthStatus(<any>response_);
            } catch (e) {
              return <Observable<MonthStatusVm>>(<any>_observableThrow(e));
            }
          } else return <Observable<MonthStatusVm>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processGetMonthStatus(response: HttpResponseBase): Observable<MonthStatusVm> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = MonthStatusVm.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status === 422) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result422: any = null;
          let resultData422 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result422 = ValidationProblemDetails.fromJS(resultData422);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result422
          );
        })
      );
    } else {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let resultdefault: any = null;
          let resultDatadefault =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          resultdefault = ProblemDetails.fromJS(resultDatadefault);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            resultdefault
          );
        })
      );
    }
  }

  getProfile(): Observable<ControlsProfileVm> {
    let url_ = this.baseUrl + '/api/Controls/GetProfile';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'application/json',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetProfile(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetProfile(<any>response_);
            } catch (e) {
              return <Observable<ControlsProfileVm>>(<any>_observableThrow(e));
            }
          } else return <Observable<ControlsProfileVm>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processGetProfile(response: HttpResponseBase): Observable<ControlsProfileVm> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = ControlsProfileVm.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let resultdefault: any = null;
          let resultDatadefault =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          resultdefault = ProblemDetails.fromJS(resultDatadefault);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            resultdefault
          );
        })
      );
    }
  }

  updateWorkingDay(query: ControlsUpdateWorkingDayCommand): Observable<FileResponse> {
    let url_ = this.baseUrl + '/api/Controls/UpdateWorkingDay';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(query);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
        Accept: 'application/octet-stream',
      }),
    };

    return this.http
      .request('put', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processUpdateWorkingDay(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processUpdateWorkingDay(<any>response_);
            } catch (e) {
              return <Observable<FileResponse>>(<any>_observableThrow(e));
            }
          } else return <Observable<FileResponse>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processUpdateWorkingDay(
    response: HttpResponseBase
  ): Observable<FileResponse> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200 || status === 206) {
      const contentDisposition = response.headers
        ? response.headers.get('content-disposition')
        : undefined;
      const fileNameMatch = contentDisposition
        ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition)
        : undefined;
      const fileName =
        fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
      return _observableOf({
        fileName: fileName,
        data: <any>responseBlob,
        status: status,
        headers: _headers,
      });
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<FileResponse>(<any>null);
  }

  postComment(query: ControlsPostCommentCommand): Observable<HttpResultOfInteger> {
    let url_ = this.baseUrl + '/api/Controls/PostComment';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(query);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
        Accept: 'application/json',
      }),
    };

    return this.http
      .request('post', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processPostComment(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processPostComment(<any>response_);
            } catch (e) {
              return <Observable<HttpResultOfInteger>>(<any>_observableThrow(e));
            }
          } else
            return <Observable<HttpResultOfInteger>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processPostComment(
    response: HttpResponseBase
  ): Observable<HttpResultOfInteger> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = HttpResultOfInteger.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status === 404) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result404: any = null;
          let resultData404 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result404 = ProblemDetails.fromJS(resultData404);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result404
          );
        })
      );
    } else if (status === 400) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result400: any = null;
          let resultData400 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result400 = ProblemDetails.fromJS(resultData400);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result400
          );
        })
      );
    } else if (status === 422) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result422: any = null;
          let resultData422 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result422 = ValidationProblemDetails.fromJS(resultData422);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result422
          );
        })
      );
    } else {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let resultdefault: any = null;
          let resultDatadefault =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          resultdefault = ProblemDetails.fromJS(resultDatadefault);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            resultdefault
          );
        })
      );
    }
  }

  deleteComment(id: number | undefined): Observable<void> {
    let url_ = this.baseUrl + '/api/Controls/DeleteComment?';
    if (id === null) throw new Error("The parameter 'id' cannot be null.");
    else if (id !== undefined) url_ += 'id=' + encodeURIComponent('' + id) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({}),
    };

    return this.http
      .request('delete', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processDeleteComment(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processDeleteComment(<any>response_);
            } catch (e) {
              return <Observable<void>>(<any>_observableThrow(e));
            }
          } else return <Observable<void>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processDeleteComment(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return _observableOf<void>(<any>null);
        })
      );
    } else if (status === 404) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result404: any = null;
          let resultData404 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result404 = ProblemDetails.fromJS(resultData404);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result404
          );
        })
      );
    } else if (status === 422) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result422: any = null;
          let resultData422 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result422 = ValidationProblemDetails.fromJS(resultData422);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result422
          );
        })
      );
    } else {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let resultdefault: any = null;
          let resultDatadefault =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          resultdefault = ProblemDetails.fromJS(resultDatadefault);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            resultdefault
          );
        })
      );
    }
  }
}

export interface ICountersClient {
  get(serviceId: number | null | undefined): Observable<CounterVm>;
  getCustomersData(serviceId: number | null | undefined): Observable<CustomerVm2[]>;
  getReservationsList(
    serviceId: number | null | undefined
  ): Observable<CounterWorkingDayVm[]>;
  getReservationsByDate(
    serviceId: number | null | undefined,
    date: Date | undefined
  ): Observable<CounterReservationVm[]>;
  issueTicket(command: CountersIssueTicketCommand): Observable<IssueTicketVm>;
  callTicket(command: CountersCallTicketCommand): Observable<CalledTicketDetailsVm>;
  callNext(command: CountersCallTicketCommand): Observable<CalledTicketDetailsVm>;
  reset(command: CountersResetCommand): Observable<void>;
}

@Injectable({
  providedIn: 'root',
})
export class CountersClient implements ICountersClient {
  private http: HttpClient;
  private baseUrl: string;
  protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

  constructor(
    @Inject(HttpClient) http: HttpClient,
    @Optional() @Inject(API_BASE_URL) baseUrl?: string
  ) {
    this.http = http;
    this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : '';
  }

  get(serviceId: number | null | undefined): Observable<CounterVm> {
    let url_ = this.baseUrl + '/api/Counters?';
    if (serviceId !== undefined && serviceId !== null)
      url_ += 'serviceId=' + encodeURIComponent('' + serviceId) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'application/json',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGet(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGet(<any>response_);
            } catch (e) {
              return <Observable<CounterVm>>(<any>_observableThrow(e));
            }
          } else return <Observable<CounterVm>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processGet(response: HttpResponseBase): Observable<CounterVm> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = CounterVm.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status === 422) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result422: any = null;
          let resultData422 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result422 = ValidationProblemDetails.fromJS(resultData422);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result422
          );
        })
      );
    } else {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let resultdefault: any = null;
          let resultDatadefault =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          resultdefault = ProblemDetails.fromJS(resultDatadefault);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            resultdefault
          );
        })
      );
    }
  }

  getCustomersData(serviceId: number | null | undefined): Observable<CustomerVm2[]> {
    let url_ = this.baseUrl + '/api/Counters/GetCustomersData?';
    if (serviceId !== undefined && serviceId !== null)
      url_ += 'serviceId=' + encodeURIComponent('' + serviceId) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'application/json',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetCustomersData(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetCustomersData(<any>response_);
            } catch (e) {
              return <Observable<CustomerVm2[]>>(<any>_observableThrow(e));
            }
          } else return <Observable<CustomerVm2[]>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processGetCustomersData(
    response: HttpResponseBase
  ): Observable<CustomerVm2[]> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          if (Array.isArray(resultData200)) {
            result200 = [] as any;
            for (let item of resultData200) result200!.push(CustomerVm2.fromJS(item));
          } else {
            result200 = <any>null;
          }
          return _observableOf(result200);
        })
      );
    } else if (status === 422) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result422: any = null;
          let resultData422 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result422 = ValidationProblemDetails.fromJS(resultData422);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result422
          );
        })
      );
    } else {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let resultdefault: any = null;
          let resultDatadefault =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          resultdefault = ProblemDetails.fromJS(resultDatadefault);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            resultdefault
          );
        })
      );
    }
  }

  getReservationsList(
    serviceId: number | null | undefined
  ): Observable<CounterWorkingDayVm[]> {
    let url_ = this.baseUrl + '/api/Counters/GetReservationsList?';
    if (serviceId !== undefined && serviceId !== null)
      url_ += 'serviceId=' + encodeURIComponent('' + serviceId) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'application/json',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetReservationsList(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetReservationsList(<any>response_);
            } catch (e) {
              return <Observable<CounterWorkingDayVm[]>>(<any>_observableThrow(e));
            }
          } else
            return <Observable<CounterWorkingDayVm[]>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processGetReservationsList(
    response: HttpResponseBase
  ): Observable<CounterWorkingDayVm[]> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          if (Array.isArray(resultData200)) {
            result200 = [] as any;
            for (let item of resultData200)
              result200!.push(CounterWorkingDayVm.fromJS(item));
          } else {
            result200 = <any>null;
          }
          return _observableOf(result200);
        })
      );
    } else if (status === 422) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result422: any = null;
          let resultData422 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result422 = ValidationProblemDetails.fromJS(resultData422);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result422
          );
        })
      );
    } else {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let resultdefault: any = null;
          let resultDatadefault =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          resultdefault = ProblemDetails.fromJS(resultDatadefault);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            resultdefault
          );
        })
      );
    }
  }

  getReservationsByDate(
    serviceId: number | null | undefined,
    date: Date | undefined
  ): Observable<CounterReservationVm[]> {
    let url_ = this.baseUrl + '/api/Counters/GetReservationsByDate?';
    if (serviceId !== undefined && serviceId !== null)
      url_ += 'serviceId=' + encodeURIComponent('' + serviceId) + '&';
    if (date === null) throw new Error("The parameter 'date' cannot be null.");
    else if (date !== undefined)
      url_ += 'date=' + encodeURIComponent(date ? '' + date.toJSON() : '') + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'application/json',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetReservationsByDate(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetReservationsByDate(<any>response_);
            } catch (e) {
              return <Observable<CounterReservationVm[]>>(<any>_observableThrow(e));
            }
          } else
            return <Observable<CounterReservationVm[]>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processGetReservationsByDate(
    response: HttpResponseBase
  ): Observable<CounterReservationVm[]> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          if (Array.isArray(resultData200)) {
            result200 = [] as any;
            for (let item of resultData200)
              result200!.push(CounterReservationVm.fromJS(item));
          } else {
            result200 = <any>null;
          }
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<CounterReservationVm[]>(<any>null);
  }

  issueTicket(command: CountersIssueTicketCommand): Observable<IssueTicketVm> {
    let url_ = this.baseUrl + '/api/Counters/IssueTicket';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(command);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
        Accept: 'application/json',
      }),
    };

    return this.http
      .request('post', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processIssueTicket(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processIssueTicket(<any>response_);
            } catch (e) {
              return <Observable<IssueTicketVm>>(<any>_observableThrow(e));
            }
          } else return <Observable<IssueTicketVm>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processIssueTicket(response: HttpResponseBase): Observable<IssueTicketVm> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = IssueTicketVm.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status === 404) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result404: any = null;
          let resultData404 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result404 = ProblemDetails.fromJS(resultData404);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result404
          );
        })
      );
    } else if (status === 400) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result400: any = null;
          let resultData400 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result400 = ProblemDetails.fromJS(resultData400);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result400
          );
        })
      );
    } else if (status === 422) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result422: any = null;
          let resultData422 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result422 = ValidationProblemDetails.fromJS(resultData422);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result422
          );
        })
      );
    } else {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let resultdefault: any = null;
          let resultDatadefault =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          resultdefault = ProblemDetails.fromJS(resultDatadefault);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            resultdefault
          );
        })
      );
    }
  }

  callTicket(command: CountersCallTicketCommand): Observable<CalledTicketDetailsVm> {
    let url_ = this.baseUrl + '/api/Counters/CallTicket';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(command);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
        Accept: 'application/json',
      }),
    };

    return this.http
      .request('put', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processCallTicket(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processCallTicket(<any>response_);
            } catch (e) {
              return <Observable<CalledTicketDetailsVm>>(<any>_observableThrow(e));
            }
          } else
            return <Observable<CalledTicketDetailsVm>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processCallTicket(
    response: HttpResponseBase
  ): Observable<CalledTicketDetailsVm> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = CalledTicketDetailsVm.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status === 404) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result404: any = null;
          let resultData404 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result404 = ProblemDetails.fromJS(resultData404);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result404
          );
        })
      );
    } else if (status === 400) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result400: any = null;
          let resultData400 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result400 = ProblemDetails.fromJS(resultData400);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result400
          );
        })
      );
    } else if (status === 422) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result422: any = null;
          let resultData422 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result422 = ValidationProblemDetails.fromJS(resultData422);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result422
          );
        })
      );
    } else {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let resultdefault: any = null;
          let resultDatadefault =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          resultdefault = ProblemDetails.fromJS(resultDatadefault);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            resultdefault
          );
        })
      );
    }
  }

  callNext(command: CountersCallTicketCommand): Observable<CalledTicketDetailsVm> {
    let url_ = this.baseUrl + '/api/Counters/CallNext';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(command);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
        Accept: 'application/json',
      }),
    };

    return this.http
      .request('put', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processCallNext(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processCallNext(<any>response_);
            } catch (e) {
              return <Observable<CalledTicketDetailsVm>>(<any>_observableThrow(e));
            }
          } else
            return <Observable<CalledTicketDetailsVm>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processCallNext(
    response: HttpResponseBase
  ): Observable<CalledTicketDetailsVm> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = CalledTicketDetailsVm.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status === 404) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result404: any = null;
          let resultData404 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result404 = ProblemDetails.fromJS(resultData404);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result404
          );
        })
      );
    } else if (status === 400) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result400: any = null;
          let resultData400 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result400 = ProblemDetails.fromJS(resultData400);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result400
          );
        })
      );
    } else if (status === 422) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result422: any = null;
          let resultData422 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result422 = ValidationProblemDetails.fromJS(resultData422);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result422
          );
        })
      );
    } else {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let resultdefault: any = null;
          let resultDatadefault =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          resultdefault = ProblemDetails.fromJS(resultDatadefault);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            resultdefault
          );
        })
      );
    }
  }

  reset(command: CountersResetCommand): Observable<void> {
    let url_ = this.baseUrl + '/api/Counters/Reset';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(command);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
      }),
    };

    return this.http
      .request('delete', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processReset(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processReset(<any>response_);
            } catch (e) {
              return <Observable<void>>(<any>_observableThrow(e));
            }
          } else return <Observable<void>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processReset(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return _observableOf<void>(<any>null);
        })
      );
    } else if (status === 404) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result404: any = null;
          let resultData404 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result404 = ProblemDetails.fromJS(resultData404);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result404
          );
        })
      );
    } else if (status === 422) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result422: any = null;
          let resultData422 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result422 = ValidationProblemDetails.fromJS(resultData422);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result422
          );
        })
      );
    } else {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let resultdefault: any = null;
          let resultDatadefault =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          resultdefault = ProblemDetails.fromJS(resultDatadefault);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            resultdefault
          );
        })
      );
    }
  }
}

export interface IDistrictsClient {
  getPage(
    offset: number | null | undefined,
    pageIndex: number | null | undefined,
    search: string | null | undefined,
    ascending: boolean | undefined,
    sortBy: string | null | undefined
  ): Observable<PaginatedListOfDistrictDto>;
  post(command: DistrictPostCommand): Observable<HttpResultOfInteger>;
  put(command: DistrictsPutCommand): Observable<void>;
  delete(id: number | undefined): Observable<void>;
}

@Injectable({
  providedIn: 'root',
})
export class DistrictsClient implements IDistrictsClient {
  private http: HttpClient;
  private baseUrl: string;
  protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

  constructor(
    @Inject(HttpClient) http: HttpClient,
    @Optional() @Inject(API_BASE_URL) baseUrl?: string
  ) {
    this.http = http;
    this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : '';
  }

  getPage(
    offset: number | null | undefined,
    pageIndex: number | null | undefined,
    search: string | null | undefined,
    ascending: boolean | undefined,
    sortBy: string | null | undefined
  ): Observable<PaginatedListOfDistrictDto> {
    let url_ = this.baseUrl + '/api/Districts/GetPage?';
    if (offset !== undefined && offset !== null)
      url_ += 'Offset=' + encodeURIComponent('' + offset) + '&';
    if (pageIndex !== undefined && pageIndex !== null)
      url_ += 'PageIndex=' + encodeURIComponent('' + pageIndex) + '&';
    if (search !== undefined && search !== null)
      url_ += 'Search=' + encodeURIComponent('' + search) + '&';
    if (ascending === null) throw new Error("The parameter 'ascending' cannot be null.");
    else if (ascending !== undefined)
      url_ += 'Ascending=' + encodeURIComponent('' + ascending) + '&';
    if (sortBy !== undefined && sortBy !== null)
      url_ += 'SortBy=' + encodeURIComponent('' + sortBy) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'application/json',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetPage(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetPage(<any>response_);
            } catch (e) {
              return <Observable<PaginatedListOfDistrictDto>>(<any>_observableThrow(e));
            }
          } else
            return <Observable<PaginatedListOfDistrictDto>>(
              (<any>_observableThrow(response_))
            );
        })
      );
  }

  protected processGetPage(
    response: HttpResponseBase
  ): Observable<PaginatedListOfDistrictDto> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = PaginatedListOfDistrictDto.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status === 422) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result422: any = null;
          let resultData422 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result422 = ValidationProblemDetails.fromJS(resultData422);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result422
          );
        })
      );
    } else {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let resultdefault: any = null;
          let resultDatadefault =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          resultdefault = ProblemDetails.fromJS(resultDatadefault);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            resultdefault
          );
        })
      );
    }
  }

  post(command: DistrictPostCommand): Observable<HttpResultOfInteger> {
    let url_ = this.baseUrl + '/api/Districts';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(command);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
        Accept: 'application/json',
      }),
    };

    return this.http
      .request('post', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processPost(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processPost(<any>response_);
            } catch (e) {
              return <Observable<HttpResultOfInteger>>(<any>_observableThrow(e));
            }
          } else
            return <Observable<HttpResultOfInteger>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processPost(response: HttpResponseBase): Observable<HttpResultOfInteger> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = HttpResultOfInteger.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status === 404) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result404: any = null;
          let resultData404 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result404 = ProblemDetails.fromJS(resultData404);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result404
          );
        })
      );
    } else if (status === 400) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result400: any = null;
          let resultData400 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result400 = ProblemDetails.fromJS(resultData400);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result400
          );
        })
      );
    } else if (status === 422) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result422: any = null;
          let resultData422 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result422 = ValidationProblemDetails.fromJS(resultData422);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result422
          );
        })
      );
    } else {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let resultdefault: any = null;
          let resultDatadefault =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          resultdefault = ProblemDetails.fromJS(resultDatadefault);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            resultdefault
          );
        })
      );
    }
  }

  put(command: DistrictsPutCommand): Observable<void> {
    let url_ = this.baseUrl + '/api/Districts';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(command);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
      }),
    };

    return this.http
      .request('put', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processPut(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processPut(<any>response_);
            } catch (e) {
              return <Observable<void>>(<any>_observableThrow(e));
            }
          } else return <Observable<void>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processPut(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return _observableOf<void>(<any>null);
        })
      );
    } else if (status === 404) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result404: any = null;
          let resultData404 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result404 = ProblemDetails.fromJS(resultData404);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result404
          );
        })
      );
    } else if (status === 400) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result400: any = null;
          let resultData400 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result400 = ProblemDetails.fromJS(resultData400);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result400
          );
        })
      );
    } else if (status === 422) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result422: any = null;
          let resultData422 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result422 = ValidationProblemDetails.fromJS(resultData422);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result422
          );
        })
      );
    } else {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let resultdefault: any = null;
          let resultDatadefault =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          resultdefault = ProblemDetails.fromJS(resultDatadefault);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            resultdefault
          );
        })
      );
    }
  }

  delete(id: number | undefined): Observable<void> {
    let url_ = this.baseUrl + '/api/Districts?';
    if (id === null) throw new Error("The parameter 'id' cannot be null.");
    else if (id !== undefined) url_ += 'id=' + encodeURIComponent('' + id) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({}),
    };

    return this.http
      .request('delete', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processDelete(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processDelete(<any>response_);
            } catch (e) {
              return <Observable<void>>(<any>_observableThrow(e));
            }
          } else return <Observable<void>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processDelete(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return _observableOf<void>(<any>null);
        })
      );
    } else if (status === 404) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result404: any = null;
          let resultData404 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result404 = ProblemDetails.fromJS(resultData404);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result404
          );
        })
      );
    } else if (status === 422) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result422: any = null;
          let resultData422 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result422 = ValidationProblemDetails.fromJS(resultData422);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result422
          );
        })
      );
    } else {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let resultdefault: any = null;
          let resultDatadefault =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          resultdefault = ProblemDetails.fromJS(resultDatadefault);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            resultdefault
          );
        })
      );
    }
  }
}

export interface IGovernoratesClient {
  getPage(
    offset: number | null | undefined,
    pageIndex: number | null | undefined,
    search: string | null | undefined,
    ascending: boolean | undefined,
    sortBy: string | null | undefined
  ): Observable<PaginatedListOfGovernorateDto>;
  getFullList(): Observable<GovernorateDashboardVm[]>;
  getList(): Observable<GovernorateShortVm[]>;
  post(command: GovernoratesPostCommand): Observable<HttpResultOfInteger>;
  put(command: GovernoratesPutCommand): Observable<void>;
  delete(id: number | undefined): Observable<void>;
}

@Injectable({
  providedIn: 'root',
})
export class GovernoratesClient implements IGovernoratesClient {
  private http: HttpClient;
  private baseUrl: string;
  protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

  constructor(
    @Inject(HttpClient) http: HttpClient,
    @Optional() @Inject(API_BASE_URL) baseUrl?: string
  ) {
    this.http = http;
    this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : '';
  }

  getPage(
    offset: number | null | undefined,
    pageIndex: number | null | undefined,
    search: string | null | undefined,
    ascending: boolean | undefined,
    sortBy: string | null | undefined
  ): Observable<PaginatedListOfGovernorateDto> {
    let url_ = this.baseUrl + '/api/Governorates/GetPage?';
    if (offset !== undefined && offset !== null)
      url_ += 'Offset=' + encodeURIComponent('' + offset) + '&';
    if (pageIndex !== undefined && pageIndex !== null)
      url_ += 'PageIndex=' + encodeURIComponent('' + pageIndex) + '&';
    if (search !== undefined && search !== null)
      url_ += 'Search=' + encodeURIComponent('' + search) + '&';
    if (ascending === null) throw new Error("The parameter 'ascending' cannot be null.");
    else if (ascending !== undefined)
      url_ += 'Ascending=' + encodeURIComponent('' + ascending) + '&';
    if (sortBy !== undefined && sortBy !== null)
      url_ += 'SortBy=' + encodeURIComponent('' + sortBy) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'application/json',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetPage(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetPage(<any>response_);
            } catch (e) {
              return <Observable<PaginatedListOfGovernorateDto>>(
                (<any>_observableThrow(e))
              );
            }
          } else
            return <Observable<PaginatedListOfGovernorateDto>>(
              (<any>_observableThrow(response_))
            );
        })
      );
  }

  protected processGetPage(
    response: HttpResponseBase
  ): Observable<PaginatedListOfGovernorateDto> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = PaginatedListOfGovernorateDto.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status === 422) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result422: any = null;
          let resultData422 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result422 = ValidationProblemDetails.fromJS(resultData422);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result422
          );
        })
      );
    } else {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let resultdefault: any = null;
          let resultDatadefault =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          resultdefault = ProblemDetails.fromJS(resultDatadefault);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            resultdefault
          );
        })
      );
    }
  }

  getFullList(): Observable<GovernorateDashboardVm[]> {
    let url_ = this.baseUrl + '/api/Governorates/GetFullList';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'application/json',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetFullList(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetFullList(<any>response_);
            } catch (e) {
              return <Observable<GovernorateDashboardVm[]>>(<any>_observableThrow(e));
            }
          } else
            return <Observable<GovernorateDashboardVm[]>>(
              (<any>_observableThrow(response_))
            );
        })
      );
  }

  protected processGetFullList(
    response: HttpResponseBase
  ): Observable<GovernorateDashboardVm[]> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          if (Array.isArray(resultData200)) {
            result200 = [] as any;
            for (let item of resultData200)
              result200!.push(GovernorateDashboardVm.fromJS(item));
          } else {
            result200 = <any>null;
          }
          return _observableOf(result200);
        })
      );
    } else {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let resultdefault: any = null;
          let resultDatadefault =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          resultdefault = ProblemDetails.fromJS(resultDatadefault);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            resultdefault
          );
        })
      );
    }
  }

  getList(): Observable<GovernorateShortVm[]> {
    let url_ = this.baseUrl + '/api/Governorates/GetList';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'application/json',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetList(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetList(<any>response_);
            } catch (e) {
              return <Observable<GovernorateShortVm[]>>(<any>_observableThrow(e));
            }
          } else
            return <Observable<GovernorateShortVm[]>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processGetList(response: HttpResponseBase): Observable<GovernorateShortVm[]> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          if (Array.isArray(resultData200)) {
            result200 = [] as any;
            for (let item of resultData200)
              result200!.push(GovernorateShortVm.fromJS(item));
          } else {
            result200 = <any>null;
          }
          return _observableOf(result200);
        })
      );
    } else {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let resultdefault: any = null;
          let resultDatadefault =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          resultdefault = ProblemDetails.fromJS(resultDatadefault);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            resultdefault
          );
        })
      );
    }
  }

  post(command: GovernoratesPostCommand): Observable<HttpResultOfInteger> {
    let url_ = this.baseUrl + '/api/Governorates';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(command);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
        Accept: 'application/json',
      }),
    };

    return this.http
      .request('post', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processPost(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processPost(<any>response_);
            } catch (e) {
              return <Observable<HttpResultOfInteger>>(<any>_observableThrow(e));
            }
          } else
            return <Observable<HttpResultOfInteger>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processPost(response: HttpResponseBase): Observable<HttpResultOfInteger> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = HttpResultOfInteger.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status === 404) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result404: any = null;
          let resultData404 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result404 = ProblemDetails.fromJS(resultData404);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result404
          );
        })
      );
    } else if (status === 400) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result400: any = null;
          let resultData400 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result400 = ProblemDetails.fromJS(resultData400);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result400
          );
        })
      );
    } else if (status === 422) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result422: any = null;
          let resultData422 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result422 = ValidationProblemDetails.fromJS(resultData422);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result422
          );
        })
      );
    } else {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let resultdefault: any = null;
          let resultDatadefault =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          resultdefault = ProblemDetails.fromJS(resultDatadefault);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            resultdefault
          );
        })
      );
    }
  }

  put(command: GovernoratesPutCommand): Observable<void> {
    let url_ = this.baseUrl + '/api/Governorates';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(command);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
      }),
    };

    return this.http
      .request('put', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processPut(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processPut(<any>response_);
            } catch (e) {
              return <Observable<void>>(<any>_observableThrow(e));
            }
          } else return <Observable<void>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processPut(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return _observableOf<void>(<any>null);
        })
      );
    } else if (status === 404) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result404: any = null;
          let resultData404 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result404 = ProblemDetails.fromJS(resultData404);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result404
          );
        })
      );
    } else if (status === 400) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result400: any = null;
          let resultData400 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result400 = ProblemDetails.fromJS(resultData400);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result400
          );
        })
      );
    } else if (status === 422) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result422: any = null;
          let resultData422 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result422 = ValidationProblemDetails.fromJS(resultData422);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result422
          );
        })
      );
    } else {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let resultdefault: any = null;
          let resultDatadefault =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          resultdefault = ProblemDetails.fromJS(resultDatadefault);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            resultdefault
          );
        })
      );
    }
  }

  delete(id: number | undefined): Observable<void> {
    let url_ = this.baseUrl + '/api/Governorates?';
    if (id === null) throw new Error("The parameter 'id' cannot be null.");
    else if (id !== undefined) url_ += 'id=' + encodeURIComponent('' + id) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({}),
    };

    return this.http
      .request('delete', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processDelete(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processDelete(<any>response_);
            } catch (e) {
              return <Observable<void>>(<any>_observableThrow(e));
            }
          } else return <Observable<void>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processDelete(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return _observableOf<void>(<any>null);
        })
      );
    } else if (status === 404) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result404: any = null;
          let resultData404 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result404 = ProblemDetails.fromJS(resultData404);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result404
          );
        })
      );
    } else if (status === 422) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result422: any = null;
          let resultData422 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result422 = ValidationProblemDetails.fromJS(resultData422);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result422
          );
        })
      );
    } else {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let resultdefault: any = null;
          let resultDatadefault =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          resultdefault = ProblemDetails.fromJS(resultDatadefault);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            resultdefault
          );
        })
      );
    }
  }
}

export interface IOffDaysClient {
  getList(queueId: number | undefined): Observable<OffDayDto[]>;
  put(command: OffDaysPutCommand): Observable<void>;
}

@Injectable({
  providedIn: 'root',
})
export class OffDaysClient implements IOffDaysClient {
  private http: HttpClient;
  private baseUrl: string;
  protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

  constructor(
    @Inject(HttpClient) http: HttpClient,
    @Optional() @Inject(API_BASE_URL) baseUrl?: string
  ) {
    this.http = http;
    this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : '';
  }

  getList(queueId: number | undefined): Observable<OffDayDto[]> {
    let url_ = this.baseUrl + '/api/OffDays?';
    if (queueId === null) throw new Error("The parameter 'queueId' cannot be null.");
    else if (queueId !== undefined)
      url_ += 'QueueId=' + encodeURIComponent('' + queueId) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'application/json',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetList(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetList(<any>response_);
            } catch (e) {
              return <Observable<OffDayDto[]>>(<any>_observableThrow(e));
            }
          } else return <Observable<OffDayDto[]>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processGetList(response: HttpResponseBase): Observable<OffDayDto[]> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          if (Array.isArray(resultData200)) {
            result200 = [] as any;
            for (let item of resultData200) result200!.push(OffDayDto.fromJS(item));
          } else {
            result200 = <any>null;
          }
          return _observableOf(result200);
        })
      );
    } else if (status === 422) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result422: any = null;
          let resultData422 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result422 = ValidationProblemDetails.fromJS(resultData422);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result422
          );
        })
      );
    } else {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let resultdefault: any = null;
          let resultDatadefault =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          resultdefault = ProblemDetails.fromJS(resultDatadefault);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            resultdefault
          );
        })
      );
    }
  }

  put(command: OffDaysPutCommand): Observable<void> {
    let url_ = this.baseUrl + '/api/OffDays';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(command);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
      }),
    };

    return this.http
      .request('put', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processPut(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processPut(<any>response_);
            } catch (e) {
              return <Observable<void>>(<any>_observableThrow(e));
            }
          } else return <Observable<void>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processPut(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return _observableOf<void>(<any>null);
        })
      );
    } else if (status === 404) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result404: any = null;
          let resultData404 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result404 = ProblemDetails.fromJS(resultData404);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result404
          );
        })
      );
    } else if (status === 400) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result400: any = null;
          let resultData400 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result400 = ProblemDetails.fromJS(resultData400);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result400
          );
        })
      );
    } else if (status === 422) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result422: any = null;
          let resultData422 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result422 = ValidationProblemDetails.fromJS(resultData422);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result422
          );
        })
      );
    } else {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let resultdefault: any = null;
          let resultDatadefault =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          resultdefault = ProblemDetails.fromJS(resultDatadefault);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            resultdefault
          );
        })
      );
    }
  }
}

export interface IQueuesClient {
  getPage(
    serviceId: number | undefined,
    branchId: number | undefined,
    offset: number | null | undefined,
    pageIndex: number | null | undefined,
    search: string | null | undefined,
    ascending: boolean | undefined,
    sortBy: string | null | undefined
  ): Observable<QueueVm>;
  getCounterData(id: number | undefined): Observable<CounterDataDto>;
  get(id: number | undefined): Observable<QueueDto>;
  put(command: QueuesPutCommand): Observable<void>;
  putCounterData(command: QueuesPutCounterDataCommand): Observable<void>;
  issueTicket(command: QueuesIssueTicketCommand): Observable<void>;
  callTicket(command: QueuesCallTicketCommand): Observable<void>;
  reset(id: number | undefined): Observable<void>;
}

@Injectable({
  providedIn: 'root',
})
export class QueuesClient implements IQueuesClient {
  private http: HttpClient;
  private baseUrl: string;
  protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

  constructor(
    @Inject(HttpClient) http: HttpClient,
    @Optional() @Inject(API_BASE_URL) baseUrl?: string
  ) {
    this.http = http;
    this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : '';
  }

  getPage(
    serviceId: number | undefined,
    branchId: number | undefined,
    offset: number | null | undefined,
    pageIndex: number | null | undefined,
    search: string | null | undefined,
    ascending: boolean | undefined,
    sortBy: string | null | undefined
  ): Observable<QueueVm> {
    let url_ = this.baseUrl + '/api/Queues/GetPage?';
    if (serviceId === null) throw new Error("The parameter 'serviceId' cannot be null.");
    else if (serviceId !== undefined)
      url_ += 'ServiceId=' + encodeURIComponent('' + serviceId) + '&';
    if (branchId === null) throw new Error("The parameter 'branchId' cannot be null.");
    else if (branchId !== undefined)
      url_ += 'BranchId=' + encodeURIComponent('' + branchId) + '&';
    if (offset !== undefined && offset !== null)
      url_ += 'Offset=' + encodeURIComponent('' + offset) + '&';
    if (pageIndex !== undefined && pageIndex !== null)
      url_ += 'PageIndex=' + encodeURIComponent('' + pageIndex) + '&';
    if (search !== undefined && search !== null)
      url_ += 'Search=' + encodeURIComponent('' + search) + '&';
    if (ascending === null) throw new Error("The parameter 'ascending' cannot be null.");
    else if (ascending !== undefined)
      url_ += 'Ascending=' + encodeURIComponent('' + ascending) + '&';
    if (sortBy !== undefined && sortBy !== null)
      url_ += 'SortBy=' + encodeURIComponent('' + sortBy) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'application/json',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetPage(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetPage(<any>response_);
            } catch (e) {
              return <Observable<QueueVm>>(<any>_observableThrow(e));
            }
          } else return <Observable<QueueVm>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processGetPage(response: HttpResponseBase): Observable<QueueVm> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = QueueVm.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status === 422) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result422: any = null;
          let resultData422 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result422 = ValidationProblemDetails.fromJS(resultData422);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result422
          );
        })
      );
    } else {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let resultdefault: any = null;
          let resultDatadefault =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          resultdefault = ProblemDetails.fromJS(resultDatadefault);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            resultdefault
          );
        })
      );
    }
  }

  getCounterData(id: number | undefined): Observable<CounterDataDto> {
    let url_ = this.baseUrl + '/api/Queues/GetCounterData?';
    if (id === null) throw new Error("The parameter 'id' cannot be null.");
    else if (id !== undefined) url_ += 'id=' + encodeURIComponent('' + id) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'application/json',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetCounterData(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetCounterData(<any>response_);
            } catch (e) {
              return <Observable<CounterDataDto>>(<any>_observableThrow(e));
            }
          } else return <Observable<CounterDataDto>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processGetCounterData(
    response: HttpResponseBase
  ): Observable<CounterDataDto> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = CounterDataDto.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status === 422) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result422: any = null;
          let resultData422 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result422 = ValidationProblemDetails.fromJS(resultData422);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result422
          );
        })
      );
    } else {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let resultdefault: any = null;
          let resultDatadefault =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          resultdefault = ProblemDetails.fromJS(resultDatadefault);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            resultdefault
          );
        })
      );
    }
  }

  get(id: number | undefined): Observable<QueueDto> {
    let url_ = this.baseUrl + '/api/Queues?';
    if (id === null) throw new Error("The parameter 'id' cannot be null.");
    else if (id !== undefined) url_ += 'id=' + encodeURIComponent('' + id) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'application/json',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGet(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGet(<any>response_);
            } catch (e) {
              return <Observable<QueueDto>>(<any>_observableThrow(e));
            }
          } else return <Observable<QueueDto>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processGet(response: HttpResponseBase): Observable<QueueDto> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = QueueDto.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status === 422) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result422: any = null;
          let resultData422 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result422 = ValidationProblemDetails.fromJS(resultData422);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result422
          );
        })
      );
    } else {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let resultdefault: any = null;
          let resultDatadefault =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          resultdefault = ProblemDetails.fromJS(resultDatadefault);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            resultdefault
          );
        })
      );
    }
  }

  put(command: QueuesPutCommand): Observable<void> {
    let url_ = this.baseUrl + '/api/Queues';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(command);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
      }),
    };

    return this.http
      .request('put', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processPut(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processPut(<any>response_);
            } catch (e) {
              return <Observable<void>>(<any>_observableThrow(e));
            }
          } else return <Observable<void>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processPut(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return _observableOf<void>(<any>null);
        })
      );
    } else if (status === 404) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result404: any = null;
          let resultData404 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result404 = ProblemDetails.fromJS(resultData404);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result404
          );
        })
      );
    } else if (status === 400) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result400: any = null;
          let resultData400 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result400 = ProblemDetails.fromJS(resultData400);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result400
          );
        })
      );
    } else if (status === 422) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result422: any = null;
          let resultData422 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result422 = ValidationProblemDetails.fromJS(resultData422);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result422
          );
        })
      );
    } else {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let resultdefault: any = null;
          let resultDatadefault =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          resultdefault = ProblemDetails.fromJS(resultDatadefault);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            resultdefault
          );
        })
      );
    }
  }

  putCounterData(command: QueuesPutCounterDataCommand): Observable<void> {
    let url_ = this.baseUrl + '/api/Queues/PutCounterData';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(command);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
      }),
    };

    return this.http
      .request('put', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processPutCounterData(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processPutCounterData(<any>response_);
            } catch (e) {
              return <Observable<void>>(<any>_observableThrow(e));
            }
          } else return <Observable<void>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processPutCounterData(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return _observableOf<void>(<any>null);
        })
      );
    } else if (status === 404) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result404: any = null;
          let resultData404 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result404 = ProblemDetails.fromJS(resultData404);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result404
          );
        })
      );
    } else if (status === 400) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result400: any = null;
          let resultData400 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result400 = ProblemDetails.fromJS(resultData400);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result400
          );
        })
      );
    } else if (status === 422) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result422: any = null;
          let resultData422 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result422 = ValidationProblemDetails.fromJS(resultData422);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result422
          );
        })
      );
    } else {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let resultdefault: any = null;
          let resultDatadefault =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          resultdefault = ProblemDetails.fromJS(resultDatadefault);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            resultdefault
          );
        })
      );
    }
  }

  issueTicket(command: QueuesIssueTicketCommand): Observable<void> {
    let url_ = this.baseUrl + '/api/Queues/IssueTicket';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(command);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
      }),
    };

    return this.http
      .request('post', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processIssueTicket(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processIssueTicket(<any>response_);
            } catch (e) {
              return <Observable<void>>(<any>_observableThrow(e));
            }
          } else return <Observable<void>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processIssueTicket(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return _observableOf<void>(<any>null);
        })
      );
    } else if (status === 404) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result404: any = null;
          let resultData404 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result404 = ProblemDetails.fromJS(resultData404);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result404
          );
        })
      );
    } else if (status === 400) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result400: any = null;
          let resultData400 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result400 = ProblemDetails.fromJS(resultData400);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result400
          );
        })
      );
    } else if (status === 422) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result422: any = null;
          let resultData422 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result422 = ValidationProblemDetails.fromJS(resultData422);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result422
          );
        })
      );
    } else {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let resultdefault: any = null;
          let resultDatadefault =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          resultdefault = ProblemDetails.fromJS(resultDatadefault);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            resultdefault
          );
        })
      );
    }
  }

  callTicket(command: QueuesCallTicketCommand): Observable<void> {
    let url_ = this.baseUrl + '/api/Queues/CallTicket';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(command);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
      }),
    };

    return this.http
      .request('put', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processCallTicket(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processCallTicket(<any>response_);
            } catch (e) {
              return <Observable<void>>(<any>_observableThrow(e));
            }
          } else return <Observable<void>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processCallTicket(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return _observableOf<void>(<any>null);
        })
      );
    } else if (status === 404) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result404: any = null;
          let resultData404 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result404 = ProblemDetails.fromJS(resultData404);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result404
          );
        })
      );
    } else if (status === 400) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result400: any = null;
          let resultData400 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result400 = ProblemDetails.fromJS(resultData400);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result400
          );
        })
      );
    } else if (status === 422) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result422: any = null;
          let resultData422 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result422 = ValidationProblemDetails.fromJS(resultData422);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result422
          );
        })
      );
    } else {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let resultdefault: any = null;
          let resultDatadefault =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          resultdefault = ProblemDetails.fromJS(resultDatadefault);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            resultdefault
          );
        })
      );
    }
  }

  reset(id: number | undefined): Observable<void> {
    let url_ = this.baseUrl + '/api/Queues/Reset?';
    if (id === null) throw new Error("The parameter 'id' cannot be null.");
    else if (id !== undefined) url_ += 'id=' + encodeURIComponent('' + id) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({}),
    };

    return this.http
      .request('delete', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processReset(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processReset(<any>response_);
            } catch (e) {
              return <Observable<void>>(<any>_observableThrow(e));
            }
          } else return <Observable<void>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processReset(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return _observableOf<void>(<any>null);
        })
      );
    } else if (status === 404) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result404: any = null;
          let resultData404 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result404 = ProblemDetails.fromJS(resultData404);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result404
          );
        })
      );
    } else if (status === 422) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result422: any = null;
          let resultData422 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result422 = ValidationProblemDetails.fromJS(resultData422);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result422
          );
        })
      );
    } else {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let resultdefault: any = null;
          let resultDatadefault =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          resultdefault = ProblemDetails.fromJS(resultDatadefault);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            resultdefault
          );
        })
      );
    }
  }
}

export interface IReservationsClient {
  getPage(
    serviceId: number | null | undefined,
    branchId: number | null | undefined,
    offset: number | null | undefined,
    pageIndex: number | null | undefined,
    search: string | null | undefined,
    ascending: boolean | undefined,
    sortBy: string | null | undefined
  ): Observable<PaginatedListOfReservationDashboardVm>;
  delete(id: number | undefined): Observable<void>;
}

@Injectable({
  providedIn: 'root',
})
export class ReservationsClient implements IReservationsClient {
  private http: HttpClient;
  private baseUrl: string;
  protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

  constructor(
    @Inject(HttpClient) http: HttpClient,
    @Optional() @Inject(API_BASE_URL) baseUrl?: string
  ) {
    this.http = http;
    this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : '';
  }

  getPage(
    serviceId: number | null | undefined,
    branchId: number | null | undefined,
    offset: number | null | undefined,
    pageIndex: number | null | undefined,
    search: string | null | undefined,
    ascending: boolean | undefined,
    sortBy: string | null | undefined
  ): Observable<PaginatedListOfReservationDashboardVm> {
    let url_ = this.baseUrl + '/api/Reservations/GetPage?';
    if (serviceId !== undefined && serviceId !== null)
      url_ += 'ServiceId=' + encodeURIComponent('' + serviceId) + '&';
    if (branchId !== undefined && branchId !== null)
      url_ += 'BranchId=' + encodeURIComponent('' + branchId) + '&';
    if (offset !== undefined && offset !== null)
      url_ += 'Offset=' + encodeURIComponent('' + offset) + '&';
    if (pageIndex !== undefined && pageIndex !== null)
      url_ += 'PageIndex=' + encodeURIComponent('' + pageIndex) + '&';
    if (search !== undefined && search !== null)
      url_ += 'Search=' + encodeURIComponent('' + search) + '&';
    if (ascending === null) throw new Error("The parameter 'ascending' cannot be null.");
    else if (ascending !== undefined)
      url_ += 'Ascending=' + encodeURIComponent('' + ascending) + '&';
    if (sortBy !== undefined && sortBy !== null)
      url_ += 'SortBy=' + encodeURIComponent('' + sortBy) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'application/json',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetPage(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetPage(<any>response_);
            } catch (e) {
              return <Observable<PaginatedListOfReservationDashboardVm>>(
                (<any>_observableThrow(e))
              );
            }
          } else
            return <Observable<PaginatedListOfReservationDashboardVm>>(
              (<any>_observableThrow(response_))
            );
        })
      );
  }

  protected processGetPage(
    response: HttpResponseBase
  ): Observable<PaginatedListOfReservationDashboardVm> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = PaginatedListOfReservationDashboardVm.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status === 422) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result422: any = null;
          let resultData422 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result422 = ValidationProblemDetails.fromJS(resultData422);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result422
          );
        })
      );
    } else {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let resultdefault: any = null;
          let resultDatadefault =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          resultdefault = ProblemDetails.fromJS(resultDatadefault);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            resultdefault
          );
        })
      );
    }
  }

  delete(id: number | undefined): Observable<void> {
    let url_ = this.baseUrl + '/api/Reservations?';
    if (id === null) throw new Error("The parameter 'id' cannot be null.");
    else if (id !== undefined) url_ += 'id=' + encodeURIComponent('' + id) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({}),
    };

    return this.http
      .request('delete', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processDelete(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processDelete(<any>response_);
            } catch (e) {
              return <Observable<void>>(<any>_observableThrow(e));
            }
          } else return <Observable<void>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processDelete(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return _observableOf<void>(<any>null);
        })
      );
    } else if (status === 404) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result404: any = null;
          let resultData404 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result404 = ProblemDetails.fromJS(resultData404);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result404
          );
        })
      );
    } else if (status === 422) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result422: any = null;
          let resultData422 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result422 = ValidationProblemDetails.fromJS(resultData422);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result422
          );
        })
      );
    } else {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let resultdefault: any = null;
          let resultDatadefault =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          resultdefault = ProblemDetails.fromJS(resultDatadefault);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            resultdefault
          );
        })
      );
    }
  }
}

export interface IServiceProvidersClient {
  getPage(
    offset: number | null | undefined,
    pageIndex: number | null | undefined,
    search: string | null | undefined,
    ascending: boolean | undefined,
    sortBy: string | null | undefined
  ): Observable<PaginatedListOfServiceProviderPageVm>;
  getFullList(): Observable<ServiceProviderFullVm[]>;
  getList(): Observable<ServiceProviderDashboardVm[]>;
  get(id: number | undefined): Observable<ServiceProviderDto>;
  post(
    name_Ar: string | null | undefined,
    name_En: string | null | undefined,
    contactInfo_Name: string | null | undefined,
    contactInfo_Email: string | null | undefined,
    contactInfo_PhoneNumber: string | null | undefined,
    logo: FileParameter | null | undefined,
    isActive: boolean | undefined,
    categoryId: number | undefined,
    accountManagerId: number | null | undefined
  ): Observable<HttpResultOfInteger>;
  put(
    id: number | undefined,
    name_Ar: string | null | undefined,
    name_En: string | null | undefined,
    contactInfo_Name: string | null | undefined,
    contactInfo_Email: string | null | undefined,
    contactInfo_PhoneNumber: string | null | undefined,
    logo: FileParameter | null | undefined,
    isActive: boolean | undefined,
    categoryId: number | undefined,
    accountManagerId: number | null | undefined
  ): Observable<void>;
  delete(id: number | undefined): Observable<void>;
}

@Injectable({
  providedIn: 'root',
})
export class ServiceProvidersClient implements IServiceProvidersClient {
  private http: HttpClient;
  private baseUrl: string;
  protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

  constructor(
    @Inject(HttpClient) http: HttpClient,
    @Optional() @Inject(API_BASE_URL) baseUrl?: string
  ) {
    this.http = http;
    this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : '';
  }

  getPage(
    offset: number | null | undefined,
    pageIndex: number | null | undefined,
    search: string | null | undefined,
    ascending: boolean | undefined,
    sortBy: string | null | undefined
  ): Observable<PaginatedListOfServiceProviderPageVm> {
    let url_ = this.baseUrl + '/api/ServiceProviders/GetPage?';
    if (offset !== undefined && offset !== null)
      url_ += 'Offset=' + encodeURIComponent('' + offset) + '&';
    if (pageIndex !== undefined && pageIndex !== null)
      url_ += 'PageIndex=' + encodeURIComponent('' + pageIndex) + '&';
    if (search !== undefined && search !== null)
      url_ += 'Search=' + encodeURIComponent('' + search) + '&';
    if (ascending === null) throw new Error("The parameter 'ascending' cannot be null.");
    else if (ascending !== undefined)
      url_ += 'Ascending=' + encodeURIComponent('' + ascending) + '&';
    if (sortBy !== undefined && sortBy !== null)
      url_ += 'SortBy=' + encodeURIComponent('' + sortBy) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'application/json',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetPage(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetPage(<any>response_);
            } catch (e) {
              return <Observable<PaginatedListOfServiceProviderPageVm>>(
                (<any>_observableThrow(e))
              );
            }
          } else
            return <Observable<PaginatedListOfServiceProviderPageVm>>(
              (<any>_observableThrow(response_))
            );
        })
      );
  }

  protected processGetPage(
    response: HttpResponseBase
  ): Observable<PaginatedListOfServiceProviderPageVm> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = PaginatedListOfServiceProviderPageVm.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status === 422) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result422: any = null;
          let resultData422 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result422 = ValidationProblemDetails.fromJS(resultData422);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result422
          );
        })
      );
    } else {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let resultdefault: any = null;
          let resultDatadefault =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          resultdefault = ProblemDetails.fromJS(resultDatadefault);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            resultdefault
          );
        })
      );
    }
  }

  getFullList(): Observable<ServiceProviderFullVm[]> {
    let url_ = this.baseUrl + '/api/ServiceProviders/GetFullList';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'application/json',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetFullList(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetFullList(<any>response_);
            } catch (e) {
              return <Observable<ServiceProviderFullVm[]>>(<any>_observableThrow(e));
            }
          } else
            return <Observable<ServiceProviderFullVm[]>>(
              (<any>_observableThrow(response_))
            );
        })
      );
  }

  protected processGetFullList(
    response: HttpResponseBase
  ): Observable<ServiceProviderFullVm[]> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          if (Array.isArray(resultData200)) {
            result200 = [] as any;
            for (let item of resultData200)
              result200!.push(ServiceProviderFullVm.fromJS(item));
          } else {
            result200 = <any>null;
          }
          return _observableOf(result200);
        })
      );
    } else {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let resultdefault: any = null;
          let resultDatadefault =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          resultdefault = ProblemDetails.fromJS(resultDatadefault);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            resultdefault
          );
        })
      );
    }
  }

  getList(): Observable<ServiceProviderDashboardVm[]> {
    let url_ = this.baseUrl + '/api/ServiceProviders/GetList';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'application/json',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetList(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetList(<any>response_);
            } catch (e) {
              return <Observable<ServiceProviderDashboardVm[]>>(<any>_observableThrow(e));
            }
          } else
            return <Observable<ServiceProviderDashboardVm[]>>(
              (<any>_observableThrow(response_))
            );
        })
      );
  }

  protected processGetList(
    response: HttpResponseBase
  ): Observable<ServiceProviderDashboardVm[]> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          if (Array.isArray(resultData200)) {
            result200 = [] as any;
            for (let item of resultData200)
              result200!.push(ServiceProviderDashboardVm.fromJS(item));
          } else {
            result200 = <any>null;
          }
          return _observableOf(result200);
        })
      );
    } else {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let resultdefault: any = null;
          let resultDatadefault =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          resultdefault = ProblemDetails.fromJS(resultDatadefault);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            resultdefault
          );
        })
      );
    }
  }

  get(id: number | undefined): Observable<ServiceProviderDto> {
    let url_ = this.baseUrl + '/api/ServiceProviders?';
    if (id === null) throw new Error("The parameter 'id' cannot be null.");
    else if (id !== undefined) url_ += 'id=' + encodeURIComponent('' + id) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'application/json',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGet(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGet(<any>response_);
            } catch (e) {
              return <Observable<ServiceProviderDto>>(<any>_observableThrow(e));
            }
          } else
            return <Observable<ServiceProviderDto>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processGet(response: HttpResponseBase): Observable<ServiceProviderDto> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = ServiceProviderDto.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status === 422) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result422: any = null;
          let resultData422 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result422 = ValidationProblemDetails.fromJS(resultData422);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result422
          );
        })
      );
    } else {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let resultdefault: any = null;
          let resultDatadefault =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          resultdefault = ProblemDetails.fromJS(resultDatadefault);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            resultdefault
          );
        })
      );
    }
  }

  post(
    name_Ar: string | null | undefined,
    name_En: string | null | undefined,
    contactInfo_Name: string | null | undefined,
    contactInfo_Email: string | null | undefined,
    contactInfo_PhoneNumber: string | null | undefined,
    logo: FileParameter | null | undefined,
    isActive: boolean | undefined,
    categoryId: number | undefined,
    accountManagerId: number | null | undefined
  ): Observable<HttpResultOfInteger> {
    let url_ = this.baseUrl + '/api/ServiceProviders';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = new FormData();
    if (name_Ar !== null && name_Ar !== undefined)
      content_.append('Name.Ar', name_Ar.toString());
    if (name_En !== null && name_En !== undefined)
      content_.append('Name.En', name_En.toString());
    if (contactInfo_Name !== null && contactInfo_Name !== undefined)
      content_.append('ContactInfo.Name', contactInfo_Name.toString());
    if (contactInfo_Email !== null && contactInfo_Email !== undefined)
      content_.append('ContactInfo.Email', contactInfo_Email.toString());
    if (contactInfo_PhoneNumber !== null && contactInfo_PhoneNumber !== undefined)
      content_.append('ContactInfo.PhoneNumber', contactInfo_PhoneNumber.toString());
    if (logo !== null && logo !== undefined)
      content_.append('Logo', logo.data, logo.fileName ? logo.fileName : 'Logo');
    if (isActive === null || isActive === undefined)
      throw new Error("The parameter 'isActive' cannot be null.");
    else content_.append('IsActive', isActive.toString());
    if (categoryId === null || categoryId === undefined)
      throw new Error("The parameter 'categoryId' cannot be null.");
    else content_.append('CategoryId', categoryId.toString());
    if (accountManagerId !== null && accountManagerId !== undefined)
      content_.append('AccountManagerId', accountManagerId.toString());

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'application/json',
      }),
    };

    return this.http
      .request('post', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processPost(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processPost(<any>response_);
            } catch (e) {
              return <Observable<HttpResultOfInteger>>(<any>_observableThrow(e));
            }
          } else
            return <Observable<HttpResultOfInteger>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processPost(response: HttpResponseBase): Observable<HttpResultOfInteger> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = HttpResultOfInteger.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status === 404) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result404: any = null;
          let resultData404 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result404 = ProblemDetails.fromJS(resultData404);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result404
          );
        })
      );
    } else if (status === 400) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result400: any = null;
          let resultData400 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result400 = ProblemDetails.fromJS(resultData400);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result400
          );
        })
      );
    } else if (status === 422) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result422: any = null;
          let resultData422 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result422 = ValidationProblemDetails.fromJS(resultData422);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result422
          );
        })
      );
    } else {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let resultdefault: any = null;
          let resultDatadefault =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          resultdefault = ProblemDetails.fromJS(resultDatadefault);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            resultdefault
          );
        })
      );
    }
  }

  put(
    id: number | undefined,
    name_Ar: string | null | undefined,
    name_En: string | null | undefined,
    contactInfo_Name: string | null | undefined,
    contactInfo_Email: string | null | undefined,
    contactInfo_PhoneNumber: string | null | undefined,
    logo: FileParameter | null | undefined,
    isActive: boolean | undefined,
    categoryId: number | undefined,
    accountManagerId: number | null | undefined
  ): Observable<void> {
    let url_ = this.baseUrl + '/api/ServiceProviders';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = new FormData();
    if (id === null || id === undefined)
      throw new Error("The parameter 'id' cannot be null.");
    else content_.append('Id', id.toString());
    if (name_Ar !== null && name_Ar !== undefined)
      content_.append('Name.Ar', name_Ar.toString());
    if (name_En !== null && name_En !== undefined)
      content_.append('Name.En', name_En.toString());
    if (contactInfo_Name !== null && contactInfo_Name !== undefined)
      content_.append('ContactInfo.Name', contactInfo_Name.toString());
    if (contactInfo_Email !== null && contactInfo_Email !== undefined)
      content_.append('ContactInfo.Email', contactInfo_Email.toString());
    if (contactInfo_PhoneNumber !== null && contactInfo_PhoneNumber !== undefined)
      content_.append('ContactInfo.PhoneNumber', contactInfo_PhoneNumber.toString());
    if (logo !== null && logo !== undefined)
      content_.append('Logo', logo.data, logo.fileName ? logo.fileName : 'Logo');
    if (isActive === null || isActive === undefined)
      throw new Error("The parameter 'isActive' cannot be null.");
    else content_.append('IsActive', isActive.toString());
    if (categoryId === null || categoryId === undefined)
      throw new Error("The parameter 'categoryId' cannot be null.");
    else content_.append('CategoryId', categoryId.toString());
    if (accountManagerId !== null && accountManagerId !== undefined)
      content_.append('AccountManagerId', accountManagerId.toString());

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({}),
    };

    return this.http
      .request('put', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processPut(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processPut(<any>response_);
            } catch (e) {
              return <Observable<void>>(<any>_observableThrow(e));
            }
          } else return <Observable<void>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processPut(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return _observableOf<void>(<any>null);
        })
      );
    } else if (status === 404) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result404: any = null;
          let resultData404 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result404 = ProblemDetails.fromJS(resultData404);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result404
          );
        })
      );
    } else if (status === 400) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result400: any = null;
          let resultData400 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result400 = ProblemDetails.fromJS(resultData400);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result400
          );
        })
      );
    } else if (status === 422) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result422: any = null;
          let resultData422 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result422 = ValidationProblemDetails.fromJS(resultData422);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result422
          );
        })
      );
    } else {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let resultdefault: any = null;
          let resultDatadefault =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          resultdefault = ProblemDetails.fromJS(resultDatadefault);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            resultdefault
          );
        })
      );
    }
  }

  delete(id: number | undefined): Observable<void> {
    let url_ = this.baseUrl + '/api/ServiceProviders?';
    if (id === null) throw new Error("The parameter 'id' cannot be null.");
    else if (id !== undefined) url_ += 'id=' + encodeURIComponent('' + id) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({}),
    };

    return this.http
      .request('delete', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processDelete(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processDelete(<any>response_);
            } catch (e) {
              return <Observable<void>>(<any>_observableThrow(e));
            }
          } else return <Observable<void>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processDelete(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return _observableOf<void>(<any>null);
        })
      );
    } else if (status === 404) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result404: any = null;
          let resultData404 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result404 = ProblemDetails.fromJS(resultData404);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result404
          );
        })
      );
    } else if (status === 422) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result422: any = null;
          let resultData422 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result422 = ValidationProblemDetails.fromJS(resultData422);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result422
          );
        })
      );
    } else {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let resultdefault: any = null;
          let resultDatadefault =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          resultdefault = ProblemDetails.fromJS(resultDatadefault);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            resultdefault
          );
        })
      );
    }
  }
}

export interface IServicesClient {
  getPage(
    serviceProviderId: number | null | undefined,
    offset: number | null | undefined,
    pageIndex: number | null | undefined,
    search: string | null | undefined,
    ascending: boolean | undefined,
    sortBy: string | null | undefined
  ): Observable<PaginatedListOfGroupServiceDashboardVm>;
  getList(): Observable<GroupServiceVm[]>;
  get(id: number | undefined): Observable<GroupServiceDto>;
  post(
    name_Ar: string | null | undefined,
    name_En: string | null | undefined,
    contactInfo_Name: string | null | undefined,
    contactInfo_Email: string | null | undefined,
    contactInfo_PhoneNumber: string | null | undefined,
    logo: FileParameter | null | undefined,
    isActive: boolean | undefined,
    serviceProviderId: number | undefined,
    bookingFee_Name_Ar: string | null | undefined,
    bookingFee_Name_En: string | null | undefined,
    bookingFee_Amount: number | null | undefined,
    otherFee_Name_Ar: string | null | undefined,
    otherFee_Name_En: string | null | undefined,
    otherFee_Amount: number | null | undefined,
    services: ServiceDto[] | null | undefined
  ): Observable<HttpResultOfInteger>;
  put(
    id: number | undefined,
    name_Ar: string | null | undefined,
    name_En: string | null | undefined,
    contactInfo_Name: string | null | undefined,
    contactInfo_Email: string | null | undefined,
    contactInfo_PhoneNumber: string | null | undefined,
    logo: FileParameter | null | undefined,
    isActive: boolean | undefined,
    serviceProviderId: number | undefined,
    bookingFee_Name_Ar: string | null | undefined,
    bookingFee_Name_En: string | null | undefined,
    bookingFee_Amount: number | null | undefined,
    otherFee_Name_Ar: string | null | undefined,
    otherFee_Name_En: string | null | undefined,
    otherFee_Amount: number | null | undefined,
    services: ServiceDto[] | null | undefined
  ): Observable<void>;
  delete(id: number | undefined): Observable<void>;
}

@Injectable({
  providedIn: 'root',
})
export class ServicesClient implements IServicesClient {
  private http: HttpClient;
  private baseUrl: string;
  protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

  constructor(
    @Inject(HttpClient) http: HttpClient,
    @Optional() @Inject(API_BASE_URL) baseUrl?: string
  ) {
    this.http = http;
    this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : '';
  }

  getPage(
    serviceProviderId: number | null | undefined,
    offset: number | null | undefined,
    pageIndex: number | null | undefined,
    search: string | null | undefined,
    ascending: boolean | undefined,
    sortBy: string | null | undefined
  ): Observable<PaginatedListOfGroupServiceDashboardVm> {
    let url_ = this.baseUrl + '/api/Services/GetPage?';
    if (serviceProviderId !== undefined && serviceProviderId !== null)
      url_ += 'ServiceProviderId=' + encodeURIComponent('' + serviceProviderId) + '&';
    if (offset !== undefined && offset !== null)
      url_ += 'Offset=' + encodeURIComponent('' + offset) + '&';
    if (pageIndex !== undefined && pageIndex !== null)
      url_ += 'PageIndex=' + encodeURIComponent('' + pageIndex) + '&';
    if (search !== undefined && search !== null)
      url_ += 'Search=' + encodeURIComponent('' + search) + '&';
    if (ascending === null) throw new Error("The parameter 'ascending' cannot be null.");
    else if (ascending !== undefined)
      url_ += 'Ascending=' + encodeURIComponent('' + ascending) + '&';
    if (sortBy !== undefined && sortBy !== null)
      url_ += 'SortBy=' + encodeURIComponent('' + sortBy) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'application/json',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetPage(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetPage(<any>response_);
            } catch (e) {
              return <Observable<PaginatedListOfGroupServiceDashboardVm>>(
                (<any>_observableThrow(e))
              );
            }
          } else
            return <Observable<PaginatedListOfGroupServiceDashboardVm>>(
              (<any>_observableThrow(response_))
            );
        })
      );
  }

  protected processGetPage(
    response: HttpResponseBase
  ): Observable<PaginatedListOfGroupServiceDashboardVm> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = PaginatedListOfGroupServiceDashboardVm.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status === 422) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result422: any = null;
          let resultData422 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result422 = ValidationProblemDetails.fromJS(resultData422);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result422
          );
        })
      );
    } else {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let resultdefault: any = null;
          let resultDatadefault =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          resultdefault = ProblemDetails.fromJS(resultDatadefault);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            resultdefault
          );
        })
      );
    }
  }

  getList(): Observable<GroupServiceVm[]> {
    let url_ = this.baseUrl + '/api/Services/GetList';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'application/json',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetList(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetList(<any>response_);
            } catch (e) {
              return <Observable<GroupServiceVm[]>>(<any>_observableThrow(e));
            }
          } else return <Observable<GroupServiceVm[]>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processGetList(response: HttpResponseBase): Observable<GroupServiceVm[]> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          if (Array.isArray(resultData200)) {
            result200 = [] as any;
            for (let item of resultData200) result200!.push(GroupServiceVm.fromJS(item));
          } else {
            result200 = <any>null;
          }
          return _observableOf(result200);
        })
      );
    } else {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let resultdefault: any = null;
          let resultDatadefault =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          resultdefault = ProblemDetails.fromJS(resultDatadefault);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            resultdefault
          );
        })
      );
    }
  }

  get(id: number | undefined): Observable<GroupServiceDto> {
    let url_ = this.baseUrl + '/api/Services?';
    if (id === null) throw new Error("The parameter 'id' cannot be null.");
    else if (id !== undefined) url_ += 'id=' + encodeURIComponent('' + id) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'application/json',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGet(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGet(<any>response_);
            } catch (e) {
              return <Observable<GroupServiceDto>>(<any>_observableThrow(e));
            }
          } else return <Observable<GroupServiceDto>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processGet(response: HttpResponseBase): Observable<GroupServiceDto> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = GroupServiceDto.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status === 422) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result422: any = null;
          let resultData422 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result422 = ValidationProblemDetails.fromJS(resultData422);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result422
          );
        })
      );
    } else {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let resultdefault: any = null;
          let resultDatadefault =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          resultdefault = ProblemDetails.fromJS(resultDatadefault);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            resultdefault
          );
        })
      );
    }
  }

  post(
    name_Ar: string | null | undefined,
    name_En: string | null | undefined,
    contactInfo_Name: string | null | undefined,
    contactInfo_Email: string | null | undefined,
    contactInfo_PhoneNumber: string | null | undefined,
    logo: FileParameter | null | undefined,
    isActive: boolean | undefined,
    serviceProviderId: number | undefined,
    bookingFee_Name_Ar: string | null | undefined,
    bookingFee_Name_En: string | null | undefined,
    bookingFee_Amount: number | null | undefined,
    otherFee_Name_Ar: string | null | undefined,
    otherFee_Name_En: string | null | undefined,
    otherFee_Amount: number | null | undefined,
    services: ServiceDto[] | null | undefined
  ): Observable<HttpResultOfInteger> {
    let url_ = this.baseUrl + '/api/Services';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = new FormData();
    if (name_Ar !== null && name_Ar !== undefined)
      content_.append('Name.Ar', name_Ar.toString());
    if (name_En !== null && name_En !== undefined)
      content_.append('Name.En', name_En.toString());
    if (contactInfo_Name !== null && contactInfo_Name !== undefined)
      content_.append('ContactInfo.Name', contactInfo_Name.toString());
    if (contactInfo_Email !== null && contactInfo_Email !== undefined)
      content_.append('ContactInfo.Email', contactInfo_Email.toString());
    if (contactInfo_PhoneNumber !== null && contactInfo_PhoneNumber !== undefined)
      content_.append('ContactInfo.PhoneNumber', contactInfo_PhoneNumber.toString());
    if (logo !== null && logo !== undefined)
      content_.append('Logo', logo.data, logo.fileName ? logo.fileName : 'Logo');
    if (isActive === null || isActive === undefined)
      throw new Error("The parameter 'isActive' cannot be null.");
    else content_.append('IsActive', isActive.toString());
    if (serviceProviderId === null || serviceProviderId === undefined)
      throw new Error("The parameter 'serviceProviderId' cannot be null.");
    else content_.append('ServiceProviderId', serviceProviderId.toString());
    if (bookingFee_Name_Ar !== null && bookingFee_Name_Ar !== undefined)
      content_.append('BookingFee.Name.Ar', bookingFee_Name_Ar.toString());
    if (bookingFee_Name_En !== null && bookingFee_Name_En !== undefined)
      content_.append('BookingFee.Name.En', bookingFee_Name_En.toString());
    if (bookingFee_Amount !== null && bookingFee_Amount !== undefined)
      content_.append('BookingFee.Amount', bookingFee_Amount.toString());
    if (otherFee_Name_Ar !== null && otherFee_Name_Ar !== undefined)
      content_.append('OtherFee.Name.Ar', otherFee_Name_Ar.toString());
    if (otherFee_Name_En !== null && otherFee_Name_En !== undefined)
      content_.append('OtherFee.Name.En', otherFee_Name_En.toString());
    if (otherFee_Amount !== null && otherFee_Amount !== undefined)
      content_.append('OtherFee.Amount', otherFee_Amount.toString());
    if (services !== null && services !== undefined)
      services.forEach((item_, index_) => {
        if (item_.id) {
          content_.append(`Services[${index_}].Id`, item_.id.toString());
        }

        if (item_.name) {
          content_.append(`Services[${index_}].Name.Ar`, item_.name.ar.toString());
          content_.append(`Services[${index_}].Name.En`, item_.name.en.toString());
        }

        if (item_.isActive) {
          content_.append(`Services[${index_}].IsActive`, item_.isActive.toString());
        }
      });

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'application/json',
      }),
    };

    return this.http
      .request('post', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processPost(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processPost(<any>response_);
            } catch (e) {
              return <Observable<HttpResultOfInteger>>(<any>_observableThrow(e));
            }
          } else
            return <Observable<HttpResultOfInteger>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processPost(response: HttpResponseBase): Observable<HttpResultOfInteger> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = HttpResultOfInteger.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status === 404) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result404: any = null;
          let resultData404 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result404 = ProblemDetails.fromJS(resultData404);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result404
          );
        })
      );
    } else if (status === 400) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result400: any = null;
          let resultData400 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result400 = ProblemDetails.fromJS(resultData400);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result400
          );
        })
      );
    } else if (status === 422) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result422: any = null;
          let resultData422 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result422 = ValidationProblemDetails.fromJS(resultData422);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result422
          );
        })
      );
    } else {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let resultdefault: any = null;
          let resultDatadefault =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          resultdefault = ProblemDetails.fromJS(resultDatadefault);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            resultdefault
          );
        })
      );
    }
  }

  put(
    id: number | undefined,
    name_Ar: string | null | undefined,
    name_En: string | null | undefined,
    contactInfo_Name: string | null | undefined,
    contactInfo_Email: string | null | undefined,
    contactInfo_PhoneNumber: string | null | undefined,
    logo: FileParameter | null | undefined,
    isActive: boolean | undefined,
    serviceProviderId: number | undefined,
    bookingFee_Name_Ar: string | null | undefined,
    bookingFee_Name_En: string | null | undefined,
    bookingFee_Amount: number | null | undefined,
    otherFee_Name_Ar: string | null | undefined,
    otherFee_Name_En: string | null | undefined,
    otherFee_Amount: number | null | undefined,
    services: ServiceDto[] | null | undefined
  ): Observable<void> {
    let url_ = this.baseUrl + '/api/Services';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = new FormData();
    if (id === null || id === undefined)
      throw new Error("The parameter 'id' cannot be null.");
    else content_.append('Id', id.toString());
    if (name_Ar !== null && name_Ar !== undefined)
      content_.append('Name.Ar', name_Ar.toString());
    if (name_En !== null && name_En !== undefined)
      content_.append('Name.En', name_En.toString());
    if (contactInfo_Name !== null && contactInfo_Name !== undefined)
      content_.append('ContactInfo.Name', contactInfo_Name.toString());
    if (contactInfo_Email !== null && contactInfo_Email !== undefined)
      content_.append('ContactInfo.Email', contactInfo_Email.toString());
    if (contactInfo_PhoneNumber !== null && contactInfo_PhoneNumber !== undefined)
      content_.append('ContactInfo.PhoneNumber', contactInfo_PhoneNumber.toString());
    if (logo !== null && logo !== undefined)
      content_.append('Logo', logo.data, logo.fileName ? logo.fileName : 'Logo');
    if (isActive === null || isActive === undefined)
      throw new Error("The parameter 'isActive' cannot be null.");
    else content_.append('IsActive', isActive.toString());
    if (serviceProviderId === null || serviceProviderId === undefined)
      throw new Error("The parameter 'serviceProviderId' cannot be null.");
    else content_.append('ServiceProviderId', serviceProviderId.toString());
    if (bookingFee_Name_Ar !== null && bookingFee_Name_Ar !== undefined)
      content_.append('BookingFee.Name.Ar', bookingFee_Name_Ar.toString());
    if (bookingFee_Name_En !== null && bookingFee_Name_En !== undefined)
      content_.append('BookingFee.Name.En', bookingFee_Name_En.toString());
    if (bookingFee_Amount !== null && bookingFee_Amount !== undefined)
      content_.append('BookingFee.Amount', bookingFee_Amount.toString());
    if (otherFee_Name_Ar !== null && otherFee_Name_Ar !== undefined)
      content_.append('OtherFee.Name.Ar', otherFee_Name_Ar.toString());
    if (otherFee_Name_En !== null && otherFee_Name_En !== undefined)
      content_.append('OtherFee.Name.En', otherFee_Name_En.toString());
    if (otherFee_Amount !== null && otherFee_Amount !== undefined)
      content_.append('OtherFee.Amount', otherFee_Amount.toString());
    if (services !== null && services !== undefined)
      services.forEach((item_, index_) => {
        if (item_.id) {
          content_.append(`Services[${index_}].Id`, item_.id.toString());
        }

        if (item_.name) {
          content_.append(`Services[${index_}].Name.Ar`, item_.name.ar.toString());
          content_.append(`Services[${index_}].Name.En`, item_.name.en.toString());
        }

        if (item_.isActive) {
          content_.append(`Services[${index_}].IsActive`, item_.isActive.toString());
        }
      });

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({}),
    };

    return this.http
      .request('put', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processPut(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processPut(<any>response_);
            } catch (e) {
              return <Observable<void>>(<any>_observableThrow(e));
            }
          } else return <Observable<void>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processPut(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return _observableOf<void>(<any>null);
        })
      );
    } else if (status === 404) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result404: any = null;
          let resultData404 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result404 = ProblemDetails.fromJS(resultData404);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result404
          );
        })
      );
    } else if (status === 400) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result400: any = null;
          let resultData400 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result400 = ProblemDetails.fromJS(resultData400);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result400
          );
        })
      );
    } else if (status === 422) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result422: any = null;
          let resultData422 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result422 = ValidationProblemDetails.fromJS(resultData422);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result422
          );
        })
      );
    } else {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let resultdefault: any = null;
          let resultDatadefault =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          resultdefault = ProblemDetails.fromJS(resultDatadefault);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            resultdefault
          );
        })
      );
    }
  }

  delete(id: number | undefined): Observable<void> {
    let url_ = this.baseUrl + '/api/Services?';
    if (id === null) throw new Error("The parameter 'id' cannot be null.");
    else if (id !== undefined) url_ += 'id=' + encodeURIComponent('' + id) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({}),
    };

    return this.http
      .request('delete', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processDelete(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processDelete(<any>response_);
            } catch (e) {
              return <Observable<void>>(<any>_observableThrow(e));
            }
          } else return <Observable<void>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processDelete(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return _observableOf<void>(<any>null);
        })
      );
    } else if (status === 404) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result404: any = null;
          let resultData404 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result404 = ProblemDetails.fromJS(resultData404);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result404
          );
        })
      );
    } else if (status === 422) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result422: any = null;
          let resultData422 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result422 = ValidationProblemDetails.fromJS(resultData422);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result422
          );
        })
      );
    } else {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let resultdefault: any = null;
          let resultDatadefault =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          resultdefault = ProblemDetails.fromJS(resultDatadefault);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            resultdefault
          );
        })
      );
    }
  }
}

export interface ITransactionsClient {
  getPage(
    accountId: string | null | undefined,
    type: TransactionType | null | undefined,
    serviceProviderId: number | null | undefined,
    offset: number | null | undefined,
    pageIndex: number | null | undefined,
    search: string | null | undefined,
    ascending: boolean | undefined,
    sortBy: string | null | undefined
  ): Observable<PaginatedListOfTransactionVm>;
  getWallet(): Observable<WalletVm>;
  pay(command: TransactionsPayCommand): Observable<TransactionResponse>;
  confirmOtp(command: TransactionsConfirmOtpCommand): Observable<FileResponse>;
}

@Injectable({
  providedIn: 'root',
})
export class TransactionsClient implements ITransactionsClient {
  private http: HttpClient;
  private baseUrl: string;
  protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

  constructor(
    @Inject(HttpClient) http: HttpClient,
    @Optional() @Inject(API_BASE_URL) baseUrl?: string
  ) {
    this.http = http;
    this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : '';
  }

  getPage(
    accountId: string | null | undefined,
    type: TransactionType | null | undefined,
    serviceProviderId: number | null | undefined,
    offset: number | null | undefined,
    pageIndex: number | null | undefined,
    search: string | null | undefined,
    ascending: boolean | undefined,
    sortBy: string | null | undefined
  ): Observable<PaginatedListOfTransactionVm> {
    let url_ = this.baseUrl + '/api/Transactions/GetPage?';
    if (accountId !== undefined && accountId !== null)
      url_ += 'AccountId=' + encodeURIComponent('' + accountId) + '&';
    if (type !== undefined && type !== null)
      url_ += 'Type=' + encodeURIComponent('' + type) + '&';
    if (serviceProviderId !== undefined && serviceProviderId !== null)
      url_ += 'ServiceProviderId=' + encodeURIComponent('' + serviceProviderId) + '&';
    if (offset !== undefined && offset !== null)
      url_ += 'Offset=' + encodeURIComponent('' + offset) + '&';
    if (pageIndex !== undefined && pageIndex !== null)
      url_ += 'PageIndex=' + encodeURIComponent('' + pageIndex) + '&';
    if (search !== undefined && search !== null)
      url_ += 'Search=' + encodeURIComponent('' + search) + '&';
    if (ascending === null) throw new Error("The parameter 'ascending' cannot be null.");
    else if (ascending !== undefined)
      url_ += 'Ascending=' + encodeURIComponent('' + ascending) + '&';
    if (sortBy !== undefined && sortBy !== null)
      url_ += 'SortBy=' + encodeURIComponent('' + sortBy) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'application/json',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetPage(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetPage(<any>response_);
            } catch (e) {
              return <Observable<PaginatedListOfTransactionVm>>(<any>_observableThrow(e));
            }
          } else
            return <Observable<PaginatedListOfTransactionVm>>(
              (<any>_observableThrow(response_))
            );
        })
      );
  }

  protected processGetPage(
    response: HttpResponseBase
  ): Observable<PaginatedListOfTransactionVm> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = PaginatedListOfTransactionVm.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status === 422) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result422: any = null;
          let resultData422 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result422 = ValidationProblemDetails.fromJS(resultData422);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result422
          );
        })
      );
    } else {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let resultdefault: any = null;
          let resultDatadefault =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          resultdefault = ProblemDetails.fromJS(resultDatadefault);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            resultdefault
          );
        })
      );
    }
  }

  getWallet(): Observable<WalletVm> {
    let url_ = this.baseUrl + '/api/Transactions/GetWallet';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'application/json',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetWallet(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetWallet(<any>response_);
            } catch (e) {
              return <Observable<WalletVm>>(<any>_observableThrow(e));
            }
          } else return <Observable<WalletVm>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processGetWallet(response: HttpResponseBase): Observable<WalletVm> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = WalletVm.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let resultdefault: any = null;
          let resultDatadefault =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          resultdefault = ProblemDetails.fromJS(resultDatadefault);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            resultdefault
          );
        })
      );
    }
  }

  pay(command: TransactionsPayCommand): Observable<TransactionResponse> {
    let url_ = this.baseUrl + '/api/Transactions/Pay';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(command);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
        Accept: 'application/json',
      }),
    };

    return this.http
      .request('post', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processPay(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processPay(<any>response_);
            } catch (e) {
              return <Observable<TransactionResponse>>(<any>_observableThrow(e));
            }
          } else
            return <Observable<TransactionResponse>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processPay(response: HttpResponseBase): Observable<TransactionResponse> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = TransactionResponse.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<TransactionResponse>(<any>null);
  }

  confirmOtp(command: TransactionsConfirmOtpCommand): Observable<FileResponse> {
    let url_ = this.baseUrl + '/api/Transactions/ConfirmOtp';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(command);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
        Accept: 'application/octet-stream',
      }),
    };

    return this.http
      .request('post', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processConfirmOtp(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processConfirmOtp(<any>response_);
            } catch (e) {
              return <Observable<FileResponse>>(<any>_observableThrow(e));
            }
          } else return <Observable<FileResponse>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processConfirmOtp(response: HttpResponseBase): Observable<FileResponse> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200 || status === 206) {
      const contentDisposition = response.headers
        ? response.headers.get('content-disposition')
        : undefined;
      const fileNameMatch = contentDisposition
        ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition)
        : undefined;
      const fileName =
        fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
      return _observableOf({
        fileName: fileName,
        data: <any>responseBlob,
        status: status,
        headers: _headers,
      });
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<FileResponse>(<any>null);
  }
}

export interface IWorkingDaysClient {
  getList(queueId: number | undefined): Observable<WorkingDayDto[]>;
  put(command: WorkingDaysPutCommand): Observable<void>;
}

@Injectable({
  providedIn: 'root',
})
export class WorkingDaysClient implements IWorkingDaysClient {
  private http: HttpClient;
  private baseUrl: string;
  protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

  constructor(
    @Inject(HttpClient) http: HttpClient,
    @Optional() @Inject(API_BASE_URL) baseUrl?: string
  ) {
    this.http = http;
    this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : '';
  }

  getList(queueId: number | undefined): Observable<WorkingDayDto[]> {
    let url_ = this.baseUrl + '/api/WorkingDays?';
    if (queueId === null) throw new Error("The parameter 'queueId' cannot be null.");
    else if (queueId !== undefined)
      url_ += 'QueueId=' + encodeURIComponent('' + queueId) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'application/json',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetList(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetList(<any>response_);
            } catch (e) {
              return <Observable<WorkingDayDto[]>>(<any>_observableThrow(e));
            }
          } else return <Observable<WorkingDayDto[]>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processGetList(response: HttpResponseBase): Observable<WorkingDayDto[]> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          if (Array.isArray(resultData200)) {
            result200 = [] as any;
            for (let item of resultData200) result200!.push(WorkingDayDto.fromJS(item));
          } else {
            result200 = <any>null;
          }
          return _observableOf(result200);
        })
      );
    } else if (status === 422) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result422: any = null;
          let resultData422 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result422 = ValidationProblemDetails.fromJS(resultData422);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result422
          );
        })
      );
    } else {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let resultdefault: any = null;
          let resultDatadefault =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          resultdefault = ProblemDetails.fromJS(resultDatadefault);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            resultdefault
          );
        })
      );
    }
  }

  put(command: WorkingDaysPutCommand): Observable<void> {
    let url_ = this.baseUrl + '/api/WorkingDays';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(command);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
      }),
    };

    return this.http
      .request('put', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processPut(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processPut(<any>response_);
            } catch (e) {
              return <Observable<void>>(<any>_observableThrow(e));
            }
          } else return <Observable<void>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processPut(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return _observableOf<void>(<any>null);
        })
      );
    } else if (status === 404) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result404: any = null;
          let resultData404 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result404 = ProblemDetails.fromJS(resultData404);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result404
          );
        })
      );
    } else if (status === 400) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result400: any = null;
          let resultData400 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result400 = ProblemDetails.fromJS(resultData400);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result400
          );
        })
      );
    } else if (status === 422) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result422: any = null;
          let resultData422 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result422 = ValidationProblemDetails.fromJS(resultData422);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result422
          );
        })
      );
    } else {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let resultdefault: any = null;
          let resultDatadefault =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          resultdefault = ProblemDetails.fromJS(resultDatadefault);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            resultdefault
          );
        })
      );
    }
  }
}

export class ProblemDetails implements IProblemDetails {
  type?: string | undefined;
  title?: string | undefined;
  status?: number | undefined;
  detail?: string | undefined;
  instance?: string | undefined;
  extensions?: { [key: string]: any } | undefined;

  constructor(data?: IProblemDetails) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.type = _data['type'];
      this.title = _data['title'];
      this.status = _data['status'];
      this.detail = _data['detail'];
      this.instance = _data['instance'];
      if (_data['extensions']) {
        this.extensions = {} as any;
        for (let key in _data['extensions']) {
          if (_data['extensions'].hasOwnProperty(key))
            (<any>this.extensions)![key] = _data['extensions'][key];
        }
      }
    }
  }

  static fromJS(data: any): ProblemDetails {
    data = typeof data === 'object' ? data : {};
    let result = new ProblemDetails();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['type'] = this.type;
    data['title'] = this.title;
    data['status'] = this.status;
    data['detail'] = this.detail;
    data['instance'] = this.instance;
    if (this.extensions) {
      data['extensions'] = {};
      for (let key in this.extensions) {
        if (this.extensions.hasOwnProperty(key))
          (<any>data['extensions'])[key] = this.extensions[key];
      }
    }
    return data;
  }
}

export interface IProblemDetails {
  type?: string | undefined;
  title?: string | undefined;
  status?: number | undefined;
  detail?: string | undefined;
  instance?: string | undefined;
  extensions?: { [key: string]: any } | undefined;
}

export class PaginatedListOfAccountManagerDto
  implements IPaginatedListOfAccountManagerDto {
  pageInfo?: PageInfo | undefined;
  items?: AccountManagerDto[] | undefined;

  constructor(data?: IPaginatedListOfAccountManagerDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.pageInfo = _data['pageInfo']
        ? PageInfo.fromJS(_data['pageInfo'])
        : <any>undefined;
      if (Array.isArray(_data['items'])) {
        this.items = [] as any;
        for (let item of _data['items']) this.items!.push(AccountManagerDto.fromJS(item));
      }
    }
  }

  static fromJS(data: any): PaginatedListOfAccountManagerDto {
    data = typeof data === 'object' ? data : {};
    let result = new PaginatedListOfAccountManagerDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['pageInfo'] = this.pageInfo ? this.pageInfo.toJSON() : <any>undefined;
    if (Array.isArray(this.items)) {
      data['items'] = [];
      for (let item of this.items) data['items'].push(item.toJSON());
    }
    return data;
  }
}

export interface IPaginatedListOfAccountManagerDto {
  pageInfo?: PageInfo | undefined;
  items?: AccountManagerDto[] | undefined;
}

export class PageInfo implements IPageInfo {
  pageIndex?: number;
  totalPages?: number;
  totalCount?: number;

  constructor(data?: IPageInfo) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.pageIndex = _data['pageIndex'];
      this.totalPages = _data['totalPages'];
      this.totalCount = _data['totalCount'];
    }
  }

  static fromJS(data: any): PageInfo {
    data = typeof data === 'object' ? data : {};
    let result = new PageInfo();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['pageIndex'] = this.pageIndex;
    data['totalPages'] = this.totalPages;
    data['totalCount'] = this.totalCount;
    return data;
  }
}

export interface IPageInfo {
  pageIndex?: number;
  totalPages?: number;
  totalCount?: number;
}

export class AccountManagerDto implements IAccountManagerDto {
  id?: number;
  contactInfo?: ContactInfoDto | undefined;
  numberOfServiceProvider?: number;

  constructor(data?: IAccountManagerDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data['id'];
      this.contactInfo = _data['contactInfo']
        ? ContactInfoDto.fromJS(_data['contactInfo'])
        : <any>undefined;
      this.numberOfServiceProvider = _data['numberOfServiceProvider'];
    }
  }

  static fromJS(data: any): AccountManagerDto {
    data = typeof data === 'object' ? data : {};
    let result = new AccountManagerDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['id'] = this.id;
    data['contactInfo'] = this.contactInfo ? this.contactInfo.toJSON() : <any>undefined;
    data['numberOfServiceProvider'] = this.numberOfServiceProvider;
    return data;
  }
}

export interface IAccountManagerDto {
  id?: number;
  contactInfo?: ContactInfoDto | undefined;
  numberOfServiceProvider?: number;
}

export class ContactInfoDto implements IContactInfoDto {
  name?: string | undefined;
  email?: string | undefined;
  phoneNumber?: string | undefined;

  constructor(data?: IContactInfoDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.name = _data['name'];
      this.email = _data['email'];
      this.phoneNumber = _data['phoneNumber'];
    }
  }

  static fromJS(data: any): ContactInfoDto {
    data = typeof data === 'object' ? data : {};
    let result = new ContactInfoDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['name'] = this.name;
    data['email'] = this.email;
    data['phoneNumber'] = this.phoneNumber;
    return data;
  }
}

export interface IContactInfoDto {
  name?: string | undefined;
  email?: string | undefined;
  phoneNumber?: string | undefined;
}

export class ValidationProblemDetails extends ProblemDetails
  implements IValidationProblemDetails {
  errors?: { [key: string]: string[] } | undefined;

  constructor(data?: IValidationProblemDetails) {
    super(data);
  }

  init(_data?: any) {
    super.init(_data);
    if (_data) {
      if (_data['errors']) {
        this.errors = {} as any;
        for (let key in _data['errors']) {
          if (_data['errors'].hasOwnProperty(key))
            (<any>this.errors)![key] =
              _data['errors'][key] !== undefined ? _data['errors'][key] : [];
        }
      }
    }
  }

  static fromJS(data: any): ValidationProblemDetails {
    data = typeof data === 'object' ? data : {};
    let result = new ValidationProblemDetails();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    if (this.errors) {
      data['errors'] = {};
      for (let key in this.errors) {
        if (this.errors.hasOwnProperty(key))
          (<any>data['errors'])[key] = this.errors[key];
      }
    }
    super.toJSON(data);
    return data;
  }
}

export interface IValidationProblemDetails extends IProblemDetails {
  errors?: { [key: string]: string[] } | undefined;
}

export class AccountManagerVm implements IAccountManagerVm {
  id?: number;
  name?: string | undefined;

  constructor(data?: IAccountManagerVm) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data['id'];
      this.name = _data['name'];
    }
  }

  static fromJS(data: any): AccountManagerVm {
    data = typeof data === 'object' ? data : {};
    let result = new AccountManagerVm();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['id'] = this.id;
    data['name'] = this.name;
    return data;
  }
}

export interface IAccountManagerVm {
  id?: number;
  name?: string | undefined;
}

export class HttpResultOfInteger implements IHttpResultOfInteger {
  result?: number;

  constructor(data?: IHttpResultOfInteger) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.result = _data['result'];
    }
  }

  static fromJS(data: any): HttpResultOfInteger {
    data = typeof data === 'object' ? data : {};
    let result = new HttpResultOfInteger();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['result'] = this.result;
    return data;
  }
}

export interface IHttpResultOfInteger {
  result?: number;
}

export class AccountManagersPostPutCommon implements IAccountManagersPostPutCommon {
  contactInfo?: ContactInfoDto | undefined;

  constructor(data?: IAccountManagersPostPutCommon) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.contactInfo = _data['contactInfo']
        ? ContactInfoDto.fromJS(_data['contactInfo'])
        : <any>undefined;
    }
  }

  static fromJS(data: any): AccountManagersPostPutCommon {
    data = typeof data === 'object' ? data : {};
    let result = new AccountManagersPostPutCommon();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['contactInfo'] = this.contactInfo ? this.contactInfo.toJSON() : <any>undefined;
    return data;
  }
}

export interface IAccountManagersPostPutCommon {
  contactInfo?: ContactInfoDto | undefined;
}

export class AccountManagersPostCommand extends AccountManagersPostPutCommon
  implements IAccountManagersPostCommand {
  constructor(data?: IAccountManagersPostCommand) {
    super(data);
  }

  init(_data?: any) {
    super.init(_data);
  }

  static fromJS(data: any): AccountManagersPostCommand {
    data = typeof data === 'object' ? data : {};
    let result = new AccountManagersPostCommand();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    super.toJSON(data);
    return data;
  }
}

export interface IAccountManagersPostCommand extends IAccountManagersPostPutCommon {}

export class AccountManagersPutCommand extends AccountManagersPostPutCommon
  implements IAccountManagersPutCommand {
  id?: number;

  constructor(data?: IAccountManagersPutCommand) {
    super(data);
  }

  init(_data?: any) {
    super.init(_data);
    if (_data) {
      this.id = _data['id'];
    }
  }

  static fromJS(data: any): AccountManagersPutCommand {
    data = typeof data === 'object' ? data : {};
    let result = new AccountManagersPutCommand();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['id'] = this.id;
    super.toJSON(data);
    return data;
  }
}

export interface IAccountManagersPutCommand extends IAccountManagersPostPutCommon {
  id?: number;
}

export class PaginatedListOfAccountVm implements IPaginatedListOfAccountVm {
  pageInfo?: PageInfo | undefined;
  items?: AccountVm[] | undefined;

  constructor(data?: IPaginatedListOfAccountVm) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.pageInfo = _data['pageInfo']
        ? PageInfo.fromJS(_data['pageInfo'])
        : <any>undefined;
      if (Array.isArray(_data['items'])) {
        this.items = [] as any;
        for (let item of _data['items']) this.items!.push(AccountVm.fromJS(item));
      }
    }
  }

  static fromJS(data: any): PaginatedListOfAccountVm {
    data = typeof data === 'object' ? data : {};
    let result = new PaginatedListOfAccountVm();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['pageInfo'] = this.pageInfo ? this.pageInfo.toJSON() : <any>undefined;
    if (Array.isArray(this.items)) {
      data['items'] = [];
      for (let item of this.items) data['items'].push(item.toJSON());
    }
    return data;
  }
}

export interface IPaginatedListOfAccountVm {
  pageInfo?: PageInfo | undefined;
  items?: AccountVm[] | undefined;
}

export class AccountVm implements IAccountVm {
  id?: string | undefined;
  username?: string | undefined;
  fullName?: string | undefined;
  pictureUrl?: string | undefined;
  phoneNumber?: string | undefined;
  status?: AccountStatus;
  createdAt?: Date;

  constructor(data?: IAccountVm) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data['id'];
      this.username = _data['username'];
      this.fullName = _data['fullName'];
      this.pictureUrl = _data['pictureUrl'];
      this.phoneNumber = _data['phoneNumber'];
      this.status = _data['status'];
      this.createdAt = _data['createdAt']
        ? new Date(_data['createdAt'].toString())
        : <any>undefined;
    }
  }

  static fromJS(data: any): AccountVm {
    data = typeof data === 'object' ? data : {};
    let result = new AccountVm();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['id'] = this.id;
    data['username'] = this.username;
    data['fullName'] = this.fullName;
    data['pictureUrl'] = this.pictureUrl;
    data['phoneNumber'] = this.phoneNumber;
    data['status'] = this.status;
    data['createdAt'] = this.createdAt ? this.createdAt.toISOString() : <any>undefined;
    return data;
  }
}

export interface IAccountVm {
  id?: string | undefined;
  username?: string | undefined;
  fullName?: string | undefined;
  pictureUrl?: string | undefined;
  phoneNumber?: string | undefined;
  status?: AccountStatus;
  createdAt?: Date;
}

/** 0 = Live 1 = Banned 2 = Inactive */
export enum AccountStatus {
  Live = 0,
  Banned = 1,
  Inactive = 2,
}

export class PaginatedListOfAdminVm implements IPaginatedListOfAdminVm {
  pageInfo?: PageInfo | undefined;
  items?: AdminVm[] | undefined;

  constructor(data?: IPaginatedListOfAdminVm) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.pageInfo = _data['pageInfo']
        ? PageInfo.fromJS(_data['pageInfo'])
        : <any>undefined;
      if (Array.isArray(_data['items'])) {
        this.items = [] as any;
        for (let item of _data['items']) this.items!.push(AdminVm.fromJS(item));
      }
    }
  }

  static fromJS(data: any): PaginatedListOfAdminVm {
    data = typeof data === 'object' ? data : {};
    let result = new PaginatedListOfAdminVm();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['pageInfo'] = this.pageInfo ? this.pageInfo.toJSON() : <any>undefined;
    if (Array.isArray(this.items)) {
      data['items'] = [];
      for (let item of this.items) data['items'].push(item.toJSON());
    }
    return data;
  }
}

export interface IPaginatedListOfAdminVm {
  pageInfo?: PageInfo | undefined;
  items?: AdminVm[] | undefined;
}

export class AdminVm implements IAdminVm {
  id?: string | undefined;
  username?: string | undefined;
  fullName?: string | undefined;
  pictureUrl?: string | undefined;
  phoneNumber?: string | undefined;
  role?: Role | undefined;
  createdAt?: Date;

  constructor(data?: IAdminVm) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data['id'];
      this.username = _data['username'];
      this.fullName = _data['fullName'];
      this.pictureUrl = _data['pictureUrl'];
      this.phoneNumber = _data['phoneNumber'];
      this.role = _data['role'];
      this.createdAt = _data['createdAt']
        ? new Date(_data['createdAt'].toString())
        : <any>undefined;
    }
  }

  static fromJS(data: any): AdminVm {
    data = typeof data === 'object' ? data : {};
    let result = new AdminVm();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['id'] = this.id;
    data['username'] = this.username;
    data['fullName'] = this.fullName;
    data['pictureUrl'] = this.pictureUrl;
    data['phoneNumber'] = this.phoneNumber;
    data['role'] = this.role;
    data['createdAt'] = this.createdAt ? this.createdAt.toISOString() : <any>undefined;
    return data;
  }
}

export interface IAdminVm {
  id?: string | undefined;
  username?: string | undefined;
  fullName?: string | undefined;
  pictureUrl?: string | undefined;
  phoneNumber?: string | undefined;
  role?: Role | undefined;
  createdAt?: Date;
}

/** 0 = Admin 1 = ServiceProvider 2 = Branch 3 = Service 4 = Counter 5 = User */
export enum Role {
  Admin = 0,
  ServiceProvider = 1,
  Branch = 2,
  Service = 3,
  Counter = 4,
  User = 5,
}

export class AccountDashboardDto implements IAccountDashboardDto {
  name?: FullNameDto | undefined;
  email?: string | undefined;
  phoneNumber?: string | undefined;
  role?: Role | undefined;
  username?: string | undefined;
  serviceProviderId?: number | undefined;
  branchId?: number | undefined;
  serviceId?: number | undefined;
  pin?: string | undefined;

  constructor(data?: IAccountDashboardDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.name = _data['name'] ? FullNameDto.fromJS(_data['name']) : <any>undefined;
      this.email = _data['email'];
      this.phoneNumber = _data['phoneNumber'];
      this.role = _data['role'];
      this.username = _data['username'];
      this.serviceProviderId = _data['serviceProviderId'];
      this.branchId = _data['branchId'];
      this.serviceId = _data['serviceId'];
      this.pin = _data['pin'];
    }
  }

  static fromJS(data: any): AccountDashboardDto {
    data = typeof data === 'object' ? data : {};
    let result = new AccountDashboardDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['name'] = this.name ? this.name.toJSON() : <any>undefined;
    data['email'] = this.email;
    data['phoneNumber'] = this.phoneNumber;
    data['role'] = this.role;
    data['username'] = this.username;
    data['serviceProviderId'] = this.serviceProviderId;
    data['branchId'] = this.branchId;
    data['serviceId'] = this.serviceId;
    data['pin'] = this.pin;
    return data;
  }
}

export interface IAccountDashboardDto {
  name?: FullNameDto | undefined;
  email?: string | undefined;
  phoneNumber?: string | undefined;
  role?: Role | undefined;
  username?: string | undefined;
  serviceProviderId?: number | undefined;
  branchId?: number | undefined;
  serviceId?: number | undefined;
  pin?: string | undefined;
}

export class FullNameDto implements IFullNameDto {
  firstName?: string | undefined;
  lastName?: string | undefined;

  constructor(data?: IFullNameDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.firstName = _data['firstName'];
      this.lastName = _data['lastName'];
    }
  }

  static fromJS(data: any): FullNameDto {
    data = typeof data === 'object' ? data : {};
    let result = new FullNameDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['firstName'] = this.firstName;
    data['lastName'] = this.lastName;
    return data;
  }
}

export interface IFullNameDto {
  firstName?: string | undefined;
  lastName?: string | undefined;
}

export class AccountDto implements IAccountDto {
  email?: string | undefined;
  phoneNumber?: string | undefined;
  name?: FullNameDto | undefined;
  nationalId?: string | undefined;

  constructor(data?: IAccountDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.email = _data['email'];
      this.phoneNumber = _data['phoneNumber'];
      this.name = _data['name'] ? FullNameDto.fromJS(_data['name']) : <any>undefined;
      this.nationalId = _data['nationalId'];
    }
  }

  static fromJS(data: any): AccountDto {
    data = typeof data === 'object' ? data : {};
    let result = new AccountDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['email'] = this.email;
    data['phoneNumber'] = this.phoneNumber;
    data['name'] = this.name ? this.name.toJSON() : <any>undefined;
    data['nationalId'] = this.nationalId;
    return data;
  }
}

export interface IAccountDto {
  email?: string | undefined;
  phoneNumber?: string | undefined;
  name?: FullNameDto | undefined;
  nationalId?: string | undefined;
}

export class AccountResult implements IAccountResult {
  id?: string | undefined;
  username?: string | undefined;
  createdAt?: Date;

  constructor(data?: IAccountResult) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data['id'];
      this.username = _data['username'];
      this.createdAt = _data['createdAt']
        ? new Date(_data['createdAt'].toString())
        : <any>undefined;
    }
  }

  static fromJS(data: any): AccountResult {
    data = typeof data === 'object' ? data : {};
    let result = new AccountResult();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['id'] = this.id;
    data['username'] = this.username;
    data['createdAt'] = this.createdAt ? this.createdAt.toISOString() : <any>undefined;
    return data;
  }
}

export interface IAccountResult {
  id?: string | undefined;
  username?: string | undefined;
  createdAt?: Date;
}

export class UserPostCommon implements IUserPostCommon {
  fullName?: FullNameDto | undefined;
  email?: string | undefined;
  phoneNumber?: string | undefined;

  constructor(data?: IUserPostCommon) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.fullName = _data['fullName']
        ? FullNameDto.fromJS(_data['fullName'])
        : <any>undefined;
      this.email = _data['email'];
      this.phoneNumber = _data['phoneNumber'];
    }
  }

  static fromJS(data: any): UserPostCommon {
    data = typeof data === 'object' ? data : {};
    let result = new UserPostCommon();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['fullName'] = this.fullName ? this.fullName.toJSON() : <any>undefined;
    data['email'] = this.email;
    data['phoneNumber'] = this.phoneNumber;
    return data;
  }
}

export interface IUserPostCommon {
  fullName?: FullNameDto | undefined;
  email?: string | undefined;
  phoneNumber?: string | undefined;
}

export class AdminPostCommon extends UserPostCommon implements IAdminPostCommon {
  role?: Role;
  username?: string | undefined;
  serviceProviderId?: number | undefined;
  branchId?: number | undefined;
  serviceId?: number | undefined;
  pin?: string | undefined;

  constructor(data?: IAdminPostCommon) {
    super(data);
  }

  init(_data?: any) {
    super.init(_data);
    if (_data) {
      this.role = _data['role'];
      this.username = _data['username'];
      this.serviceProviderId = _data['serviceProviderId'];
      this.branchId = _data['branchId'];
      this.serviceId = _data['serviceId'];
      this.pin = _data['pin'];
    }
  }

  static fromJS(data: any): AdminPostCommon {
    data = typeof data === 'object' ? data : {};
    let result = new AdminPostCommon();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['role'] = this.role;
    data['username'] = this.username;
    data['serviceProviderId'] = this.serviceProviderId;
    data['branchId'] = this.branchId;
    data['serviceId'] = this.serviceId;
    data['pin'] = this.pin;
    super.toJSON(data);
    return data;
  }
}

export interface IAdminPostCommon extends IUserPostCommon {
  role?: Role;
  username?: string | undefined;
  serviceProviderId?: number | undefined;
  branchId?: number | undefined;
  serviceId?: number | undefined;
  pin?: string | undefined;
}

export class AccountsPostCommand extends AdminPostCommon implements IAccountsPostCommand {
  password?: string | undefined;
  confirmPassword?: string | undefined;

  constructor(data?: IAccountsPostCommand) {
    super(data);
  }

  init(_data?: any) {
    super.init(_data);
    if (_data) {
      this.password = _data['password'];
      this.confirmPassword = _data['confirmPassword'];
    }
  }

  static fromJS(data: any): AccountsPostCommand {
    data = typeof data === 'object' ? data : {};
    let result = new AccountsPostCommand();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['password'] = this.password;
    data['confirmPassword'] = this.confirmPassword;
    super.toJSON(data);
    return data;
  }
}

export interface IAccountsPostCommand extends IAdminPostCommon {
  password?: string | undefined;
  confirmPassword?: string | undefined;
}

export class AuthResponse implements IAuthResponse {
  token?: string | undefined;
  refreshToken?: string | undefined;

  constructor(data?: IAuthResponse) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.token = _data['token'];
      this.refreshToken = _data['refreshToken'];
    }
  }

  static fromJS(data: any): AuthResponse {
    data = typeof data === 'object' ? data : {};
    let result = new AuthResponse();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['token'] = this.token;
    data['refreshToken'] = this.refreshToken;
    return data;
  }
}

export interface IAuthResponse {
  token?: string | undefined;
  refreshToken?: string | undefined;
}

export class RefreshTokenCommand implements IRefreshTokenCommand {
  refreshToken?: string | undefined;

  constructor(data?: IRefreshTokenCommand) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.refreshToken = _data['refreshToken'];
    }
  }

  static fromJS(data: any): RefreshTokenCommand {
    data = typeof data === 'object' ? data : {};
    let result = new RefreshTokenCommand();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['refreshToken'] = this.refreshToken;
    return data;
  }
}

export interface IRefreshTokenCommand {
  refreshToken?: string | undefined;
}

export class LoginCommand implements ILoginCommand {
  email?: string | undefined;
  password?: string | undefined;

  constructor(data?: ILoginCommand) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.email = _data['email'];
      this.password = _data['password'];
    }
  }

  static fromJS(data: any): LoginCommand {
    data = typeof data === 'object' ? data : {};
    let result = new LoginCommand();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['email'] = this.email;
    data['password'] = this.password;
    return data;
  }
}

export interface ILoginCommand {
  email?: string | undefined;
  password?: string | undefined;
}

export class CounterAuthResponse extends AuthResponse implements ICounterAuthResponse {
  numberOfServices?: number;
  services?: CounterServiceVm[] | undefined;

  constructor(data?: ICounterAuthResponse) {
    super(data);
  }

  init(_data?: any) {
    super.init(_data);
    if (_data) {
      this.numberOfServices = _data['numberOfServices'];
      if (Array.isArray(_data['services'])) {
        this.services = [] as any;
        for (let item of _data['services'])
          this.services!.push(CounterServiceVm.fromJS(item));
      }
    }
  }

  static fromJS(data: any): CounterAuthResponse {
    data = typeof data === 'object' ? data : {};
    let result = new CounterAuthResponse();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['numberOfServices'] = this.numberOfServices;
    if (Array.isArray(this.services)) {
      data['services'] = [];
      for (let item of this.services) data['services'].push(item.toJSON());
    }
    super.toJSON(data);
    return data;
  }
}

export interface ICounterAuthResponse extends IAuthResponse {
  numberOfServices?: number;
  services?: CounterServiceVm[] | undefined;
}

export class CounterServiceVm implements ICounterServiceVm {
  serviceId?: number;
  logoUrl?: string | undefined;

  constructor(data?: ICounterServiceVm) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.serviceId = _data['serviceId'];
      this.logoUrl = _data['logoUrl'];
    }
  }

  static fromJS(data: any): CounterServiceVm {
    data = typeof data === 'object' ? data : {};
    let result = new CounterServiceVm();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['serviceId'] = this.serviceId;
    data['logoUrl'] = this.logoUrl;
    return data;
  }
}

export interface ICounterServiceVm {
  serviceId?: number;
  logoUrl?: string | undefined;
}

export class CountersLoginCommand implements ICountersLoginCommand {
  username?: string | undefined;
  password?: string | undefined;

  constructor(data?: ICountersLoginCommand) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.username = _data['username'];
      this.password = _data['password'];
    }
  }

  static fromJS(data: any): CountersLoginCommand {
    data = typeof data === 'object' ? data : {};
    let result = new CountersLoginCommand();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['username'] = this.username;
    data['password'] = this.password;
    return data;
  }
}

export interface ICountersLoginCommand {
  username?: string | undefined;
  password?: string | undefined;
}

export class HttpResultOfString implements IHttpResultOfString {
  result?: string | undefined;

  constructor(data?: IHttpResultOfString) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.result = _data['result'];
    }
  }

  static fromJS(data: any): HttpResultOfString {
    data = typeof data === 'object' ? data : {};
    let result = new HttpResultOfString();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['result'] = this.result;
    return data;
  }
}

export interface IHttpResultOfString {
  result?: string | undefined;
}

export class RegisterCommand extends UserPostCommon implements IRegisterCommand {
  nationalId?: string | undefined;
  password?: string | undefined;
  confirmPassword?: string | undefined;

  constructor(data?: IRegisterCommand) {
    super(data);
  }

  init(_data?: any) {
    super.init(_data);
    if (_data) {
      this.nationalId = _data['nationalId'];
      this.password = _data['password'];
      this.confirmPassword = _data['confirmPassword'];
    }
  }

  static fromJS(data: any): RegisterCommand {
    data = typeof data === 'object' ? data : {};
    let result = new RegisterCommand();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['nationalId'] = this.nationalId;
    data['password'] = this.password;
    data['confirmPassword'] = this.confirmPassword;
    super.toJSON(data);
    return data;
  }
}

export interface IRegisterCommand extends IUserPostCommon {
  nationalId?: string | undefined;
  password?: string | undefined;
  confirmPassword?: string | undefined;
}

export class ExternalLoginCommand implements IExternalLoginCommand {
  provider?: string | undefined;
  token?: string | undefined;
  email?: string | undefined;

  constructor(data?: IExternalLoginCommand) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.provider = _data['provider'];
      this.token = _data['token'];
      this.email = _data['email'];
    }
  }

  static fromJS(data: any): ExternalLoginCommand {
    data = typeof data === 'object' ? data : {};
    let result = new ExternalLoginCommand();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['provider'] = this.provider;
    data['token'] = this.token;
    data['email'] = this.email;
    return data;
  }
}

export interface IExternalLoginCommand {
  provider?: string | undefined;
  token?: string | undefined;
  email?: string | undefined;
}

export class ExternalRegisterCommand implements IExternalRegisterCommand {
  provider?: string | undefined;
  token?: string | undefined;
  phoneNumber?: string | undefined;

  constructor(data?: IExternalRegisterCommand) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.provider = _data['provider'];
      this.token = _data['token'];
      this.phoneNumber = _data['phoneNumber'];
    }
  }

  static fromJS(data: any): ExternalRegisterCommand {
    data = typeof data === 'object' ? data : {};
    let result = new ExternalRegisterCommand();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['provider'] = this.provider;
    data['token'] = this.token;
    data['phoneNumber'] = this.phoneNumber;
    return data;
  }
}

export interface IExternalRegisterCommand {
  provider?: string | undefined;
  token?: string | undefined;
  phoneNumber?: string | undefined;
}

export class ResetPasswordCommand implements IResetPasswordCommand {
  email?: string | undefined;
  token?: string | undefined;
  password?: string | undefined;
  confirmPassword?: string | undefined;

  constructor(data?: IResetPasswordCommand) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.email = _data['email'];
      this.token = _data['token'];
      this.password = _data['password'];
      this.confirmPassword = _data['confirmPassword'];
    }
  }

  static fromJS(data: any): ResetPasswordCommand {
    data = typeof data === 'object' ? data : {};
    let result = new ResetPasswordCommand();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['email'] = this.email;
    data['token'] = this.token;
    data['password'] = this.password;
    data['confirmPassword'] = this.confirmPassword;
    return data;
  }
}

export interface IResetPasswordCommand {
  email?: string | undefined;
  token?: string | undefined;
  password?: string | undefined;
  confirmPassword?: string | undefined;
}

export class ConfirmPhoneNumberCommand implements IConfirmPhoneNumberCommand {
  email?: string | undefined;
  token?: string | undefined;

  constructor(data?: IConfirmPhoneNumberCommand) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.email = _data['email'];
      this.token = _data['token'];
    }
  }

  static fromJS(data: any): ConfirmPhoneNumberCommand {
    data = typeof data === 'object' ? data : {};
    let result = new ConfirmPhoneNumberCommand();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['email'] = this.email;
    data['token'] = this.token;
    return data;
  }
}

export interface IConfirmPhoneNumberCommand {
  email?: string | undefined;
  token?: string | undefined;
}

export class ConfirmChangePhoneNumberCommand implements IConfirmChangePhoneNumberCommand {
  token?: string | undefined;

  constructor(data?: IConfirmChangePhoneNumberCommand) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.token = _data['token'];
    }
  }

  static fromJS(data: any): ConfirmChangePhoneNumberCommand {
    data = typeof data === 'object' ? data : {};
    let result = new ConfirmChangePhoneNumberCommand();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['token'] = this.token;
    return data;
  }
}

export interface IConfirmChangePhoneNumberCommand {
  token?: string | undefined;
}

export class ResendPhoneNumberConfirmationCommand
  implements IResendPhoneNumberConfirmationCommand {
  email?: string | undefined;

  constructor(data?: IResendPhoneNumberConfirmationCommand) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.email = _data['email'];
    }
  }

  static fromJS(data: any): ResendPhoneNumberConfirmationCommand {
    data = typeof data === 'object' ? data : {};
    let result = new ResendPhoneNumberConfirmationCommand();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['email'] = this.email;
    return data;
  }
}

export interface IResendPhoneNumberConfirmationCommand {
  email?: string | undefined;
}

export class ForgetPasswordCommand implements IForgetPasswordCommand {
  email?: string | undefined;

  constructor(data?: IForgetPasswordCommand) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.email = _data['email'];
    }
  }

  static fromJS(data: any): ForgetPasswordCommand {
    data = typeof data === 'object' ? data : {};
    let result = new ForgetPasswordCommand();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['email'] = this.email;
    return data;
  }
}

export interface IForgetPasswordCommand {
  email?: string | undefined;
}

export class AccountsPutCommand extends AdminPostCommon implements IAccountsPutCommand {
  id?: string | undefined;

  constructor(data?: IAccountsPutCommand) {
    super(data);
  }

  init(_data?: any) {
    super.init(_data);
    if (_data) {
      this.id = _data['id'];
    }
  }

  static fromJS(data: any): AccountsPutCommand {
    data = typeof data === 'object' ? data : {};
    let result = new AccountsPutCommand();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['id'] = this.id;
    super.toJSON(data);
    return data;
  }
}

export interface IAccountsPutCommand extends IAdminPostCommon {
  id?: string | undefined;
}

export class ChangePhoneNumberCommand implements IChangePhoneNumberCommand {
  phoneNumber?: string | undefined;

  constructor(data?: IChangePhoneNumberCommand) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.phoneNumber = _data['phoneNumber'];
    }
  }

  static fromJS(data: any): ChangePhoneNumberCommand {
    data = typeof data === 'object' ? data : {};
    let result = new ChangePhoneNumberCommand();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['phoneNumber'] = this.phoneNumber;
    return data;
  }
}

export interface IChangePhoneNumberCommand {
  phoneNumber?: string | undefined;
}

export class ChangePasswordCommand implements IChangePasswordCommand {
  oldPassword?: string | undefined;
  newPassword?: string | undefined;
  confirmPassword?: string | undefined;

  constructor(data?: IChangePasswordCommand) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.oldPassword = _data['oldPassword'];
      this.newPassword = _data['newPassword'];
      this.confirmPassword = _data['confirmPassword'];
    }
  }

  static fromJS(data: any): ChangePasswordCommand {
    data = typeof data === 'object' ? data : {};
    let result = new ChangePasswordCommand();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['oldPassword'] = this.oldPassword;
    data['newPassword'] = this.newPassword;
    data['confirmPassword'] = this.confirmPassword;
    return data;
  }
}

export interface IChangePasswordCommand {
  oldPassword?: string | undefined;
  newPassword?: string | undefined;
  confirmPassword?: string | undefined;
}

export class ChangeLanguageCommand implements IChangeLanguageCommand {
  language?: Language;

  constructor(data?: IChangeLanguageCommand) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.language = _data['language'];
    }
  }

  static fromJS(data: any): ChangeLanguageCommand {
    data = typeof data === 'object' ? data : {};
    let result = new ChangeLanguageCommand();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['language'] = this.language;
    return data;
  }
}

export interface IChangeLanguageCommand {
  language?: Language;
}

/** 0 = En 1 = Ar */
export enum Language {
  En = 0,
  Ar = 1,
}

export class ResetUserPasswordCommand implements IResetUserPasswordCommand {
  accountId?: string | undefined;
  password?: string | undefined;
  confirmPassword?: string | undefined;

  constructor(data?: IResetUserPasswordCommand) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.accountId = _data['accountId'];
      this.password = _data['password'];
      this.confirmPassword = _data['confirmPassword'];
    }
  }

  static fromJS(data: any): ResetUserPasswordCommand {
    data = typeof data === 'object' ? data : {};
    let result = new ResetUserPasswordCommand();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['accountId'] = this.accountId;
    data['password'] = this.password;
    data['confirmPassword'] = this.confirmPassword;
    return data;
  }
}

export interface IResetUserPasswordCommand {
  accountId?: string | undefined;
  password?: string | undefined;
  confirmPassword?: string | undefined;
}

export class AccountsBanCommand implements IAccountsBanCommand {
  id?: string | undefined;
  ban?: boolean;

  constructor(data?: IAccountsBanCommand) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data['id'];
      this.ban = _data['ban'];
    }
  }

  static fromJS(data: any): AccountsBanCommand {
    data = typeof data === 'object' ? data : {};
    let result = new AccountsBanCommand();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['id'] = this.id;
    data['ban'] = this.ban;
    return data;
  }
}

export interface IAccountsBanCommand {
  id?: string | undefined;
  ban?: boolean;
}

export class ServiceProviderVm implements IServiceProviderVm {
  id?: number;
  name?: string | undefined;
  logoUrl?: string | undefined;
  services?: ServiceVm[] | undefined;

  constructor(data?: IServiceProviderVm) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data['id'];
      this.name = _data['name'];
      this.logoUrl = _data['logoUrl'];
      if (Array.isArray(_data['services'])) {
        this.services = [] as any;
        for (let item of _data['services']) this.services!.push(ServiceVm.fromJS(item));
      }
    }
  }

  static fromJS(data: any): ServiceProviderVm {
    data = typeof data === 'object' ? data : {};
    let result = new ServiceProviderVm();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['id'] = this.id;
    data['name'] = this.name;
    data['logoUrl'] = this.logoUrl;
    if (Array.isArray(this.services)) {
      data['services'] = [];
      for (let item of this.services) data['services'].push(item.toJSON());
    }
    return data;
  }
}

export interface IServiceProviderVm {
  id?: number;
  name?: string | undefined;
  logoUrl?: string | undefined;
  services?: ServiceVm[] | undefined;
}

export class ServiceVm implements IServiceVm {
  id?: number;
  name?: string | undefined;

  constructor(data?: IServiceVm) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data['id'];
      this.name = _data['name'];
    }
  }

  static fromJS(data: any): ServiceVm {
    data = typeof data === 'object' ? data : {};
    let result = new ServiceVm();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['id'] = this.id;
    data['name'] = this.name;
    return data;
  }
}

export interface IServiceVm {
  id?: number;
  name?: string | undefined;
}

export class ServiceDataVm implements IServiceDataVm {
  bookingFee?: number | undefined;
  otherFeeName?: string | undefined;
  otherFeeAmount?: number | undefined;
  governorates?: GovernorateVm[] | undefined;

  constructor(data?: IServiceDataVm) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.bookingFee = _data['bookingFee'];
      this.otherFeeName = _data['otherFeeName'];
      this.otherFeeAmount = _data['otherFeeAmount'];
      if (Array.isArray(_data['governorates'])) {
        this.governorates = [] as any;
        for (let item of _data['governorates'])
          this.governorates!.push(GovernorateVm.fromJS(item));
      }
    }
  }

  static fromJS(data: any): ServiceDataVm {
    data = typeof data === 'object' ? data : {};
    let result = new ServiceDataVm();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['bookingFee'] = this.bookingFee;
    data['otherFeeName'] = this.otherFeeName;
    data['otherFeeAmount'] = this.otherFeeAmount;
    if (Array.isArray(this.governorates)) {
      data['governorates'] = [];
      for (let item of this.governorates) data['governorates'].push(item.toJSON());
    }
    return data;
  }
}

export interface IServiceDataVm {
  bookingFee?: number | undefined;
  otherFeeName?: string | undefined;
  otherFeeAmount?: number | undefined;
  governorates?: GovernorateVm[] | undefined;
}

export class GovernorateVm implements IGovernorateVm {
  id?: number;
  name?: string | undefined;
  districts?: DistrictVm[] | undefined;

  constructor(data?: IGovernorateVm) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data['id'];
      this.name = _data['name'];
      if (Array.isArray(_data['districts'])) {
        this.districts = [] as any;
        for (let item of _data['districts'])
          this.districts!.push(DistrictVm.fromJS(item));
      }
    }
  }

  static fromJS(data: any): GovernorateVm {
    data = typeof data === 'object' ? data : {};
    let result = new GovernorateVm();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['id'] = this.id;
    data['name'] = this.name;
    if (Array.isArray(this.districts)) {
      data['districts'] = [];
      for (let item of this.districts) data['districts'].push(item.toJSON());
    }
    return data;
  }
}

export interface IGovernorateVm {
  id?: number;
  name?: string | undefined;
  districts?: DistrictVm[] | undefined;
}

export class DistrictVm implements IDistrictVm {
  id?: number;
  name?: string | undefined;
  branches?: BranchVm[] | undefined;

  constructor(data?: IDistrictVm) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data['id'];
      this.name = _data['name'];
      if (Array.isArray(_data['branches'])) {
        this.branches = [] as any;
        for (let item of _data['branches']) this.branches!.push(BranchVm.fromJS(item));
      }
    }
  }

  static fromJS(data: any): DistrictVm {
    data = typeof data === 'object' ? data : {};
    let result = new DistrictVm();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['id'] = this.id;
    data['name'] = this.name;
    if (Array.isArray(this.branches)) {
      data['branches'] = [];
      for (let item of this.branches) data['branches'].push(item.toJSON());
    }
    return data;
  }
}

export interface IDistrictVm {
  id?: number;
  name?: string | undefined;
  branches?: BranchVm[] | undefined;
}

export class BranchVm implements IBranchVm {
  id?: number;
  name?: string | undefined;
  street?: string | undefined;
  longitude?: number;
  latitude?: number;
  averageServingTime?: number;

  constructor(data?: IBranchVm) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data['id'];
      this.name = _data['name'];
      this.street = _data['street'];
      this.longitude = _data['longitude'];
      this.latitude = _data['latitude'];
      this.averageServingTime = _data['averageServingTime'];
    }
  }

  static fromJS(data: any): BranchVm {
    data = typeof data === 'object' ? data : {};
    let result = new BranchVm();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['id'] = this.id;
    data['name'] = this.name;
    data['street'] = this.street;
    data['longitude'] = this.longitude;
    data['latitude'] = this.latitude;
    data['averageServingTime'] = this.averageServingTime;
    return data;
  }
}

export interface IBranchVm {
  id?: number;
  name?: string | undefined;
  street?: string | undefined;
  longitude?: number;
  latitude?: number;
  averageServingTime?: number;
}

export class AvailableAppointmentVm implements IAvailableAppointmentVm {
  days?: DayVm[] | undefined;
  offDays?: OffDayVm[] | undefined;

  constructor(data?: IAvailableAppointmentVm) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      if (Array.isArray(_data['days'])) {
        this.days = [] as any;
        for (let item of _data['days']) this.days!.push(DayVm.fromJS(item));
      }
      if (Array.isArray(_data['offDays'])) {
        this.offDays = [] as any;
        for (let item of _data['offDays']) this.offDays!.push(OffDayVm.fromJS(item));
      }
    }
  }

  static fromJS(data: any): AvailableAppointmentVm {
    data = typeof data === 'object' ? data : {};
    let result = new AvailableAppointmentVm();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    if (Array.isArray(this.days)) {
      data['days'] = [];
      for (let item of this.days) data['days'].push(item.toJSON());
    }
    if (Array.isArray(this.offDays)) {
      data['offDays'] = [];
      for (let item of this.offDays) data['offDays'].push(item.toJSON());
    }
    return data;
  }
}

export interface IAvailableAppointmentVm {
  days?: DayVm[] | undefined;
  offDays?: OffDayVm[] | undefined;
}

export class DayVm implements IDayVm {
  id?: number;
  workDay?: DayOfWeek;
  startTimeH?: number;
  startTimeM?: number;
  endTimeH?: number;
  endTimeM?: number;
  nightShift?: boolean;

  constructor(data?: IDayVm) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data['id'];
      this.workDay = _data['workDay'];
      this.startTimeH = _data['startTimeH'];
      this.startTimeM = _data['startTimeM'];
      this.endTimeH = _data['endTimeH'];
      this.endTimeM = _data['endTimeM'];
      this.nightShift = _data['nightShift'];
    }
  }

  static fromJS(data: any): DayVm {
    data = typeof data === 'object' ? data : {};
    let result = new DayVm();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['id'] = this.id;
    data['workDay'] = this.workDay;
    data['startTimeH'] = this.startTimeH;
    data['startTimeM'] = this.startTimeM;
    data['endTimeH'] = this.endTimeH;
    data['endTimeM'] = this.endTimeM;
    data['nightShift'] = this.nightShift;
    return data;
  }
}

export interface IDayVm {
  id?: number;
  workDay?: DayOfWeek;
  startTimeH?: number;
  startTimeM?: number;
  endTimeH?: number;
  endTimeM?: number;
  nightShift?: boolean;
}

/** 0 = Sunday 1 = Monday 2 = Tuesday 3 = Wednesday 4 = Thursday 5 = Friday 6 = Saturday */
export enum DayOfWeek {
  Sunday = 0,
  Monday = 1,
  Tuesday = 2,
  Wednesday = 3,
  Thursday = 4,
  Friday = 5,
  Saturday = 6,
}

export class OffDayVm implements IOffDayVm {
  date?: Date;

  constructor(data?: IOffDayVm) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.date = _data['date'] ? new Date(_data['date'].toString()) : <any>undefined;
    }
  }

  static fromJS(data: any): OffDayVm {
    data = typeof data === 'object' ? data : {};
    let result = new OffDayVm();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['date'] = this.date ? this.date.toISOString() : <any>undefined;
    return data;
  }
}

export interface IOffDayVm {
  date?: Date;
}

export class ReservationVm implements IReservationVm {
  date?: Date;
  timeH?: number;
  timeM?: number;

  constructor(data?: IReservationVm) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.date = _data['date'] ? new Date(_data['date'].toString()) : <any>undefined;
      this.timeH = _data['timeH'];
      this.timeM = _data['timeM'];
    }
  }

  static fromJS(data: any): ReservationVm {
    data = typeof data === 'object' ? data : {};
    let result = new ReservationVm();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['date'] = this.date ? this.date.toISOString() : <any>undefined;
    data['timeH'] = this.timeH;
    data['timeM'] = this.timeM;
    return data;
  }
}

export interface IReservationVm {
  date?: Date;
  timeH?: number;
  timeM?: number;
}

export class ReservationFullVm implements IReservationFullVm {
  id?: number;
  code?: string | undefined;
  status?: ReservationStatus;
  logoUrl?: string | undefined;
  serviceProviderName?: string | undefined;
  serviceName?: string | undefined;
  governorateName?: string | undefined;
  districtName?: string | undefined;
  streetName?: string | undefined;
  branchName?: string | undefined;
  branchLongitude?: number;
  branchLatitude?: number;
  date?: Date;
  timeH?: number;
  timeM?: number;

  constructor(data?: IReservationFullVm) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data['id'];
      this.code = _data['code'];
      this.status = _data['status'];
      this.logoUrl = _data['logoUrl'];
      this.serviceProviderName = _data['serviceProviderName'];
      this.serviceName = _data['serviceName'];
      this.governorateName = _data['governorateName'];
      this.districtName = _data['districtName'];
      this.streetName = _data['streetName'];
      this.branchName = _data['branchName'];
      this.branchLongitude = _data['branchLongitude'];
      this.branchLatitude = _data['branchLatitude'];
      this.date = _data['date'] ? new Date(_data['date'].toString()) : <any>undefined;
      this.timeH = _data['timeH'];
      this.timeM = _data['timeM'];
    }
  }

  static fromJS(data: any): ReservationFullVm {
    data = typeof data === 'object' ? data : {};
    let result = new ReservationFullVm();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['id'] = this.id;
    data['code'] = this.code;
    data['status'] = this.status;
    data['logoUrl'] = this.logoUrl;
    data['serviceProviderName'] = this.serviceProviderName;
    data['serviceName'] = this.serviceName;
    data['governorateName'] = this.governorateName;
    data['districtName'] = this.districtName;
    data['streetName'] = this.streetName;
    data['branchName'] = this.branchName;
    data['branchLongitude'] = this.branchLongitude;
    data['branchLatitude'] = this.branchLatitude;
    data['date'] = this.date ? this.date.toISOString() : <any>undefined;
    data['timeH'] = this.timeH;
    data['timeM'] = this.timeM;
    return data;
  }
}

export interface IReservationFullVm {
  id?: number;
  code?: string | undefined;
  status?: ReservationStatus;
  logoUrl?: string | undefined;
  serviceProviderName?: string | undefined;
  serviceName?: string | undefined;
  governorateName?: string | undefined;
  districtName?: string | undefined;
  streetName?: string | undefined;
  branchName?: string | undefined;
  branchLongitude?: number;
  branchLatitude?: number;
  date?: Date;
  timeH?: number;
  timeM?: number;
}

/** 0 = Pending 1 = Created 2 = Called 3 = Cancelled */
export enum ReservationStatus {
  Pending = 0,
  Created = 1,
  Called = 2,
  Cancelled = 3,
}

export class AppointmentResponse implements IAppointmentResponse {
  payment?: PaymentResponse | undefined;
  data?: ReservationData | undefined;

  constructor(data?: IAppointmentResponse) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.payment = _data['payment']
        ? PaymentResponse.fromJS(_data['payment'])
        : <any>undefined;
      this.data = _data['data'] ? ReservationData.fromJS(_data['data']) : <any>undefined;
    }
  }

  static fromJS(data: any): AppointmentResponse {
    data = typeof data === 'object' ? data : {};
    let result = new AppointmentResponse();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['payment'] = this.payment ? this.payment.toJSON() : <any>undefined;
    data['data'] = this.data ? this.data.toJSON() : <any>undefined;
    return data;
  }
}

export interface IAppointmentResponse {
  payment?: PaymentResponse | undefined;
  data?: ReservationData | undefined;
}

export class PaymentResponse implements IPaymentResponse {
  id?: number;
  amount?: number;

  constructor(data?: IPaymentResponse) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data['id'];
      this.amount = _data['amount'];
    }
  }

  static fromJS(data: any): PaymentResponse {
    data = typeof data === 'object' ? data : {};
    let result = new PaymentResponse();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['id'] = this.id;
    data['amount'] = this.amount;
    return data;
  }
}

export interface IPaymentResponse {
  id?: number;
  amount?: number;
}

export class ReservationData implements IReservationData {
  id?: number;
  code?: string | undefined;

  constructor(data?: IReservationData) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data['id'];
      this.code = _data['code'];
    }
  }

  static fromJS(data: any): ReservationData {
    data = typeof data === 'object' ? data : {};
    let result = new ReservationData();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['id'] = this.id;
    data['code'] = this.code;
    return data;
  }
}

export interface IReservationData {
  id?: number;
  code?: string | undefined;
}

export class AppointmentsPostCommand implements IAppointmentsPostCommand {
  branchId?: number;
  serviceId?: number;
  date?: Date;
  timeH?: number;
  timeM?: number;

  constructor(data?: IAppointmentsPostCommand) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.branchId = _data['branchId'];
      this.serviceId = _data['serviceId'];
      this.date = _data['date'] ? new Date(_data['date'].toString()) : <any>undefined;
      this.timeH = _data['timeH'];
      this.timeM = _data['timeM'];
    }
  }

  static fromJS(data: any): AppointmentsPostCommand {
    data = typeof data === 'object' ? data : {};
    let result = new AppointmentsPostCommand();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['branchId'] = this.branchId;
    data['serviceId'] = this.serviceId;
    data['date'] = this.date ? this.date.toISOString() : <any>undefined;
    data['timeH'] = this.timeH;
    data['timeM'] = this.timeM;
    return data;
  }
}

export interface IAppointmentsPostCommand {
  branchId?: number;
  serviceId?: number;
  date?: Date;
  timeH?: number;
  timeM?: number;
}

export class PaginatedListOfBranchDashboardVm
  implements IPaginatedListOfBranchDashboardVm {
  pageInfo?: PageInfo | undefined;
  items?: BranchDashboardVm[] | undefined;

  constructor(data?: IPaginatedListOfBranchDashboardVm) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.pageInfo = _data['pageInfo']
        ? PageInfo.fromJS(_data['pageInfo'])
        : <any>undefined;
      if (Array.isArray(_data['items'])) {
        this.items = [] as any;
        for (let item of _data['items']) this.items!.push(BranchDashboardVm.fromJS(item));
      }
    }
  }

  static fromJS(data: any): PaginatedListOfBranchDashboardVm {
    data = typeof data === 'object' ? data : {};
    let result = new PaginatedListOfBranchDashboardVm();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['pageInfo'] = this.pageInfo ? this.pageInfo.toJSON() : <any>undefined;
    if (Array.isArray(this.items)) {
      data['items'] = [];
      for (let item of this.items) data['items'].push(item.toJSON());
    }
    return data;
  }
}

export interface IPaginatedListOfBranchDashboardVm {
  pageInfo?: PageInfo | undefined;
  items?: BranchDashboardVm[] | undefined;
}

export class BranchDashboardVm implements IBranchDashboardVm {
  id?: number;
  code?: string | undefined;
  name?: string | undefined;
  serviceProviderId?: number;
  serviceProviderName?: string | undefined;
  numberOfQueues?: number;

  constructor(data?: IBranchDashboardVm) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data['id'];
      this.code = _data['code'];
      this.name = _data['name'];
      this.serviceProviderId = _data['serviceProviderId'];
      this.serviceProviderName = _data['serviceProviderName'];
      this.numberOfQueues = _data['numberOfQueues'];
    }
  }

  static fromJS(data: any): BranchDashboardVm {
    data = typeof data === 'object' ? data : {};
    let result = new BranchDashboardVm();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['id'] = this.id;
    data['code'] = this.code;
    data['name'] = this.name;
    data['serviceProviderId'] = this.serviceProviderId;
    data['serviceProviderName'] = this.serviceProviderName;
    data['numberOfQueues'] = this.numberOfQueues;
    return data;
  }
}

export interface IBranchDashboardVm {
  id?: number;
  code?: string | undefined;
  name?: string | undefined;
  serviceProviderId?: number;
  serviceProviderName?: string | undefined;
  numberOfQueues?: number;
}

export class CounterDataDto implements ICounterDataDto {
  id?: number;
  firstMessage?: LocalizedStringDto | undefined;
  lastMessage?: LocalizedStringDto | undefined;
  skipNumber?: number;

  constructor(data?: ICounterDataDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data['id'];
      this.firstMessage = _data['firstMessage']
        ? LocalizedStringDto.fromJS(_data['firstMessage'])
        : <any>undefined;
      this.lastMessage = _data['lastMessage']
        ? LocalizedStringDto.fromJS(_data['lastMessage'])
        : <any>undefined;
      this.skipNumber = _data['skipNumber'];
    }
  }

  static fromJS(data: any): CounterDataDto {
    data = typeof data === 'object' ? data : {};
    let result = new CounterDataDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['id'] = this.id;
    data['firstMessage'] = this.firstMessage
      ? this.firstMessage.toJSON()
      : <any>undefined;
    data['lastMessage'] = this.lastMessage ? this.lastMessage.toJSON() : <any>undefined;
    data['skipNumber'] = this.skipNumber;
    return data;
  }
}

export interface ICounterDataDto {
  id?: number;
  firstMessage?: LocalizedStringDto | undefined;
  lastMessage?: LocalizedStringDto | undefined;
  skipNumber?: number;
}

export class LocalizedStringDto implements ILocalizedStringDto {
  ar?: string | undefined;
  en?: string | undefined;

  constructor(data?: ILocalizedStringDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.ar = _data['ar'];
      this.en = _data['en'];
    }
  }

  static fromJS(data: any): LocalizedStringDto {
    data = typeof data === 'object' ? data : {};
    let result = new LocalizedStringDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['ar'] = this.ar;
    data['en'] = this.en;
    return data;
  }
}

export interface ILocalizedStringDto {
  ar?: string | undefined;
  en?: string | undefined;
}

export class BranchDto implements IBranchDto {
  id?: number;
  code?: string | undefined;
  name?: LocalizedStringDto | undefined;
  contactInfo?: ContactInfoDto | undefined;
  address?: AddressDto | undefined;
  logoUrl?: string | undefined;
  isActive?: boolean;
  serviceProviderId?: number;
  serviceProviderName?: string | undefined;

  constructor(data?: IBranchDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data['id'];
      this.code = _data['code'];
      this.name = _data['name']
        ? LocalizedStringDto.fromJS(_data['name'])
        : <any>undefined;
      this.contactInfo = _data['contactInfo']
        ? ContactInfoDto.fromJS(_data['contactInfo'])
        : <any>undefined;
      this.address = _data['address']
        ? AddressDto.fromJS(_data['address'])
        : <any>undefined;
      this.logoUrl = _data['logoUrl'];
      this.isActive = _data['isActive'];
      this.serviceProviderId = _data['serviceProviderId'];
      this.serviceProviderName = _data['serviceProviderName'];
    }
  }

  static fromJS(data: any): BranchDto {
    data = typeof data === 'object' ? data : {};
    let result = new BranchDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['id'] = this.id;
    data['code'] = this.code;
    data['name'] = this.name ? this.name.toJSON() : <any>undefined;
    data['contactInfo'] = this.contactInfo ? this.contactInfo.toJSON() : <any>undefined;
    data['address'] = this.address ? this.address.toJSON() : <any>undefined;
    data['logoUrl'] = this.logoUrl;
    data['isActive'] = this.isActive;
    data['serviceProviderId'] = this.serviceProviderId;
    data['serviceProviderName'] = this.serviceProviderName;
    return data;
  }
}

export interface IBranchDto {
  id?: number;
  code?: string | undefined;
  name?: LocalizedStringDto | undefined;
  contactInfo?: ContactInfoDto | undefined;
  address?: AddressDto | undefined;
  logoUrl?: string | undefined;
  isActive?: boolean;
  serviceProviderId?: number;
  serviceProviderName?: string | undefined;
}

export class AddressDto implements IAddressDto {
  districtId?: number;
  street?: LocalizedStringDto | undefined;
  longitude?: number;
  latitude?: number;

  constructor(data?: IAddressDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.districtId = _data['districtId'];
      this.street = _data['street']
        ? LocalizedStringDto.fromJS(_data['street'])
        : <any>undefined;
      this.longitude = _data['longitude'];
      this.latitude = _data['latitude'];
    }
  }

  static fromJS(data: any): AddressDto {
    data = typeof data === 'object' ? data : {};
    let result = new AddressDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['districtId'] = this.districtId;
    data['street'] = this.street ? this.street.toJSON() : <any>undefined;
    data['longitude'] = this.longitude;
    data['latitude'] = this.latitude;
    return data;
  }
}

export interface IAddressDto {
  districtId?: number;
  street?: LocalizedStringDto | undefined;
  longitude?: number;
  latitude?: number;
}

export class BranchesPutCounterDataCommand implements IBranchesPutCounterDataCommand {
  branchId?: number;
  firstMessage?: LocalizedStringDto | undefined;
  lastMessage?: LocalizedStringDto | undefined;
  skipNumber?: number | undefined;

  constructor(data?: IBranchesPutCounterDataCommand) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.branchId = _data['branchId'];
      this.firstMessage = _data['firstMessage']
        ? LocalizedStringDto.fromJS(_data['firstMessage'])
        : <any>undefined;
      this.lastMessage = _data['lastMessage']
        ? LocalizedStringDto.fromJS(_data['lastMessage'])
        : <any>undefined;
      this.skipNumber = _data['skipNumber'];
    }
  }

  static fromJS(data: any): BranchesPutCounterDataCommand {
    data = typeof data === 'object' ? data : {};
    let result = new BranchesPutCounterDataCommand();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['branchId'] = this.branchId;
    data['firstMessage'] = this.firstMessage
      ? this.firstMessage.toJSON()
      : <any>undefined;
    data['lastMessage'] = this.lastMessage ? this.lastMessage.toJSON() : <any>undefined;
    data['skipNumber'] = this.skipNumber;
    return data;
  }
}

export interface IBranchesPutCounterDataCommand {
  branchId?: number;
  firstMessage?: LocalizedStringDto | undefined;
  lastMessage?: LocalizedStringDto | undefined;
  skipNumber?: number | undefined;
}

export class PaginatedListOfCategoryDto implements IPaginatedListOfCategoryDto {
  pageInfo?: PageInfo | undefined;
  items?: CategoryDto[] | undefined;

  constructor(data?: IPaginatedListOfCategoryDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.pageInfo = _data['pageInfo']
        ? PageInfo.fromJS(_data['pageInfo'])
        : <any>undefined;
      if (Array.isArray(_data['items'])) {
        this.items = [] as any;
        for (let item of _data['items']) this.items!.push(CategoryDto.fromJS(item));
      }
    }
  }

  static fromJS(data: any): PaginatedListOfCategoryDto {
    data = typeof data === 'object' ? data : {};
    let result = new PaginatedListOfCategoryDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['pageInfo'] = this.pageInfo ? this.pageInfo.toJSON() : <any>undefined;
    if (Array.isArray(this.items)) {
      data['items'] = [];
      for (let item of this.items) data['items'].push(item.toJSON());
    }
    return data;
  }
}

export interface IPaginatedListOfCategoryDto {
  pageInfo?: PageInfo | undefined;
  items?: CategoryDto[] | undefined;
}

export class CategoryDto implements ICategoryDto {
  id?: number;
  name?: LocalizedStringDto | undefined;
  numberOfServiceProviders?: number;

  constructor(data?: ICategoryDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data['id'];
      this.name = _data['name']
        ? LocalizedStringDto.fromJS(_data['name'])
        : <any>undefined;
      this.numberOfServiceProviders = _data['numberOfServiceProviders'];
    }
  }

  static fromJS(data: any): CategoryDto {
    data = typeof data === 'object' ? data : {};
    let result = new CategoryDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['id'] = this.id;
    data['name'] = this.name ? this.name.toJSON() : <any>undefined;
    data['numberOfServiceProviders'] = this.numberOfServiceProviders;
    return data;
  }
}

export interface ICategoryDto {
  id?: number;
  name?: LocalizedStringDto | undefined;
  numberOfServiceProviders?: number;
}

export class CategoryVm implements ICategoryVm {
  id?: number;
  name?: string | undefined;

  constructor(data?: ICategoryVm) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data['id'];
      this.name = _data['name'];
    }
  }

  static fromJS(data: any): CategoryVm {
    data = typeof data === 'object' ? data : {};
    let result = new CategoryVm();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['id'] = this.id;
    data['name'] = this.name;
    return data;
  }
}

export interface ICategoryVm {
  id?: number;
  name?: string | undefined;
}

export class CategoriesPostPutCommon implements ICategoriesPostPutCommon {
  name?: LocalizedStringDto | undefined;

  constructor(data?: ICategoriesPostPutCommon) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.name = _data['name']
        ? LocalizedStringDto.fromJS(_data['name'])
        : <any>undefined;
    }
  }

  static fromJS(data: any): CategoriesPostPutCommon {
    data = typeof data === 'object' ? data : {};
    let result = new CategoriesPostPutCommon();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['name'] = this.name ? this.name.toJSON() : <any>undefined;
    return data;
  }
}

export interface ICategoriesPostPutCommon {
  name?: LocalizedStringDto | undefined;
}

export class CategoriesPostCommand extends CategoriesPostPutCommon
  implements ICategoriesPostCommand {
  constructor(data?: ICategoriesPostCommand) {
    super(data);
  }

  init(_data?: any) {
    super.init(_data);
  }

  static fromJS(data: any): CategoriesPostCommand {
    data = typeof data === 'object' ? data : {};
    let result = new CategoriesPostCommand();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    super.toJSON(data);
    return data;
  }
}

export interface ICategoriesPostCommand extends ICategoriesPostPutCommon {}

export class CategoriesPutCommand extends CategoriesPostPutCommon
  implements ICategoriesPutCommand {
  id?: number;

  constructor(data?: ICategoriesPutCommand) {
    super(data);
  }

  init(_data?: any) {
    super.init(_data);
    if (_data) {
      this.id = _data['id'];
    }
  }

  static fromJS(data: any): CategoriesPutCommand {
    data = typeof data === 'object' ? data : {};
    let result = new CategoriesPutCommand();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['id'] = this.id;
    super.toJSON(data);
    return data;
  }
}

export interface ICategoriesPutCommand extends ICategoriesPostPutCommon {
  id?: number;
}

export class ConfigDto implements IConfigDto {
  walletGift?: number | undefined;

  constructor(data?: IConfigDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.walletGift = _data['walletGift'];
    }
  }

  static fromJS(data: any): ConfigDto {
    data = typeof data === 'object' ? data : {};
    let result = new ConfigDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['walletGift'] = this.walletGift;
    return data;
  }
}

export interface IConfigDto {
  walletGift?: number | undefined;
}

export class ConfigsPutCommand implements IConfigsPutCommand {
  walletGift?: number | undefined;

  constructor(data?: IConfigsPutCommand) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.walletGift = _data['walletGift'];
    }
  }

  static fromJS(data: any): ConfigsPutCommand {
    data = typeof data === 'object' ? data : {};
    let result = new ConfigsPutCommand();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['walletGift'] = this.walletGift;
    return data;
  }
}

export interface IConfigsPutCommand {
  walletGift?: number | undefined;
}

export class ContentVm implements IContentVm {
  value?: string | undefined;

  constructor(data?: IContentVm) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.value = _data['value'];
    }
  }

  static fromJS(data: any): ContentVm {
    data = typeof data === 'object' ? data : {};
    let result = new ContentVm();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['value'] = this.value;
    return data;
  }
}

export interface IContentVm {
  value?: string | undefined;
}

/** 0 = TermsAndConditions 1 = PrivacyPolicy */
export enum ContentType {
  TermsAndConditions = 0,
  PrivacyPolicy = 1,
}

export class ContentsPutCommand implements IContentsPutCommand {
  value?: string | undefined;
  lang?: Language;
  type?: ContentType;

  constructor(data?: IContentsPutCommand) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.value = _data['value'];
      this.lang = _data['lang'];
      this.type = _data['type'];
    }
  }

  static fromJS(data: any): ContentsPutCommand {
    data = typeof data === 'object' ? data : {};
    let result = new ContentsPutCommand();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['value'] = this.value;
    data['lang'] = this.lang;
    data['type'] = this.type;
    return data;
  }
}

export interface IContentsPutCommand {
  value?: string | undefined;
  lang?: Language;
  type?: ContentType;
}

export class TodayStatusVm implements ITodayStatusVm {
  waitings?: TicketControlsVm[] | undefined;
  finished?: TicketControlsVm[] | undefined;
  reservations?: ReservationControlsVm[] | undefined;
  noShowReservations?: ReservationControlsVm[] | undefined;
  walkIns?: TicketControlsVm[] | undefined;

  constructor(data?: ITodayStatusVm) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      if (Array.isArray(_data['waitings'])) {
        this.waitings = [] as any;
        for (let item of _data['waitings'])
          this.waitings!.push(TicketControlsVm.fromJS(item));
      }
      if (Array.isArray(_data['finished'])) {
        this.finished = [] as any;
        for (let item of _data['finished'])
          this.finished!.push(TicketControlsVm.fromJS(item));
      }
      if (Array.isArray(_data['reservations'])) {
        this.reservations = [] as any;
        for (let item of _data['reservations'])
          this.reservations!.push(ReservationControlsVm.fromJS(item));
      }
      if (Array.isArray(_data['noShowReservations'])) {
        this.noShowReservations = [] as any;
        for (let item of _data['noShowReservations'])
          this.noShowReservations!.push(ReservationControlsVm.fromJS(item));
      }
      if (Array.isArray(_data['walkIns'])) {
        this.walkIns = [] as any;
        for (let item of _data['walkIns'])
          this.walkIns!.push(TicketControlsVm.fromJS(item));
      }
    }
  }

  static fromJS(data: any): TodayStatusVm {
    data = typeof data === 'object' ? data : {};
    let result = new TodayStatusVm();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    if (Array.isArray(this.waitings)) {
      data['waitings'] = [];
      for (let item of this.waitings) data['waitings'].push(item.toJSON());
    }
    if (Array.isArray(this.finished)) {
      data['finished'] = [];
      for (let item of this.finished) data['finished'].push(item.toJSON());
    }
    if (Array.isArray(this.reservations)) {
      data['reservations'] = [];
      for (let item of this.reservations) data['reservations'].push(item.toJSON());
    }
    if (Array.isArray(this.noShowReservations)) {
      data['noShowReservations'] = [];
      for (let item of this.noShowReservations)
        data['noShowReservations'].push(item.toJSON());
    }
    if (Array.isArray(this.walkIns)) {
      data['walkIns'] = [];
      for (let item of this.walkIns) data['walkIns'].push(item.toJSON());
    }
    return data;
  }
}

export interface ITodayStatusVm {
  waitings?: TicketControlsVm[] | undefined;
  finished?: TicketControlsVm[] | undefined;
  reservations?: ReservationControlsVm[] | undefined;
  noShowReservations?: ReservationControlsVm[] | undefined;
  walkIns?: TicketControlsVm[] | undefined;
}

export class TicketControlsVm implements ITicketControlsVm {
  id?: number;
  code?: string | undefined;
  ticketNumber?: string | undefined;
  customer?: CustomerVm | undefined;

  constructor(data?: ITicketControlsVm) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data['id'];
      this.code = _data['code'];
      this.ticketNumber = _data['ticketNumber'];
      this.customer = _data['customer']
        ? CustomerVm.fromJS(_data['customer'])
        : <any>undefined;
    }
  }

  static fromJS(data: any): TicketControlsVm {
    data = typeof data === 'object' ? data : {};
    let result = new TicketControlsVm();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['id'] = this.id;
    data['code'] = this.code;
    data['ticketNumber'] = this.ticketNumber;
    data['customer'] = this.customer ? this.customer.toJSON() : <any>undefined;
    return data;
  }
}

export interface ITicketControlsVm {
  id?: number;
  code?: string | undefined;
  ticketNumber?: string | undefined;
  customer?: CustomerVm | undefined;
}

export class CustomerVm implements ICustomerVm {
  id?: number;
  name?: string | undefined;
  phoneNumber?: string | undefined;
  comments?: CommentVm[] | undefined;

  constructor(data?: ICustomerVm) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data['id'];
      this.name = _data['name'];
      this.phoneNumber = _data['phoneNumber'];
      if (Array.isArray(_data['comments'])) {
        this.comments = [] as any;
        for (let item of _data['comments']) this.comments!.push(CommentVm.fromJS(item));
      }
    }
  }

  static fromJS(data: any): CustomerVm {
    data = typeof data === 'object' ? data : {};
    let result = new CustomerVm();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['id'] = this.id;
    data['name'] = this.name;
    data['phoneNumber'] = this.phoneNumber;
    if (Array.isArray(this.comments)) {
      data['comments'] = [];
      for (let item of this.comments) data['comments'].push(item.toJSON());
    }
    return data;
  }
}

export interface ICustomerVm {
  id?: number;
  name?: string | undefined;
  phoneNumber?: string | undefined;
  comments?: CommentVm[] | undefined;
}

export class CommentVm implements ICommentVm {
  id?: number;
  content?: string | undefined;
  createdAt?: Date;

  constructor(data?: ICommentVm) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data['id'];
      this.content = _data['content'];
      this.createdAt = _data['createdAt']
        ? new Date(_data['createdAt'].toString())
        : <any>undefined;
    }
  }

  static fromJS(data: any): CommentVm {
    data = typeof data === 'object' ? data : {};
    let result = new CommentVm();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['id'] = this.id;
    data['content'] = this.content;
    data['createdAt'] = this.createdAt ? this.createdAt.toISOString() : <any>undefined;
    return data;
  }
}

export interface ICommentVm {
  id?: number;
  content?: string | undefined;
  createdAt?: Date;
}

export class ReservationControlsVm implements IReservationControlsVm {
  id?: number;
  code?: string | undefined;
  time?: TimeDto | undefined;
  customer?: CustomerVm | undefined;

  constructor(data?: IReservationControlsVm) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data['id'];
      this.code = _data['code'];
      this.time = _data['time'] ? TimeDto.fromJS(_data['time']) : <any>undefined;
      this.customer = _data['customer']
        ? CustomerVm.fromJS(_data['customer'])
        : <any>undefined;
    }
  }

  static fromJS(data: any): ReservationControlsVm {
    data = typeof data === 'object' ? data : {};
    let result = new ReservationControlsVm();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['id'] = this.id;
    data['code'] = this.code;
    data['time'] = this.time ? this.time.toJSON() : <any>undefined;
    data['customer'] = this.customer ? this.customer.toJSON() : <any>undefined;
    return data;
  }
}

export interface IReservationControlsVm {
  id?: number;
  code?: string | undefined;
  time?: TimeDto | undefined;
  customer?: CustomerVm | undefined;
}

export class TimeDto implements ITimeDto {
  hours?: number;
  minutes?: number;

  constructor(data?: ITimeDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.hours = _data['hours'];
      this.minutes = _data['minutes'];
    }
  }

  static fromJS(data: any): TimeDto {
    data = typeof data === 'object' ? data : {};
    let result = new TimeDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['hours'] = this.hours;
    data['minutes'] = this.minutes;
    return data;
  }
}

export interface ITimeDto {
  hours?: number;
  minutes?: number;
}

export class WeekStatusVm implements IWeekStatusVm {
  days?: DaySummaryVm[] | undefined;

  constructor(data?: IWeekStatusVm) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      if (Array.isArray(_data['days'])) {
        this.days = [] as any;
        for (let item of _data['days']) this.days!.push(DaySummaryVm.fromJS(item));
      }
    }
  }

  static fromJS(data: any): WeekStatusVm {
    data = typeof data === 'object' ? data : {};
    let result = new WeekStatusVm();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    if (Array.isArray(this.days)) {
      data['days'] = [];
      for (let item of this.days) data['days'].push(item.toJSON());
    }
    return data;
  }
}

export interface IWeekStatusVm {
  days?: DaySummaryVm[] | undefined;
}

export class DaySummaryVm implements IDaySummaryVm {
  date?: Date;
  count?: number;
  reservations?: ReservationControlsVm[] | undefined;

  constructor(data?: IDaySummaryVm) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.date = _data['date'] ? new Date(_data['date'].toString()) : <any>undefined;
      this.count = _data['count'];
      if (Array.isArray(_data['reservations'])) {
        this.reservations = [] as any;
        for (let item of _data['reservations'])
          this.reservations!.push(ReservationControlsVm.fromJS(item));
      }
    }
  }

  static fromJS(data: any): DaySummaryVm {
    data = typeof data === 'object' ? data : {};
    let result = new DaySummaryVm();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['date'] = this.date ? this.date.toISOString() : <any>undefined;
    data['count'] = this.count;
    if (Array.isArray(this.reservations)) {
      data['reservations'] = [];
      for (let item of this.reservations) data['reservations'].push(item.toJSON());
    }
    return data;
  }
}

export interface IDaySummaryVm {
  date?: Date;
  count?: number;
  reservations?: ReservationControlsVm[] | undefined;
}

export class DayStatusVm implements IDayStatusVm {
  allCustomers?: TicketControlsVm[] | undefined;
  walkIns?: TicketControlsVm[] | undefined;
  reservations?: ReservationControlsVm[] | undefined;
  noShowReservations?: ReservationControlsVm[] | undefined;

  constructor(data?: IDayStatusVm) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      if (Array.isArray(_data['allCustomers'])) {
        this.allCustomers = [] as any;
        for (let item of _data['allCustomers'])
          this.allCustomers!.push(TicketControlsVm.fromJS(item));
      }
      if (Array.isArray(_data['walkIns'])) {
        this.walkIns = [] as any;
        for (let item of _data['walkIns'])
          this.walkIns!.push(TicketControlsVm.fromJS(item));
      }
      if (Array.isArray(_data['reservations'])) {
        this.reservations = [] as any;
        for (let item of _data['reservations'])
          this.reservations!.push(ReservationControlsVm.fromJS(item));
      }
      if (Array.isArray(_data['noShowReservations'])) {
        this.noShowReservations = [] as any;
        for (let item of _data['noShowReservations'])
          this.noShowReservations!.push(ReservationControlsVm.fromJS(item));
      }
    }
  }

  static fromJS(data: any): DayStatusVm {
    data = typeof data === 'object' ? data : {};
    let result = new DayStatusVm();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    if (Array.isArray(this.allCustomers)) {
      data['allCustomers'] = [];
      for (let item of this.allCustomers) data['allCustomers'].push(item.toJSON());
    }
    if (Array.isArray(this.walkIns)) {
      data['walkIns'] = [];
      for (let item of this.walkIns) data['walkIns'].push(item.toJSON());
    }
    if (Array.isArray(this.reservations)) {
      data['reservations'] = [];
      for (let item of this.reservations) data['reservations'].push(item.toJSON());
    }
    if (Array.isArray(this.noShowReservations)) {
      data['noShowReservations'] = [];
      for (let item of this.noShowReservations)
        data['noShowReservations'].push(item.toJSON());
    }
    return data;
  }
}

export interface IDayStatusVm {
  allCustomers?: TicketControlsVm[] | undefined;
  walkIns?: TicketControlsVm[] | undefined;
  reservations?: ReservationControlsVm[] | undefined;
  noShowReservations?: ReservationControlsVm[] | undefined;
}

export class MonthStatusVm implements IMonthStatusVm {
  totalCustomers?: number;
  walkInCount?: number;
  totalReservations?: number;
  noShowCount?: number;

  constructor(data?: IMonthStatusVm) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.totalCustomers = _data['totalCustomers'];
      this.walkInCount = _data['walkInCount'];
      this.totalReservations = _data['totalReservations'];
      this.noShowCount = _data['noShowCount'];
    }
  }

  static fromJS(data: any): MonthStatusVm {
    data = typeof data === 'object' ? data : {};
    let result = new MonthStatusVm();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['totalCustomers'] = this.totalCustomers;
    data['walkInCount'] = this.walkInCount;
    data['totalReservations'] = this.totalReservations;
    data['noShowCount'] = this.noShowCount;
    return data;
  }
}

export interface IMonthStatusVm {
  totalCustomers?: number;
  walkInCount?: number;
  totalReservations?: number;
  noShowCount?: number;
}

export class ControlsProfileVm implements IControlsProfileVm {
  contactInfo?: ContactInfoDto | undefined;
  address?: AddressDto | undefined;
  startAt?: Date;
  averageServingTime?: number;
  numberOfCustomers?: number;
  accountManager?: AccountManagerDto | undefined;

  constructor(data?: IControlsProfileVm) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.contactInfo = _data['contactInfo']
        ? ContactInfoDto.fromJS(_data['contactInfo'])
        : <any>undefined;
      this.address = _data['address']
        ? AddressDto.fromJS(_data['address'])
        : <any>undefined;
      this.startAt = _data['startAt']
        ? new Date(_data['startAt'].toString())
        : <any>undefined;
      this.averageServingTime = _data['averageServingTime'];
      this.numberOfCustomers = _data['numberOfCustomers'];
      this.accountManager = _data['accountManager']
        ? AccountManagerDto.fromJS(_data['accountManager'])
        : <any>undefined;
    }
  }

  static fromJS(data: any): ControlsProfileVm {
    data = typeof data === 'object' ? data : {};
    let result = new ControlsProfileVm();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['contactInfo'] = this.contactInfo ? this.contactInfo.toJSON() : <any>undefined;
    data['address'] = this.address ? this.address.toJSON() : <any>undefined;
    data['startAt'] = this.startAt ? this.startAt.toISOString() : <any>undefined;
    data['averageServingTime'] = this.averageServingTime;
    data['numberOfCustomers'] = this.numberOfCustomers;
    data['accountManager'] = this.accountManager
      ? this.accountManager.toJSON()
      : <any>undefined;
    return data;
  }
}

export interface IControlsProfileVm {
  contactInfo?: ContactInfoDto | undefined;
  address?: AddressDto | undefined;
  startAt?: Date;
  averageServingTime?: number;
  numberOfCustomers?: number;
  accountManager?: AccountManagerDto | undefined;
}

export class ControlsUpdateWorkingDayCommand implements IControlsUpdateWorkingDayCommand {
  workingDayId?: number;
  startTime?: TimeDto | undefined;
  endTime?: TimeDto | undefined;
  offDay?: boolean;

  constructor(data?: IControlsUpdateWorkingDayCommand) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.workingDayId = _data['workingDayId'];
      this.startTime = _data['startTime']
        ? TimeDto.fromJS(_data['startTime'])
        : <any>undefined;
      this.endTime = _data['endTime'] ? TimeDto.fromJS(_data['endTime']) : <any>undefined;
      this.offDay = _data['offDay'];
    }
  }

  static fromJS(data: any): ControlsUpdateWorkingDayCommand {
    data = typeof data === 'object' ? data : {};
    let result = new ControlsUpdateWorkingDayCommand();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['workingDayId'] = this.workingDayId;
    data['startTime'] = this.startTime ? this.startTime.toJSON() : <any>undefined;
    data['endTime'] = this.endTime ? this.endTime.toJSON() : <any>undefined;
    data['offDay'] = this.offDay;
    return data;
  }
}

export interface IControlsUpdateWorkingDayCommand {
  workingDayId?: number;
  startTime?: TimeDto | undefined;
  endTime?: TimeDto | undefined;
  offDay?: boolean;
}

export class ControlsPostCommentCommand implements IControlsPostCommentCommand {
  customerId?: number;
  content?: string | undefined;

  constructor(data?: IControlsPostCommentCommand) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.customerId = _data['customerId'];
      this.content = _data['content'];
    }
  }

  static fromJS(data: any): ControlsPostCommentCommand {
    data = typeof data === 'object' ? data : {};
    let result = new ControlsPostCommentCommand();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['customerId'] = this.customerId;
    data['content'] = this.content;
    return data;
  }
}

export interface IControlsPostCommentCommand {
  customerId?: number;
  content?: string | undefined;
}

export class CounterVm implements ICounterVm {
  currentServedTicket?: string | undefined;
  lastIssuedTicket?: string | undefined;
  totalCustomersInQueue?: number;

  constructor(data?: ICounterVm) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.currentServedTicket = _data['currentServedTicket'];
      this.lastIssuedTicket = _data['lastIssuedTicket'];
      this.totalCustomersInQueue = _data['totalCustomersInQueue'];
    }
  }

  static fromJS(data: any): CounterVm {
    data = typeof data === 'object' ? data : {};
    let result = new CounterVm();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['currentServedTicket'] = this.currentServedTicket;
    data['lastIssuedTicket'] = this.lastIssuedTicket;
    data['totalCustomersInQueue'] = this.totalCustomersInQueue;
    return data;
  }
}

export interface ICounterVm {
  currentServedTicket?: string | undefined;
  lastIssuedTicket?: string | undefined;
  totalCustomersInQueue?: number;
}

export class CustomerVm2 implements ICustomerVm2 {
  ticketNumber?: string | undefined;
  name?: string | undefined;
  phoneNumber?: string | undefined;
  values?: CustomerDataValueVm[] | undefined;

  constructor(data?: ICustomerVm2) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.ticketNumber = _data['ticketNumber'];
      this.name = _data['name'];
      this.phoneNumber = _data['phoneNumber'];
      if (Array.isArray(_data['values'])) {
        this.values = [] as any;
        for (let item of _data['values'])
          this.values!.push(CustomerDataValueVm.fromJS(item));
      }
    }
  }

  static fromJS(data: any): CustomerVm2 {
    data = typeof data === 'object' ? data : {};
    let result = new CustomerVm2();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['ticketNumber'] = this.ticketNumber;
    data['name'] = this.name;
    data['phoneNumber'] = this.phoneNumber;
    if (Array.isArray(this.values)) {
      data['values'] = [];
      for (let item of this.values) data['values'].push(item.toJSON());
    }
    return data;
  }
}

export interface ICustomerVm2 {
  ticketNumber?: string | undefined;
  name?: string | undefined;
  phoneNumber?: string | undefined;
  values?: CustomerDataValueVm[] | undefined;
}

export class CustomerDataValueVm implements ICustomerDataValueVm {
  name?: string | undefined;
  value?: string | undefined;

  constructor(data?: ICustomerDataValueVm) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.name = _data['name'];
      this.value = _data['value'];
    }
  }

  static fromJS(data: any): CustomerDataValueVm {
    data = typeof data === 'object' ? data : {};
    let result = new CustomerDataValueVm();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['name'] = this.name;
    data['value'] = this.value;
    return data;
  }
}

export interface ICustomerDataValueVm {
  name?: string | undefined;
  value?: string | undefined;
}

export class CounterWorkingDayVm implements ICounterWorkingDayVm {
  date?: Date;
  reservedSlots?: number;
  availableSlots?: number;

  constructor(data?: ICounterWorkingDayVm) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.date = _data['date'] ? new Date(_data['date'].toString()) : <any>undefined;
      this.reservedSlots = _data['reservedSlots'];
      this.availableSlots = _data['availableSlots'];
    }
  }

  static fromJS(data: any): CounterWorkingDayVm {
    data = typeof data === 'object' ? data : {};
    let result = new CounterWorkingDayVm();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['date'] = this.date ? this.date.toISOString() : <any>undefined;
    data['reservedSlots'] = this.reservedSlots;
    data['availableSlots'] = this.availableSlots;
    return data;
  }
}

export interface ICounterWorkingDayVm {
  date?: Date;
  reservedSlots?: number;
  availableSlots?: number;
}

export class CounterReservationVm implements ICounterReservationVm {
  timeSlot?: string | undefined;
  customerName?: string | undefined;
  customerPhoneNumber?: string | undefined;
  code?: string | undefined;

  constructor(data?: ICounterReservationVm) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.timeSlot = _data['timeSlot'];
      this.customerName = _data['customerName'];
      this.customerPhoneNumber = _data['customerPhoneNumber'];
      this.code = _data['code'];
    }
  }

  static fromJS(data: any): CounterReservationVm {
    data = typeof data === 'object' ? data : {};
    let result = new CounterReservationVm();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['timeSlot'] = this.timeSlot;
    data['customerName'] = this.customerName;
    data['customerPhoneNumber'] = this.customerPhoneNumber;
    data['code'] = this.code;
    return data;
  }
}

export interface ICounterReservationVm {
  timeSlot?: string | undefined;
  customerName?: string | undefined;
  customerPhoneNumber?: string | undefined;
  code?: string | undefined;
}

export class IssueTicketVm implements IIssueTicketVm {
  lastIssuedTicket?: string | undefined;
  totalCustomersInQueue?: number;

  constructor(data?: IIssueTicketVm) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.lastIssuedTicket = _data['lastIssuedTicket'];
      this.totalCustomersInQueue = _data['totalCustomersInQueue'];
    }
  }

  static fromJS(data: any): IssueTicketVm {
    data = typeof data === 'object' ? data : {};
    let result = new IssueTicketVm();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['lastIssuedTicket'] = this.lastIssuedTicket;
    data['totalCustomersInQueue'] = this.totalCustomersInQueue;
    return data;
  }
}

export interface IIssueTicketVm {
  lastIssuedTicket?: string | undefined;
  totalCustomersInQueue?: number;
}

export class CountersIssueTicketCommand implements ICountersIssueTicketCommand {
  serviceId?: number | undefined;
  customerName?: string | undefined;
  customerPhoneNumber?: string | undefined;
  reservationCode?: string | undefined;

  constructor(data?: ICountersIssueTicketCommand) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.serviceId = _data['serviceId'];
      this.customerName = _data['customerName'];
      this.customerPhoneNumber = _data['customerPhoneNumber'];
      this.reservationCode = _data['reservationCode'];
    }
  }

  static fromJS(data: any): CountersIssueTicketCommand {
    data = typeof data === 'object' ? data : {};
    let result = new CountersIssueTicketCommand();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['serviceId'] = this.serviceId;
    data['customerName'] = this.customerName;
    data['customerPhoneNumber'] = this.customerPhoneNumber;
    data['reservationCode'] = this.reservationCode;
    return data;
  }
}

export interface ICountersIssueTicketCommand {
  serviceId?: number | undefined;
  customerName?: string | undefined;
  customerPhoneNumber?: string | undefined;
  reservationCode?: string | undefined;
}

export class CalledTicketDetailsVm implements ICalledTicketDetailsVm {
  ticketNumber?: string | undefined;
  phoneNumber?: string | undefined;

  constructor(data?: ICalledTicketDetailsVm) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.ticketNumber = _data['ticketNumber'];
      this.phoneNumber = _data['phoneNumber'];
    }
  }

  static fromJS(data: any): CalledTicketDetailsVm {
    data = typeof data === 'object' ? data : {};
    let result = new CalledTicketDetailsVm();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['ticketNumber'] = this.ticketNumber;
    data['phoneNumber'] = this.phoneNumber;
    return data;
  }
}

export interface ICalledTicketDetailsVm {
  ticketNumber?: string | undefined;
  phoneNumber?: string | undefined;
}

export class CountersCallTicketCommand implements ICountersCallTicketCommand {
  serviceId?: number | undefined;
  pin?: string | undefined;

  constructor(data?: ICountersCallTicketCommand) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.serviceId = _data['serviceId'];
      this.pin = _data['pin'];
    }
  }

  static fromJS(data: any): CountersCallTicketCommand {
    data = typeof data === 'object' ? data : {};
    let result = new CountersCallTicketCommand();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['serviceId'] = this.serviceId;
    data['pin'] = this.pin;
    return data;
  }
}

export interface ICountersCallTicketCommand {
  serviceId?: number | undefined;
  pin?: string | undefined;
}

export class CountersResetCommand implements ICountersResetCommand {
  serviceId?: number | undefined;
  pin?: string | undefined;

  constructor(data?: ICountersResetCommand) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.serviceId = _data['serviceId'];
      this.pin = _data['pin'];
    }
  }

  static fromJS(data: any): CountersResetCommand {
    data = typeof data === 'object' ? data : {};
    let result = new CountersResetCommand();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['serviceId'] = this.serviceId;
    data['pin'] = this.pin;
    return data;
  }
}

export interface ICountersResetCommand {
  serviceId?: number | undefined;
  pin?: string | undefined;
}

export class PaginatedListOfDistrictDto implements IPaginatedListOfDistrictDto {
  pageInfo?: PageInfo | undefined;
  items?: DistrictDto[] | undefined;

  constructor(data?: IPaginatedListOfDistrictDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.pageInfo = _data['pageInfo']
        ? PageInfo.fromJS(_data['pageInfo'])
        : <any>undefined;
      if (Array.isArray(_data['items'])) {
        this.items = [] as any;
        for (let item of _data['items']) this.items!.push(DistrictDto.fromJS(item));
      }
    }
  }

  static fromJS(data: any): PaginatedListOfDistrictDto {
    data = typeof data === 'object' ? data : {};
    let result = new PaginatedListOfDistrictDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['pageInfo'] = this.pageInfo ? this.pageInfo.toJSON() : <any>undefined;
    if (Array.isArray(this.items)) {
      data['items'] = [];
      for (let item of this.items) data['items'].push(item.toJSON());
    }
    return data;
  }
}

export interface IPaginatedListOfDistrictDto {
  pageInfo?: PageInfo | undefined;
  items?: DistrictDto[] | undefined;
}

export class DistrictDto implements IDistrictDto {
  id?: number;
  name?: LocalizedStringDto | undefined;
  governorateId?: number;
  governorateName?: string | undefined;

  constructor(data?: IDistrictDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data['id'];
      this.name = _data['name']
        ? LocalizedStringDto.fromJS(_data['name'])
        : <any>undefined;
      this.governorateId = _data['governorateId'];
      this.governorateName = _data['governorateName'];
    }
  }

  static fromJS(data: any): DistrictDto {
    data = typeof data === 'object' ? data : {};
    let result = new DistrictDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['id'] = this.id;
    data['name'] = this.name ? this.name.toJSON() : <any>undefined;
    data['governorateId'] = this.governorateId;
    data['governorateName'] = this.governorateName;
    return data;
  }
}

export interface IDistrictDto {
  id?: number;
  name?: LocalizedStringDto | undefined;
  governorateId?: number;
  governorateName?: string | undefined;
}

export class DistrictsPostPutCommon implements IDistrictsPostPutCommon {
  name?: LocalizedStringDto | undefined;
  governorateId?: number;

  constructor(data?: IDistrictsPostPutCommon) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.name = _data['name']
        ? LocalizedStringDto.fromJS(_data['name'])
        : <any>undefined;
      this.governorateId = _data['governorateId'];
    }
  }

  static fromJS(data: any): DistrictsPostPutCommon {
    data = typeof data === 'object' ? data : {};
    let result = new DistrictsPostPutCommon();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['name'] = this.name ? this.name.toJSON() : <any>undefined;
    data['governorateId'] = this.governorateId;
    return data;
  }
}

export interface IDistrictsPostPutCommon {
  name?: LocalizedStringDto | undefined;
  governorateId?: number;
}

export class DistrictPostCommand extends DistrictsPostPutCommon
  implements IDistrictPostCommand {
  constructor(data?: IDistrictPostCommand) {
    super(data);
  }

  init(_data?: any) {
    super.init(_data);
  }

  static fromJS(data: any): DistrictPostCommand {
    data = typeof data === 'object' ? data : {};
    let result = new DistrictPostCommand();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    super.toJSON(data);
    return data;
  }
}

export interface IDistrictPostCommand extends IDistrictsPostPutCommon {}

export class DistrictsPutCommand extends DistrictsPostPutCommon
  implements IDistrictsPutCommand {
  id?: number;

  constructor(data?: IDistrictsPutCommand) {
    super(data);
  }

  init(_data?: any) {
    super.init(_data);
    if (_data) {
      this.id = _data['id'];
    }
  }

  static fromJS(data: any): DistrictsPutCommand {
    data = typeof data === 'object' ? data : {};
    let result = new DistrictsPutCommand();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['id'] = this.id;
    super.toJSON(data);
    return data;
  }
}

export interface IDistrictsPutCommand extends IDistrictsPostPutCommon {
  id?: number;
}

export class PaginatedListOfGovernorateDto implements IPaginatedListOfGovernorateDto {
  pageInfo?: PageInfo | undefined;
  items?: GovernorateDto[] | undefined;

  constructor(data?: IPaginatedListOfGovernorateDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.pageInfo = _data['pageInfo']
        ? PageInfo.fromJS(_data['pageInfo'])
        : <any>undefined;
      if (Array.isArray(_data['items'])) {
        this.items = [] as any;
        for (let item of _data['items']) this.items!.push(GovernorateDto.fromJS(item));
      }
    }
  }

  static fromJS(data: any): PaginatedListOfGovernorateDto {
    data = typeof data === 'object' ? data : {};
    let result = new PaginatedListOfGovernorateDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['pageInfo'] = this.pageInfo ? this.pageInfo.toJSON() : <any>undefined;
    if (Array.isArray(this.items)) {
      data['items'] = [];
      for (let item of this.items) data['items'].push(item.toJSON());
    }
    return data;
  }
}

export interface IPaginatedListOfGovernorateDto {
  pageInfo?: PageInfo | undefined;
  items?: GovernorateDto[] | undefined;
}

export class GovernorateDto implements IGovernorateDto {
  id?: number;
  name?: LocalizedStringDto | undefined;
  numberOfDistricts?: number;

  constructor(data?: IGovernorateDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data['id'];
      this.name = _data['name']
        ? LocalizedStringDto.fromJS(_data['name'])
        : <any>undefined;
      this.numberOfDistricts = _data['numberOfDistricts'];
    }
  }

  static fromJS(data: any): GovernorateDto {
    data = typeof data === 'object' ? data : {};
    let result = new GovernorateDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['id'] = this.id;
    data['name'] = this.name ? this.name.toJSON() : <any>undefined;
    data['numberOfDistricts'] = this.numberOfDistricts;
    return data;
  }
}

export interface IGovernorateDto {
  id?: number;
  name?: LocalizedStringDto | undefined;
  numberOfDistricts?: number;
}

export class GovernorateDashboardVm implements IGovernorateDashboardVm {
  id?: number;
  name?: string | undefined;
  districts?: DistrictDashboardVm[] | undefined;

  constructor(data?: IGovernorateDashboardVm) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data['id'];
      this.name = _data['name'];
      if (Array.isArray(_data['districts'])) {
        this.districts = [] as any;
        for (let item of _data['districts'])
          this.districts!.push(DistrictDashboardVm.fromJS(item));
      }
    }
  }

  static fromJS(data: any): GovernorateDashboardVm {
    data = typeof data === 'object' ? data : {};
    let result = new GovernorateDashboardVm();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['id'] = this.id;
    data['name'] = this.name;
    if (Array.isArray(this.districts)) {
      data['districts'] = [];
      for (let item of this.districts) data['districts'].push(item.toJSON());
    }
    return data;
  }
}

export interface IGovernorateDashboardVm {
  id?: number;
  name?: string | undefined;
  districts?: DistrictDashboardVm[] | undefined;
}

export class DistrictDashboardVm implements IDistrictDashboardVm {
  id?: number;
  name?: string | undefined;

  constructor(data?: IDistrictDashboardVm) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data['id'];
      this.name = _data['name'];
    }
  }

  static fromJS(data: any): DistrictDashboardVm {
    data = typeof data === 'object' ? data : {};
    let result = new DistrictDashboardVm();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['id'] = this.id;
    data['name'] = this.name;
    return data;
  }
}

export interface IDistrictDashboardVm {
  id?: number;
  name?: string | undefined;
}

export class GovernorateShortVm implements IGovernorateShortVm {
  id?: number;
  name?: string | undefined;

  constructor(data?: IGovernorateShortVm) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data['id'];
      this.name = _data['name'];
    }
  }

  static fromJS(data: any): GovernorateShortVm {
    data = typeof data === 'object' ? data : {};
    let result = new GovernorateShortVm();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['id'] = this.id;
    data['name'] = this.name;
    return data;
  }
}

export interface IGovernorateShortVm {
  id?: number;
  name?: string | undefined;
}

export class GovernoratesPostPutCommon implements IGovernoratesPostPutCommon {
  name?: LocalizedStringDto | undefined;

  constructor(data?: IGovernoratesPostPutCommon) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.name = _data['name']
        ? LocalizedStringDto.fromJS(_data['name'])
        : <any>undefined;
    }
  }

  static fromJS(data: any): GovernoratesPostPutCommon {
    data = typeof data === 'object' ? data : {};
    let result = new GovernoratesPostPutCommon();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['name'] = this.name ? this.name.toJSON() : <any>undefined;
    return data;
  }
}

export interface IGovernoratesPostPutCommon {
  name?: LocalizedStringDto | undefined;
}

export class GovernoratesPostCommand extends GovernoratesPostPutCommon
  implements IGovernoratesPostCommand {
  constructor(data?: IGovernoratesPostCommand) {
    super(data);
  }

  init(_data?: any) {
    super.init(_data);
  }

  static fromJS(data: any): GovernoratesPostCommand {
    data = typeof data === 'object' ? data : {};
    let result = new GovernoratesPostCommand();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    super.toJSON(data);
    return data;
  }
}

export interface IGovernoratesPostCommand extends IGovernoratesPostPutCommon {}

export class GovernoratesPutCommand extends GovernoratesPostPutCommon
  implements IGovernoratesPutCommand {
  id?: number;

  constructor(data?: IGovernoratesPutCommand) {
    super(data);
  }

  init(_data?: any) {
    super.init(_data);
    if (_data) {
      this.id = _data['id'];
    }
  }

  static fromJS(data: any): GovernoratesPutCommand {
    data = typeof data === 'object' ? data : {};
    let result = new GovernoratesPutCommand();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['id'] = this.id;
    super.toJSON(data);
    return data;
  }
}

export interface IGovernoratesPutCommand extends IGovernoratesPostPutCommon {
  id?: number;
}

export class OffDayDto implements IOffDayDto {
  id?: number;
  date?: Date;
  isWorking?: boolean;
  periods?: PeriodDto[] | undefined;

  constructor(data?: IOffDayDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data['id'];
      this.date = _data['date'] ? new Date(_data['date'].toString()) : <any>undefined;
      this.isWorking = _data['isWorking'];
      if (Array.isArray(_data['periods'])) {
        this.periods = [] as any;
        for (let item of _data['periods']) this.periods!.push(PeriodDto.fromJS(item));
      }
    }
  }

  static fromJS(data: any): OffDayDto {
    data = typeof data === 'object' ? data : {};
    let result = new OffDayDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['id'] = this.id;
    data['date'] = this.date ? this.date.toISOString() : <any>undefined;
    data['isWorking'] = this.isWorking;
    if (Array.isArray(this.periods)) {
      data['periods'] = [];
      for (let item of this.periods) data['periods'].push(item.toJSON());
    }
    return data;
  }
}

export interface IOffDayDto {
  id?: number;
  date?: Date;
  isWorking?: boolean;
  periods?: PeriodDto[] | undefined;
}

export class PeriodDto implements IPeriodDto {
  id?: number;
  startTime?: TimeDto | undefined;
  endTime?: TimeDto | undefined;

  constructor(data?: IPeriodDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data['id'];
      this.startTime = _data['startTime']
        ? TimeDto.fromJS(_data['startTime'])
        : <any>undefined;
      this.endTime = _data['endTime'] ? TimeDto.fromJS(_data['endTime']) : <any>undefined;
    }
  }

  static fromJS(data: any): PeriodDto {
    data = typeof data === 'object' ? data : {};
    let result = new PeriodDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['id'] = this.id;
    data['startTime'] = this.startTime ? this.startTime.toJSON() : <any>undefined;
    data['endTime'] = this.endTime ? this.endTime.toJSON() : <any>undefined;
    return data;
  }
}

export interface IPeriodDto {
  id?: number;
  startTime?: TimeDto | undefined;
  endTime?: TimeDto | undefined;
}

export class OffDaysPutCommand implements IOffDaysPutCommand {
  queueId?: number;
  offDays?: OffDayDto[] | undefined;

  constructor(data?: IOffDaysPutCommand) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.queueId = _data['queueId'];
      if (Array.isArray(_data['offDays'])) {
        this.offDays = [] as any;
        for (let item of _data['offDays']) this.offDays!.push(OffDayDto.fromJS(item));
      }
    }
  }

  static fromJS(data: any): OffDaysPutCommand {
    data = typeof data === 'object' ? data : {};
    let result = new OffDaysPutCommand();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['queueId'] = this.queueId;
    if (Array.isArray(this.offDays)) {
      data['offDays'] = [];
      for (let item of this.offDays) data['offDays'].push(item.toJSON());
    }
    return data;
  }
}

export interface IOffDaysPutCommand {
  queueId?: number;
  offDays?: OffDayDto[] | undefined;
}

export class QueueVm implements IQueueVm {
  queueId?: number;
  tickets?: PaginatedListOfTicketVm | undefined;

  constructor(data?: IQueueVm) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.queueId = _data['queueId'];
      this.tickets = _data['tickets']
        ? PaginatedListOfTicketVm.fromJS(_data['tickets'])
        : <any>undefined;
    }
  }

  static fromJS(data: any): QueueVm {
    data = typeof data === 'object' ? data : {};
    let result = new QueueVm();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['queueId'] = this.queueId;
    data['tickets'] = this.tickets ? this.tickets.toJSON() : <any>undefined;
    return data;
  }
}

export interface IQueueVm {
  queueId?: number;
  tickets?: PaginatedListOfTicketVm | undefined;
}

export class PaginatedListOfTicketVm implements IPaginatedListOfTicketVm {
  pageInfo?: PageInfo | undefined;
  items?: TicketVm[] | undefined;

  constructor(data?: IPaginatedListOfTicketVm) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.pageInfo = _data['pageInfo']
        ? PageInfo.fromJS(_data['pageInfo'])
        : <any>undefined;
      if (Array.isArray(_data['items'])) {
        this.items = [] as any;
        for (let item of _data['items']) this.items!.push(TicketVm.fromJS(item));
      }
    }
  }

  static fromJS(data: any): PaginatedListOfTicketVm {
    data = typeof data === 'object' ? data : {};
    let result = new PaginatedListOfTicketVm();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['pageInfo'] = this.pageInfo ? this.pageInfo.toJSON() : <any>undefined;
    if (Array.isArray(this.items)) {
      data['items'] = [];
      for (let item of this.items) data['items'].push(item.toJSON());
    }
    return data;
  }
}

export interface IPaginatedListOfTicketVm {
  pageInfo?: PageInfo | undefined;
  items?: TicketVm[] | undefined;
}

export class TicketVm implements ITicketVm {
  ticketNumber?: string | undefined;
  status?: TicketStatus;
  createdAt?: Date;
  calledAt?: Date | undefined;
  completedAt?: Date | undefined;

  constructor(data?: ITicketVm) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.ticketNumber = _data['ticketNumber'];
      this.status = _data['status'];
      this.createdAt = _data['createdAt']
        ? new Date(_data['createdAt'].toString())
        : <any>undefined;
      this.calledAt = _data['calledAt']
        ? new Date(_data['calledAt'].toString())
        : <any>undefined;
      this.completedAt = _data['completedAt']
        ? new Date(_data['completedAt'].toString())
        : <any>undefined;
    }
  }

  static fromJS(data: any): TicketVm {
    data = typeof data === 'object' ? data : {};
    let result = new TicketVm();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['ticketNumber'] = this.ticketNumber;
    data['status'] = this.status;
    data['createdAt'] = this.createdAt ? this.createdAt.toISOString() : <any>undefined;
    data['calledAt'] = this.calledAt ? this.calledAt.toISOString() : <any>undefined;
    data['completedAt'] = this.completedAt
      ? this.completedAt.toISOString()
      : <any>undefined;
    return data;
  }
}

export interface ITicketVm {
  ticketNumber?: string | undefined;
  status?: TicketStatus;
  createdAt?: Date;
  calledAt?: Date | undefined;
  completedAt?: Date | undefined;
}

/** 0 = Created 1 = Arrived 2 = Called 3 = Complete 4 = Cancelled 5 = Rescheduled 6 = NoShow */
export enum TicketStatus {
  Created = 0,
  Arrived = 1,
  Called = 2,
  Complete = 3,
  Cancelled = 4,
  Rescheduled = 5,
  NoShow = 6,
}

export class QueueDto implements IQueueDto {
  id?: number;
  ticketStartRange?: number | undefined;
  ticketEndRange?: number | undefined;
  numberOfCustomers?: number | undefined;
  isActive?: boolean;
  isQmeCounter?: boolean;
  isQmeApp?: boolean;
  isQmeNow?: boolean;
  averageServingTime?: number;
  holidayType?: HolidayType;

  constructor(data?: IQueueDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data['id'];
      this.ticketStartRange = _data['ticketStartRange'];
      this.ticketEndRange = _data['ticketEndRange'];
      this.numberOfCustomers = _data['numberOfCustomers'];
      this.isActive = _data['isActive'];
      this.isQmeCounter = _data['isQmeCounter'];
      this.isQmeApp = _data['isQmeApp'];
      this.isQmeNow = _data['isQmeNow'];
      this.averageServingTime = _data['averageServingTime'];
      this.holidayType = _data['holidayType'];
    }
  }

  static fromJS(data: any): QueueDto {
    data = typeof data === 'object' ? data : {};
    let result = new QueueDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['id'] = this.id;
    data['ticketStartRange'] = this.ticketStartRange;
    data['ticketEndRange'] = this.ticketEndRange;
    data['numberOfCustomers'] = this.numberOfCustomers;
    data['isActive'] = this.isActive;
    data['isQmeCounter'] = this.isQmeCounter;
    data['isQmeApp'] = this.isQmeApp;
    data['isQmeNow'] = this.isQmeNow;
    data['averageServingTime'] = this.averageServingTime;
    data['holidayType'] = this.holidayType;
    return data;
  }
}

export interface IQueueDto {
  id?: number;
  ticketStartRange?: number | undefined;
  ticketEndRange?: number | undefined;
  numberOfCustomers?: number | undefined;
  isActive?: boolean;
  isQmeCounter?: boolean;
  isQmeApp?: boolean;
  isQmeNow?: boolean;
  averageServingTime?: number;
  holidayType?: HolidayType;
}

/** 0 = Follow 1 = FollowWithCustom 2 = Custom */
export enum HolidayType {
  Follow = 0,
  FollowWithCustom = 1,
  Custom = 2,
}

export class QueuesPutCommand implements IQueuesPutCommand {
  id?: number;
  ticketStartRange?: number | undefined;
  ticketEndRange?: number | undefined;
  numberOfCustomers?: number | undefined;
  isActive?: boolean;
  isQmeCounter?: boolean;
  isQmeApp?: boolean;
  isQmeNow?: boolean;
  averageServingTime?: number;
  holidayType?: HolidayType;

  constructor(data?: IQueuesPutCommand) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data['id'];
      this.ticketStartRange = _data['ticketStartRange'];
      this.ticketEndRange = _data['ticketEndRange'];
      this.numberOfCustomers = _data['numberOfCustomers'];
      this.isActive = _data['isActive'];
      this.isQmeCounter = _data['isQmeCounter'];
      this.isQmeApp = _data['isQmeApp'];
      this.isQmeNow = _data['isQmeNow'];
      this.averageServingTime = _data['averageServingTime'];
      this.holidayType = _data['holidayType'];
    }
  }

  static fromJS(data: any): QueuesPutCommand {
    data = typeof data === 'object' ? data : {};
    let result = new QueuesPutCommand();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['id'] = this.id;
    data['ticketStartRange'] = this.ticketStartRange;
    data['ticketEndRange'] = this.ticketEndRange;
    data['numberOfCustomers'] = this.numberOfCustomers;
    data['isActive'] = this.isActive;
    data['isQmeCounter'] = this.isQmeCounter;
    data['isQmeApp'] = this.isQmeApp;
    data['isQmeNow'] = this.isQmeNow;
    data['averageServingTime'] = this.averageServingTime;
    data['holidayType'] = this.holidayType;
    return data;
  }
}

export interface IQueuesPutCommand {
  id?: number;
  ticketStartRange?: number | undefined;
  ticketEndRange?: number | undefined;
  numberOfCustomers?: number | undefined;
  isActive?: boolean;
  isQmeCounter?: boolean;
  isQmeApp?: boolean;
  isQmeNow?: boolean;
  averageServingTime?: number;
  holidayType?: HolidayType;
}

export class QueuesPutCounterDataCommand implements IQueuesPutCounterDataCommand {
  queueId?: number;
  firstMessage?: LocalizedStringDto | undefined;
  lastMessage?: LocalizedStringDto | undefined;
  skipNumber?: number | undefined;

  constructor(data?: IQueuesPutCounterDataCommand) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.queueId = _data['queueId'];
      this.firstMessage = _data['firstMessage']
        ? LocalizedStringDto.fromJS(_data['firstMessage'])
        : <any>undefined;
      this.lastMessage = _data['lastMessage']
        ? LocalizedStringDto.fromJS(_data['lastMessage'])
        : <any>undefined;
      this.skipNumber = _data['skipNumber'];
    }
  }

  static fromJS(data: any): QueuesPutCounterDataCommand {
    data = typeof data === 'object' ? data : {};
    let result = new QueuesPutCounterDataCommand();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['queueId'] = this.queueId;
    data['firstMessage'] = this.firstMessage
      ? this.firstMessage.toJSON()
      : <any>undefined;
    data['lastMessage'] = this.lastMessage ? this.lastMessage.toJSON() : <any>undefined;
    data['skipNumber'] = this.skipNumber;
    return data;
  }
}

export interface IQueuesPutCounterDataCommand {
  queueId?: number;
  firstMessage?: LocalizedStringDto | undefined;
  lastMessage?: LocalizedStringDto | undefined;
  skipNumber?: number | undefined;
}

export class QueuesIssueTicketCommand implements IQueuesIssueTicketCommand {
  queueId?: number;
  customerName?: string | undefined;
  customerPhoneNumber?: string | undefined;

  constructor(data?: IQueuesIssueTicketCommand) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.queueId = _data['queueId'];
      this.customerName = _data['customerName'];
      this.customerPhoneNumber = _data['customerPhoneNumber'];
    }
  }

  static fromJS(data: any): QueuesIssueTicketCommand {
    data = typeof data === 'object' ? data : {};
    let result = new QueuesIssueTicketCommand();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['queueId'] = this.queueId;
    data['customerName'] = this.customerName;
    data['customerPhoneNumber'] = this.customerPhoneNumber;
    return data;
  }
}

export interface IQueuesIssueTicketCommand {
  queueId?: number;
  customerName?: string | undefined;
  customerPhoneNumber?: string | undefined;
}

export class QueuesCallTicketCommand implements IQueuesCallTicketCommand {
  queueId?: number;

  constructor(data?: IQueuesCallTicketCommand) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.queueId = _data['queueId'];
    }
  }

  static fromJS(data: any): QueuesCallTicketCommand {
    data = typeof data === 'object' ? data : {};
    let result = new QueuesCallTicketCommand();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['queueId'] = this.queueId;
    return data;
  }
}

export interface IQueuesCallTicketCommand {
  queueId?: number;
}

export class PaginatedListOfReservationDashboardVm
  implements IPaginatedListOfReservationDashboardVm {
  pageInfo?: PageInfo | undefined;
  items?: ReservationDashboardVm[] | undefined;

  constructor(data?: IPaginatedListOfReservationDashboardVm) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.pageInfo = _data['pageInfo']
        ? PageInfo.fromJS(_data['pageInfo'])
        : <any>undefined;
      if (Array.isArray(_data['items'])) {
        this.items = [] as any;
        for (let item of _data['items'])
          this.items!.push(ReservationDashboardVm.fromJS(item));
      }
    }
  }

  static fromJS(data: any): PaginatedListOfReservationDashboardVm {
    data = typeof data === 'object' ? data : {};
    let result = new PaginatedListOfReservationDashboardVm();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['pageInfo'] = this.pageInfo ? this.pageInfo.toJSON() : <any>undefined;
    if (Array.isArray(this.items)) {
      data['items'] = [];
      for (let item of this.items) data['items'].push(item.toJSON());
    }
    return data;
  }
}

export interface IPaginatedListOfReservationDashboardVm {
  pageInfo?: PageInfo | undefined;
  items?: ReservationDashboardVm[] | undefined;
}

export class ReservationDashboardVm implements IReservationDashboardVm {
  id?: number;
  code?: string | undefined;
  status?: ReservationStatus;
  type?: ReservationType;
  dateTime?: Date;
  customerName?: string | undefined;

  constructor(data?: IReservationDashboardVm) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data['id'];
      this.code = _data['code'];
      this.status = _data['status'];
      this.type = _data['type'];
      this.dateTime = _data['dateTime']
        ? new Date(_data['dateTime'].toString())
        : <any>undefined;
      this.customerName = _data['customerName'];
    }
  }

  static fromJS(data: any): ReservationDashboardVm {
    data = typeof data === 'object' ? data : {};
    let result = new ReservationDashboardVm();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['id'] = this.id;
    data['code'] = this.code;
    data['status'] = this.status;
    data['type'] = this.type;
    data['dateTime'] = this.dateTime ? this.dateTime.toISOString() : <any>undefined;
    data['customerName'] = this.customerName;
    return data;
  }
}

export interface IReservationDashboardVm {
  id?: number;
  code?: string | undefined;
  status?: ReservationStatus;
  type?: ReservationType;
  dateTime?: Date;
  customerName?: string | undefined;
}

/** 0 = Manual 1 = OneTime 2 = Recurring */
export enum ReservationType {
  Manual = 0,
  OneTime = 1,
  Recurring = 2,
}

export class PaginatedListOfServiceProviderPageVm
  implements IPaginatedListOfServiceProviderPageVm {
  pageInfo?: PageInfo | undefined;
  items?: ServiceProviderPageVm[] | undefined;

  constructor(data?: IPaginatedListOfServiceProviderPageVm) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.pageInfo = _data['pageInfo']
        ? PageInfo.fromJS(_data['pageInfo'])
        : <any>undefined;
      if (Array.isArray(_data['items'])) {
        this.items = [] as any;
        for (let item of _data['items'])
          this.items!.push(ServiceProviderPageVm.fromJS(item));
      }
    }
  }

  static fromJS(data: any): PaginatedListOfServiceProviderPageVm {
    data = typeof data === 'object' ? data : {};
    let result = new PaginatedListOfServiceProviderPageVm();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['pageInfo'] = this.pageInfo ? this.pageInfo.toJSON() : <any>undefined;
    if (Array.isArray(this.items)) {
      data['items'] = [];
      for (let item of this.items) data['items'].push(item.toJSON());
    }
    return data;
  }
}

export interface IPaginatedListOfServiceProviderPageVm {
  pageInfo?: PageInfo | undefined;
  items?: ServiceProviderPageVm[] | undefined;
}

export class ServiceProviderPageVm implements IServiceProviderPageVm {
  id?: number;
  name?: LocalizedStringDto | undefined;
  categoryName?: string | undefined;
  numberOfBranches?: number;
  numberOfServices?: number;

  constructor(data?: IServiceProviderPageVm) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data['id'];
      this.name = _data['name']
        ? LocalizedStringDto.fromJS(_data['name'])
        : <any>undefined;
      this.categoryName = _data['categoryName'];
      this.numberOfBranches = _data['numberOfBranches'];
      this.numberOfServices = _data['numberOfServices'];
    }
  }

  static fromJS(data: any): ServiceProviderPageVm {
    data = typeof data === 'object' ? data : {};
    let result = new ServiceProviderPageVm();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['id'] = this.id;
    data['name'] = this.name ? this.name.toJSON() : <any>undefined;
    data['categoryName'] = this.categoryName;
    data['numberOfBranches'] = this.numberOfBranches;
    data['numberOfServices'] = this.numberOfServices;
    return data;
  }
}

export interface IServiceProviderPageVm {
  id?: number;
  name?: LocalizedStringDto | undefined;
  categoryName?: string | undefined;
  numberOfBranches?: number;
  numberOfServices?: number;
}

export class ServiceProviderFullVm implements IServiceProviderFullVm {
  id?: number;
  name?: string | undefined;
  branches?: BranchShortVm[] | undefined;
  services?: ServiceVm[] | undefined;

  constructor(data?: IServiceProviderFullVm) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data['id'];
      this.name = _data['name'];
      if (Array.isArray(_data['branches'])) {
        this.branches = [] as any;
        for (let item of _data['branches'])
          this.branches!.push(BranchShortVm.fromJS(item));
      }
      if (Array.isArray(_data['services'])) {
        this.services = [] as any;
        for (let item of _data['services']) this.services!.push(ServiceVm.fromJS(item));
      }
    }
  }

  static fromJS(data: any): ServiceProviderFullVm {
    data = typeof data === 'object' ? data : {};
    let result = new ServiceProviderFullVm();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['id'] = this.id;
    data['name'] = this.name;
    if (Array.isArray(this.branches)) {
      data['branches'] = [];
      for (let item of this.branches) data['branches'].push(item.toJSON());
    }
    if (Array.isArray(this.services)) {
      data['services'] = [];
      for (let item of this.services) data['services'].push(item.toJSON());
    }
    return data;
  }
}

export interface IServiceProviderFullVm {
  id?: number;
  name?: string | undefined;
  branches?: BranchShortVm[] | undefined;
  services?: ServiceVm[] | undefined;
}

export class BranchShortVm implements IBranchShortVm {
  id?: number;
  name?: string | undefined;

  constructor(data?: IBranchShortVm) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data['id'];
      this.name = _data['name'];
    }
  }

  static fromJS(data: any): BranchShortVm {
    data = typeof data === 'object' ? data : {};
    let result = new BranchShortVm();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['id'] = this.id;
    data['name'] = this.name;
    return data;
  }
}

export interface IBranchShortVm {
  id?: number;
  name?: string | undefined;
}

export class ServiceProviderDashboardVm implements IServiceProviderDashboardVm {
  id?: number;
  name?: string | undefined;

  constructor(data?: IServiceProviderDashboardVm) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data['id'];
      this.name = _data['name'];
    }
  }

  static fromJS(data: any): ServiceProviderDashboardVm {
    data = typeof data === 'object' ? data : {};
    let result = new ServiceProviderDashboardVm();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['id'] = this.id;
    data['name'] = this.name;
    return data;
  }
}

export interface IServiceProviderDashboardVm {
  id?: number;
  name?: string | undefined;
}

export class ServiceProviderDto implements IServiceProviderDto {
  id?: number;
  name?: LocalizedStringDto | undefined;
  contactInfo?: ContactInfoDto | undefined;
  logoUrl?: string | undefined;
  isActive?: boolean;
  categoryId?: number;
  accountManagerId?: number | undefined;

  constructor(data?: IServiceProviderDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data['id'];
      this.name = _data['name']
        ? LocalizedStringDto.fromJS(_data['name'])
        : <any>undefined;
      this.contactInfo = _data['contactInfo']
        ? ContactInfoDto.fromJS(_data['contactInfo'])
        : <any>undefined;
      this.logoUrl = _data['logoUrl'];
      this.isActive = _data['isActive'];
      this.categoryId = _data['categoryId'];
      this.accountManagerId = _data['accountManagerId'];
    }
  }

  static fromJS(data: any): ServiceProviderDto {
    data = typeof data === 'object' ? data : {};
    let result = new ServiceProviderDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['id'] = this.id;
    data['name'] = this.name ? this.name.toJSON() : <any>undefined;
    data['contactInfo'] = this.contactInfo ? this.contactInfo.toJSON() : <any>undefined;
    data['logoUrl'] = this.logoUrl;
    data['isActive'] = this.isActive;
    data['categoryId'] = this.categoryId;
    data['accountManagerId'] = this.accountManagerId;
    return data;
  }
}

export interface IServiceProviderDto {
  id?: number;
  name?: LocalizedStringDto | undefined;
  contactInfo?: ContactInfoDto | undefined;
  logoUrl?: string | undefined;
  isActive?: boolean;
  categoryId?: number;
  accountManagerId?: number | undefined;
}

export class PaginatedListOfGroupServiceDashboardVm
  implements IPaginatedListOfGroupServiceDashboardVm {
  pageInfo?: PageInfo | undefined;
  items?: GroupServiceDashboardVm[] | undefined;

  constructor(data?: IPaginatedListOfGroupServiceDashboardVm) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.pageInfo = _data['pageInfo']
        ? PageInfo.fromJS(_data['pageInfo'])
        : <any>undefined;
      if (Array.isArray(_data['items'])) {
        this.items = [] as any;
        for (let item of _data['items'])
          this.items!.push(GroupServiceDashboardVm.fromJS(item));
      }
    }
  }

  static fromJS(data: any): PaginatedListOfGroupServiceDashboardVm {
    data = typeof data === 'object' ? data : {};
    let result = new PaginatedListOfGroupServiceDashboardVm();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['pageInfo'] = this.pageInfo ? this.pageInfo.toJSON() : <any>undefined;
    if (Array.isArray(this.items)) {
      data['items'] = [];
      for (let item of this.items) data['items'].push(item.toJSON());
    }
    return data;
  }
}

export interface IPaginatedListOfGroupServiceDashboardVm {
  pageInfo?: PageInfo | undefined;
  items?: GroupServiceDashboardVm[] | undefined;
}

export class GroupServiceDashboardVm implements IGroupServiceDashboardVm {
  id?: number;
  name?: LocalizedStringDto | undefined;
  serviceProviderName?: string | undefined;
  numberOfServices?: number;

  constructor(data?: IGroupServiceDashboardVm) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data['id'];
      this.name = _data['name']
        ? LocalizedStringDto.fromJS(_data['name'])
        : <any>undefined;
      this.serviceProviderName = _data['serviceProviderName'];
      this.numberOfServices = _data['numberOfServices'];
    }
  }

  static fromJS(data: any): GroupServiceDashboardVm {
    data = typeof data === 'object' ? data : {};
    let result = new GroupServiceDashboardVm();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['id'] = this.id;
    data['name'] = this.name ? this.name.toJSON() : <any>undefined;
    data['serviceProviderName'] = this.serviceProviderName;
    data['numberOfServices'] = this.numberOfServices;
    return data;
  }
}

export interface IGroupServiceDashboardVm {
  id?: number;
  name?: LocalizedStringDto | undefined;
  serviceProviderName?: string | undefined;
  numberOfServices?: number;
}

export class GroupServiceVm implements IGroupServiceVm {
  id?: number;
  name?: string | undefined;

  constructor(data?: IGroupServiceVm) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data['id'];
      this.name = _data['name'];
    }
  }

  static fromJS(data: any): GroupServiceVm {
    data = typeof data === 'object' ? data : {};
    let result = new GroupServiceVm();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['id'] = this.id;
    data['name'] = this.name;
    return data;
  }
}

export interface IGroupServiceVm {
  id?: number;
  name?: string | undefined;
}

export class GroupServiceDto implements IGroupServiceDto {
  id?: number;
  name?: LocalizedStringDto | undefined;
  contactInfo?: ContactInfoDto | undefined;
  logoUrl?: string | undefined;
  isActive?: boolean;
  serviceProviderId?: number;
  bookingFee?: FeeDto | undefined;
  otherFee?: FeeDto | undefined;
  services?: ServiceDto[] | undefined;

  constructor(data?: IGroupServiceDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data['id'];
      this.name = _data['name']
        ? LocalizedStringDto.fromJS(_data['name'])
        : <any>undefined;
      this.contactInfo = _data['contactInfo']
        ? ContactInfoDto.fromJS(_data['contactInfo'])
        : <any>undefined;
      this.logoUrl = _data['logoUrl'];
      this.isActive = _data['isActive'];
      this.serviceProviderId = _data['serviceProviderId'];
      this.bookingFee = _data['bookingFee']
        ? FeeDto.fromJS(_data['bookingFee'])
        : <any>undefined;
      this.otherFee = _data['otherFee']
        ? FeeDto.fromJS(_data['otherFee'])
        : <any>undefined;
      if (Array.isArray(_data['services'])) {
        this.services = [] as any;
        for (let item of _data['services']) this.services!.push(ServiceDto.fromJS(item));
      }
    }
  }

  static fromJS(data: any): GroupServiceDto {
    data = typeof data === 'object' ? data : {};
    let result = new GroupServiceDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['id'] = this.id;
    data['name'] = this.name ? this.name.toJSON() : <any>undefined;
    data['contactInfo'] = this.contactInfo ? this.contactInfo.toJSON() : <any>undefined;
    data['logoUrl'] = this.logoUrl;
    data['isActive'] = this.isActive;
    data['serviceProviderId'] = this.serviceProviderId;
    data['bookingFee'] = this.bookingFee ? this.bookingFee.toJSON() : <any>undefined;
    data['otherFee'] = this.otherFee ? this.otherFee.toJSON() : <any>undefined;
    if (Array.isArray(this.services)) {
      data['services'] = [];
      for (let item of this.services) data['services'].push(item.toJSON());
    }
    return data;
  }
}

export interface IGroupServiceDto {
  id?: number;
  name?: LocalizedStringDto | undefined;
  contactInfo?: ContactInfoDto | undefined;
  logoUrl?: string | undefined;
  isActive?: boolean;
  serviceProviderId?: number;
  bookingFee?: FeeDto | undefined;
  otherFee?: FeeDto | undefined;
  services?: ServiceDto[] | undefined;
}

export class FeeDto implements IFeeDto {
  name?: LocalizedStringDto | undefined;
  amount?: number | undefined;

  constructor(data?: IFeeDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.name = _data['name']
        ? LocalizedStringDto.fromJS(_data['name'])
        : <any>undefined;
      this.amount = _data['amount'];
    }
  }

  static fromJS(data: any): FeeDto {
    data = typeof data === 'object' ? data : {};
    let result = new FeeDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['name'] = this.name ? this.name.toJSON() : <any>undefined;
    data['amount'] = this.amount;
    return data;
  }
}

export interface IFeeDto {
  name?: LocalizedStringDto | undefined;
  amount?: number | undefined;
}

export class ServiceDto implements IServiceDto {
  id?: number;
  name?: LocalizedStringDto | undefined;
  isActive?: boolean;

  constructor(data?: IServiceDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data['id'];
      this.name = _data['name']
        ? LocalizedStringDto.fromJS(_data['name'])
        : <any>undefined;
      this.isActive = _data['isActive'];
    }
  }

  static fromJS(data: any): ServiceDto {
    data = typeof data === 'object' ? data : {};
    let result = new ServiceDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['id'] = this.id;
    data['name'] = this.name ? this.name.toJSON() : <any>undefined;
    data['isActive'] = this.isActive;
    return data;
  }
}

export interface IServiceDto {
  id?: number;
  name?: LocalizedStringDto | undefined;
  isActive?: boolean;
}

export class PaginatedListOfTransactionVm implements IPaginatedListOfTransactionVm {
  pageInfo?: PageInfo | undefined;
  items?: TransactionVm[] | undefined;

  constructor(data?: IPaginatedListOfTransactionVm) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.pageInfo = _data['pageInfo']
        ? PageInfo.fromJS(_data['pageInfo'])
        : <any>undefined;
      if (Array.isArray(_data['items'])) {
        this.items = [] as any;
        for (let item of _data['items']) this.items!.push(TransactionVm.fromJS(item));
      }
    }
  }

  static fromJS(data: any): PaginatedListOfTransactionVm {
    data = typeof data === 'object' ? data : {};
    let result = new PaginatedListOfTransactionVm();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['pageInfo'] = this.pageInfo ? this.pageInfo.toJSON() : <any>undefined;
    if (Array.isArray(this.items)) {
      data['items'] = [];
      for (let item of this.items) data['items'].push(item.toJSON());
    }
    return data;
  }
}

export interface IPaginatedListOfTransactionVm {
  pageInfo?: PageInfo | undefined;
  items?: TransactionVm[] | undefined;
}

export class TransactionVm implements ITransactionVm {
  id?: string | undefined;
  amount?: number;
  type?: TransactionType;
  status?: TransactionStatus;
  createdAt?: Date;
  paidAt?: Date | undefined;
  refundedAt?: Date | undefined;
  accountId?: string | undefined;
  accountName?: string | undefined;

  constructor(data?: ITransactionVm) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data['id'];
      this.amount = _data['amount'];
      this.type = _data['type'];
      this.status = _data['status'];
      this.createdAt = _data['createdAt']
        ? new Date(_data['createdAt'].toString())
        : <any>undefined;
      this.paidAt = _data['paidAt']
        ? new Date(_data['paidAt'].toString())
        : <any>undefined;
      this.refundedAt = _data['refundedAt']
        ? new Date(_data['refundedAt'].toString())
        : <any>undefined;
      this.accountId = _data['accountId'];
      this.accountName = _data['accountName'];
    }
  }

  static fromJS(data: any): TransactionVm {
    data = typeof data === 'object' ? data : {};
    let result = new TransactionVm();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['id'] = this.id;
    data['amount'] = this.amount;
    data['type'] = this.type;
    data['status'] = this.status;
    data['createdAt'] = this.createdAt ? this.createdAt.toISOString() : <any>undefined;
    data['paidAt'] = this.paidAt ? this.paidAt.toISOString() : <any>undefined;
    data['refundedAt'] = this.refundedAt ? this.refundedAt.toISOString() : <any>undefined;
    data['accountId'] = this.accountId;
    data['accountName'] = this.accountName;
    return data;
  }
}

export interface ITransactionVm {
  id?: string | undefined;
  amount?: number;
  type?: TransactionType;
  status?: TransactionStatus;
  createdAt?: Date;
  paidAt?: Date | undefined;
  refundedAt?: Date | undefined;
  accountId?: string | undefined;
  accountName?: string | undefined;
}

/** 0 = Ticket 1 = Reservation 2 = Subscription 3 = Gift */
export enum TransactionType {
  Ticket = 0,
  Reservation = 1,
  Subscription = 2,
  Gift = 3,
}

/** 0 = Pending 1 = Paid 2 = InProgress 3 = Rejected 4 = Refunded */
export enum TransactionStatus {
  Pending = 0,
  Paid = 1,
  InProgress = 2,
  Rejected = 3,
  Refunded = 4,
}

export class WalletVm implements IWalletVm {
  amount?: number;

  constructor(data?: IWalletVm) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.amount = _data['amount'];
    }
  }

  static fromJS(data: any): WalletVm {
    data = typeof data === 'object' ? data : {};
    let result = new WalletVm();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['amount'] = this.amount;
    return data;
  }
}

export interface IWalletVm {
  amount?: number;
}

export class TransactionResponse implements ITransactionResponse {
  status?: string | undefined;
  otpPage?: string | undefined;

  constructor(data?: ITransactionResponse) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.status = _data['status'];
      this.otpPage = _data['otpPage'];
    }
  }

  static fromJS(data: any): TransactionResponse {
    data = typeof data === 'object' ? data : {};
    let result = new TransactionResponse();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['status'] = this.status;
    data['otpPage'] = this.otpPage;
    return data;
  }
}

export interface ITransactionResponse {
  status?: string | undefined;
  otpPage?: string | undefined;
}

export class TransactionsPayCommand implements ITransactionsPayCommand {
  reservationId?: number;
  paymentInfo?: PaymentInfo | undefined;

  constructor(data?: ITransactionsPayCommand) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.reservationId = _data['reservationId'];
      this.paymentInfo = _data['paymentInfo']
        ? PaymentInfo.fromJS(_data['paymentInfo'])
        : <any>undefined;
    }
  }

  static fromJS(data: any): TransactionsPayCommand {
    data = typeof data === 'object' ? data : {};
    let result = new TransactionsPayCommand();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['reservationId'] = this.reservationId;
    data['paymentInfo'] = this.paymentInfo ? this.paymentInfo.toJSON() : <any>undefined;
    return data;
  }
}

export interface ITransactionsPayCommand {
  reservationId?: number;
  paymentInfo?: PaymentInfo | undefined;
}

export class PaymentInfo implements IPaymentInfo {
  card?: string | undefined;
  expiry?: ExpiryDate | undefined;
  cvv?: string | undefined;
  ipAddress?: string | undefined;

  constructor(data?: IPaymentInfo) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.card = _data['card'];
      this.expiry = _data['expiry'] ? ExpiryDate.fromJS(_data['expiry']) : <any>undefined;
      this.cvv = _data['cvv'];
      this.ipAddress = _data['ipAddress'];
    }
  }

  static fromJS(data: any): PaymentInfo {
    data = typeof data === 'object' ? data : {};
    let result = new PaymentInfo();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['card'] = this.card;
    data['expiry'] = this.expiry ? this.expiry.toJSON() : <any>undefined;
    data['cvv'] = this.cvv;
    data['ipAddress'] = this.ipAddress;
    return data;
  }
}

export interface IPaymentInfo {
  card?: string | undefined;
  expiry?: ExpiryDate | undefined;
  cvv?: string | undefined;
  ipAddress?: string | undefined;
}

export class ExpiryDate implements IExpiryDate {
  month?: string | undefined;
  year?: string | undefined;

  constructor(data?: IExpiryDate) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.month = _data['month'];
      this.year = _data['year'];
    }
  }

  static fromJS(data: any): ExpiryDate {
    data = typeof data === 'object' ? data : {};
    let result = new ExpiryDate();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['month'] = this.month;
    data['year'] = this.year;
    return data;
  }
}

export interface IExpiryDate {
  month?: string | undefined;
  year?: string | undefined;
}

export class TransactionsConfirmOtpCommand implements ITransactionsConfirmOtpCommand {
  reservationId?: number;
  paymentInfo?: PaymentInfo | undefined;

  constructor(data?: ITransactionsConfirmOtpCommand) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.reservationId = _data['reservationId'];
      this.paymentInfo = _data['paymentInfo']
        ? PaymentInfo.fromJS(_data['paymentInfo'])
        : <any>undefined;
    }
  }

  static fromJS(data: any): TransactionsConfirmOtpCommand {
    data = typeof data === 'object' ? data : {};
    let result = new TransactionsConfirmOtpCommand();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['reservationId'] = this.reservationId;
    data['paymentInfo'] = this.paymentInfo ? this.paymentInfo.toJSON() : <any>undefined;
    return data;
  }
}

export interface ITransactionsConfirmOtpCommand {
  reservationId?: number;
  paymentInfo?: PaymentInfo | undefined;
}

export class WorkingDayDto implements IWorkingDayDto {
  id?: number;
  dayOfWeek?: DayOfWeek;
  startTime?: TimeDto | undefined;
  endTime?: TimeDto | undefined;

  constructor(data?: IWorkingDayDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data['id'];
      this.dayOfWeek = _data['dayOfWeek'];
      this.startTime = _data['startTime']
        ? TimeDto.fromJS(_data['startTime'])
        : <any>undefined;
      this.endTime = _data['endTime'] ? TimeDto.fromJS(_data['endTime']) : <any>undefined;
    }
  }

  static fromJS(data: any): WorkingDayDto {
    data = typeof data === 'object' ? data : {};
    let result = new WorkingDayDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['id'] = this.id;
    data['dayOfWeek'] = this.dayOfWeek;
    data['startTime'] = this.startTime ? this.startTime.toJSON() : <any>undefined;
    data['endTime'] = this.endTime ? this.endTime.toJSON() : <any>undefined;
    return data;
  }
}

export interface IWorkingDayDto {
  id?: number;
  dayOfWeek?: DayOfWeek;
  startTime?: TimeDto | undefined;
  endTime?: TimeDto | undefined;
}

export class WorkingDaysPutCommand implements IWorkingDaysPutCommand {
  queueId?: number;
  workingDays?: WorkingDayDto[] | undefined;

  constructor(data?: IWorkingDaysPutCommand) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.queueId = _data['queueId'];
      if (Array.isArray(_data['workingDays'])) {
        this.workingDays = [] as any;
        for (let item of _data['workingDays'])
          this.workingDays!.push(WorkingDayDto.fromJS(item));
      }
    }
  }

  static fromJS(data: any): WorkingDaysPutCommand {
    data = typeof data === 'object' ? data : {};
    let result = new WorkingDaysPutCommand();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['queueId'] = this.queueId;
    if (Array.isArray(this.workingDays)) {
      data['workingDays'] = [];
      for (let item of this.workingDays) data['workingDays'].push(item.toJSON());
    }
    return data;
  }
}

export interface IWorkingDaysPutCommand {
  queueId?: number;
  workingDays?: WorkingDayDto[] | undefined;
}

export interface FileParameter {
  data: any;
  fileName: string;
}

export interface FileResponse {
  data: Blob;
  status: number;
  fileName?: string;
  headers?: { [name: string]: any };
}

export class ApiException extends Error {
  message: string;
  status: number;
  response: string;
  headers: { [key: string]: any };
  result: any;

  constructor(
    message: string,
    status: number,
    response: string,
    headers: { [key: string]: any },
    result: any
  ) {
    super();

    this.message = message;
    this.status = status;
    this.response = response;
    this.headers = headers;
    this.result = result;
  }

  protected isApiException = true;

  static isApiException(obj: any): obj is ApiException {
    return obj.isApiException === true;
  }
}

function throwException(
  message: string,
  status: number,
  response: string,
  headers: { [key: string]: any },
  result?: any
): Observable<any> {
  if (result !== null && result !== undefined) return _observableThrow(result);
  else
    return _observableThrow(new ApiException(message, status, response, headers, null));
}

function blobToText(blob: any): Observable<string> {
  return new Observable<string>((observer: any) => {
    if (!blob) {
      observer.next('');
      observer.complete();
    } else {
      let reader = new FileReader();
      reader.onload = (event) => {
        observer.next((<any>event.target).result);
        observer.complete();
      };
      reader.readAsText(blob);
    }
  });
}
