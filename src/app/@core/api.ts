/* tslint:disable */
/* eslint-disable */
//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v13.15.5.0 (NJsonSchema v10.6.6.0 (Newtonsoft.Json v12.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------
// ReSharper disable InconsistentNaming

import { mergeMap as _observableMergeMap, catchError as _observableCatch } from 'rxjs/operators';
import { Observable, throwError as _observableThrow, of as _observableOf } from 'rxjs';
import { Injectable, Inject, Optional, InjectionToken } from '@angular/core';
import { HttpClient, HttpHeaders, HttpResponse, HttpResponseBase } from '@angular/common/http';

export const API_BASE_URL = new InjectionToken<string>('API_BASE_URL');

export interface IAccountsClient {
    getPage(offset: number | null | undefined, pageIndex: number | null | undefined, search: string | null | undefined, ascending: boolean | undefined, sortBy: string | null | undefined): Observable<PaginatedListOfAccountVm>;
    getAdminsPage(role: Role | undefined, offset: number | null | undefined, pageIndex: number | null | undefined, search: string | null | undefined, ascending: boolean | undefined, sortBy: string | null | undefined): Observable<PaginatedListOfAdminVm>;
    getUser(id: string | null | undefined): Observable<AccountDashboardDto>;
    get(): Observable<AccountDto>;
    post(command: AccountsPostCommand): Observable<AccountResult>;
    put(command: AccountsPutCommand): Observable<void>;
    delete(userId: string | null | undefined): Observable<void>;
    refreshToken(command: RefreshTokenCommand): Observable<AuthResponse>;
    login(command: LoginCommand): Observable<AuthResponse>;
    register(command: RegisterCommand): Observable<HttpResultOfString>;
    externalLogin(command: ExternalLoginCommand): Observable<AuthResponse>;
    externalRegistration(command: ExternalRegisterCommand): Observable<HttpResultOfString>;
    resetPassword(command: ResetPasswordCommand): Observable<AuthResponse>;
    confirmPhoneNumber(command: ConfirmPhoneNumberCommand): Observable<AuthResponse>;
    confirmChangedPhoneNumber(command: ConfirmChangePhoneNumberCommand): Observable<void>;
    resendConfirmationMessage(command: ResendPhoneNumberConfirmationCommand): Observable<void>;
    forgetPassword(command: ForgetPasswordCommand): Observable<void>;
    validateToken(command: ValidateResetPasswordToken): Observable<void>;
    uploadPicture(userId: string | null | undefined, picture: FileParameter | null | undefined): Observable<void>;
    changeProfile(picture: FileParameter | null | undefined, email: string | null | undefined, fullName_FirstName: string | null | undefined, fullName_LastName: string | null | undefined): Observable<void>;
    changePhoneNumber(command: ChangePhoneNumberCommand): Observable<void>;
    changePassword(command: ChangePasswordCommand): Observable<void>;
    changeLanguage(command: ChangeLanguageCommand): Observable<void>;
    resetUserPassword(command: ResetUserPasswordCommand): Observable<void>;
    endLockout(command: AccountsEndLockoutCommand): Observable<void>;
    ban(command: AccountsBanCommand): Observable<void>;
    logout(): Observable<void>;
}

@Injectable({
    providedIn: 'root'
})
export class AccountsClient implements IAccountsClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    getPage(offset: number | null | undefined, pageIndex: number | null | undefined, search: string | null | undefined, ascending: boolean | undefined, sortBy: string | null | undefined): Observable<PaginatedListOfAccountVm> {
        let url_ = this.baseUrl + "/api/Accounts/GetPage?";
        if (offset !== undefined && offset !== null)
            url_ += "Offset=" + encodeURIComponent("" + offset) + "&";
        if (pageIndex !== undefined && pageIndex !== null)
            url_ += "PageIndex=" + encodeURIComponent("" + pageIndex) + "&";
        if (search !== undefined && search !== null)
            url_ += "Search=" + encodeURIComponent("" + search) + "&";
        if (ascending === null)
            throw new Error("The parameter 'ascending' cannot be null.");
        else if (ascending !== undefined)
            url_ += "Ascending=" + encodeURIComponent("" + ascending) + "&";
        if (sortBy !== undefined && sortBy !== null)
            url_ += "SortBy=" + encodeURIComponent("" + sortBy) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_: any) => {
            return this.processGetPage(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPage(<any>response_);
                } catch (e) {
                    return <Observable<PaginatedListOfAccountVm>><any>_observableThrow(e);
                }
            } else
                return <Observable<PaginatedListOfAccountVm>><any>_observableThrow(response_);
        }));
    }

    protected processGetPage(response: HttpResponseBase): Observable<PaginatedListOfAccountVm> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
                (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } }
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result200: any = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = PaginatedListOfAccountVm.fromJS(resultData200);
                return _observableOf(result200);
            }));
        } else if (status === 422) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result422: any = null;
                let resultData422 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result422 = ValidationProblemDetails.fromJS(resultData422);
                return throwException("A server side error occurred.", status, _responseText, _headers, result422);
            }));
        } else {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let resultdefault: any = null;
                let resultDatadefault = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                resultdefault = ProblemDetails.fromJS(resultDatadefault);
                return throwException("A server side error occurred.", status, _responseText, _headers, resultdefault);
            }));
        }
    }

    getAdminsPage(role: Role | undefined, offset: number | null | undefined, pageIndex: number | null | undefined, search: string | null | undefined, ascending: boolean | undefined, sortBy: string | null | undefined): Observable<PaginatedListOfAdminVm> {
        let url_ = this.baseUrl + "/api/Accounts/GetAdminsPage?";
        if (role === null)
            throw new Error("The parameter 'role' cannot be null.");
        else if (role !== undefined)
            url_ += "Role=" + encodeURIComponent("" + role) + "&";
        if (offset !== undefined && offset !== null)
            url_ += "Offset=" + encodeURIComponent("" + offset) + "&";
        if (pageIndex !== undefined && pageIndex !== null)
            url_ += "PageIndex=" + encodeURIComponent("" + pageIndex) + "&";
        if (search !== undefined && search !== null)
            url_ += "Search=" + encodeURIComponent("" + search) + "&";
        if (ascending === null)
            throw new Error("The parameter 'ascending' cannot be null.");
        else if (ascending !== undefined)
            url_ += "Ascending=" + encodeURIComponent("" + ascending) + "&";
        if (sortBy !== undefined && sortBy !== null)
            url_ += "SortBy=" + encodeURIComponent("" + sortBy) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_: any) => {
            return this.processGetAdminsPage(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAdminsPage(<any>response_);
                } catch (e) {
                    return <Observable<PaginatedListOfAdminVm>><any>_observableThrow(e);
                }
            } else
                return <Observable<PaginatedListOfAdminVm>><any>_observableThrow(response_);
        }));
    }

    protected processGetAdminsPage(response: HttpResponseBase): Observable<PaginatedListOfAdminVm> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
                (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } }
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result200: any = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = PaginatedListOfAdminVm.fromJS(resultData200);
                return _observableOf(result200);
            }));
        } else if (status === 422) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result422: any = null;
                let resultData422 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result422 = ValidationProblemDetails.fromJS(resultData422);
                return throwException("A server side error occurred.", status, _responseText, _headers, result422);
            }));
        } else {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let resultdefault: any = null;
                let resultDatadefault = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                resultdefault = ProblemDetails.fromJS(resultDatadefault);
                return throwException("A server side error occurred.", status, _responseText, _headers, resultdefault);
            }));
        }
    }

    getUser(id: string | null | undefined): Observable<AccountDashboardDto> {
        let url_ = this.baseUrl + "/api/Accounts/GetUser?";
        if (id !== undefined && id !== null)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_: any) => {
            return this.processGetUser(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetUser(<any>response_);
                } catch (e) {
                    return <Observable<AccountDashboardDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<AccountDashboardDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetUser(response: HttpResponseBase): Observable<AccountDashboardDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
                (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } }
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result200: any = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = AccountDashboardDto.fromJS(resultData200);
                return _observableOf(result200);
            }));
        } else if (status === 422) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result422: any = null;
                let resultData422 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result422 = ValidationProblemDetails.fromJS(resultData422);
                return throwException("A server side error occurred.", status, _responseText, _headers, result422);
            }));
        } else {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let resultdefault: any = null;
                let resultDatadefault = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                resultdefault = ProblemDetails.fromJS(resultDatadefault);
                return throwException("A server side error occurred.", status, _responseText, _headers, resultdefault);
            }));
        }
    }

    get(): Observable<AccountDto> {
        let url_ = this.baseUrl + "/api/Accounts";
        url_ = url_.replace(/[?&]$/, "");

        let options_: any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_: any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(<any>response_);
                } catch (e) {
                    return <Observable<AccountDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<AccountDto>><any>_observableThrow(response_);
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<AccountDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
                (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } }
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result200: any = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = AccountDto.fromJS(resultData200);
                return _observableOf(result200);
            }));
        } else {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let resultdefault: any = null;
                let resultDatadefault = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                resultdefault = ProblemDetails.fromJS(resultDatadefault);
                return throwException("A server side error occurred.", status, _responseText, _headers, resultdefault);
            }));
        }
    }

    post(command: AccountsPostCommand): Observable<AccountResult> {
        let url_ = this.baseUrl + "/api/Accounts";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_: any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_: any) => {
            return this.processPost(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPost(<any>response_);
                } catch (e) {
                    return <Observable<AccountResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<AccountResult>><any>_observableThrow(response_);
        }));
    }

    protected processPost(response: HttpResponseBase): Observable<AccountResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
                (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } }
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result200: any = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = AccountResult.fromJS(resultData200);
                return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result404: any = null;
                let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result404 = ProblemDetails.fromJS(resultData404);
                return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result400: any = null;
                let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result400 = ProblemDetails.fromJS(resultData400);
                return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 422) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result422: any = null;
                let resultData422 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result422 = ValidationProblemDetails.fromJS(resultData422);
                return throwException("A server side error occurred.", status, _responseText, _headers, result422);
            }));
        } else {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let resultdefault: any = null;
                let resultDatadefault = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                resultdefault = ProblemDetails.fromJS(resultDatadefault);
                return throwException("A server side error occurred.", status, _responseText, _headers, resultdefault);
            }));
        }
    }

    put(command: AccountsPutCommand): Observable<void> {
        let url_ = this.baseUrl + "/api/Accounts";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_: any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_: any) => {
            return this.processPut(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPut(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processPut(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
                (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } }
        if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return _observableOf<void>(<any>null);
            }));
        } else if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return _observableOf<void>(<any>null);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result404: any = null;
                let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result404 = ProblemDetails.fromJS(resultData404);
                return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result400: any = null;
                let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result400 = ProblemDetails.fromJS(resultData400);
                return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 422) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result422: any = null;
                let resultData422 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result422 = ValidationProblemDetails.fromJS(resultData422);
                return throwException("A server side error occurred.", status, _responseText, _headers, result422);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    delete(userId: string | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/Accounts?";
        if (userId !== undefined && userId !== null)
            url_ += "UserId=" + encodeURIComponent("" + userId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_: any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
                (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } }
        if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return _observableOf<void>(<any>null);
            }));
        } else if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return _observableOf<void>(<any>null);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result404: any = null;
                let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result404 = ProblemDetails.fromJS(resultData404);
                return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result400: any = null;
                let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result400 = ProblemDetails.fromJS(resultData400);
                return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 422) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result422: any = null;
                let resultData422 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result422 = ValidationProblemDetails.fromJS(resultData422);
                return throwException("A server side error occurred.", status, _responseText, _headers, result422);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    refreshToken(command: RefreshTokenCommand): Observable<AuthResponse> {
        let url_ = this.baseUrl + "/api/Accounts/RefreshToken";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_: any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_: any) => {
            return this.processRefreshToken(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRefreshToken(<any>response_);
                } catch (e) {
                    return <Observable<AuthResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<AuthResponse>><any>_observableThrow(response_);
        }));
    }

    protected processRefreshToken(response: HttpResponseBase): Observable<AuthResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
                (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } }
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result200: any = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = AuthResponse.fromJS(resultData200);
                return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result404: any = null;
                let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result404 = ProblemDetails.fromJS(resultData404);
                return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            }));
        } else {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let resultdefault: any = null;
                let resultDatadefault = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                resultdefault = ProblemDetails.fromJS(resultDatadefault);
                return throwException("A server side error occurred.", status, _responseText, _headers, resultdefault);
            }));
        }
    }

    login(command: LoginCommand): Observable<AuthResponse> {
        let url_ = this.baseUrl + "/api/Accounts/Login";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_: any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_: any) => {
            return this.processLogin(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processLogin(<any>response_);
                } catch (e) {
                    return <Observable<AuthResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<AuthResponse>><any>_observableThrow(response_);
        }));
    }

    protected processLogin(response: HttpResponseBase): Observable<AuthResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
                (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } }
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result200: any = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = AuthResponse.fromJS(resultData200);
                return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result404: any = null;
                let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result404 = ProblemDetails.fromJS(resultData404);
                return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result400: any = null;
                let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result400 = ProblemDetails.fromJS(resultData400);
                return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 422) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result422: any = null;
                let resultData422 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result422 = ValidationProblemDetails.fromJS(resultData422);
                return throwException("A server side error occurred.", status, _responseText, _headers, result422);
            }));
        } else {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let resultdefault: any = null;
                let resultDatadefault = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                resultdefault = ProblemDetails.fromJS(resultDatadefault);
                return throwException("A server side error occurred.", status, _responseText, _headers, resultdefault);
            }));
        }
    }

    register(command: RegisterCommand): Observable<HttpResultOfString> {
        let url_ = this.baseUrl + "/api/Accounts/Register";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_: any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_: any) => {
            return this.processRegister(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRegister(<any>response_);
                } catch (e) {
                    return <Observable<HttpResultOfString>><any>_observableThrow(e);
                }
            } else
                return <Observable<HttpResultOfString>><any>_observableThrow(response_);
        }));
    }

    protected processRegister(response: HttpResponseBase): Observable<HttpResultOfString> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
                (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } }
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result200: any = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = HttpResultOfString.fromJS(resultData200);
                return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result400: any = null;
                let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result400 = ProblemDetails.fromJS(resultData400);
                return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 422) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result422: any = null;
                let resultData422 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result422 = ValidationProblemDetails.fromJS(resultData422);
                return throwException("A server side error occurred.", status, _responseText, _headers, result422);
            }));
        } else {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let resultdefault: any = null;
                let resultDatadefault = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                resultdefault = ProblemDetails.fromJS(resultDatadefault);
                return throwException("A server side error occurred.", status, _responseText, _headers, resultdefault);
            }));
        }
    }

    externalLogin(command: ExternalLoginCommand): Observable<AuthResponse> {
        let url_ = this.baseUrl + "/api/Accounts/ExternalLogin";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_: any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_: any) => {
            return this.processExternalLogin(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processExternalLogin(<any>response_);
                } catch (e) {
                    return <Observable<AuthResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<AuthResponse>><any>_observableThrow(response_);
        }));
    }

    protected processExternalLogin(response: HttpResponseBase): Observable<AuthResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
                (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } }
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result200: any = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = AuthResponse.fromJS(resultData200);
                return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result404: any = null;
                let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result404 = ProblemDetails.fromJS(resultData404);
                return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result400: any = null;
                let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result400 = ProblemDetails.fromJS(resultData400);
                return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 422) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result422: any = null;
                let resultData422 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result422 = ValidationProblemDetails.fromJS(resultData422);
                return throwException("A server side error occurred.", status, _responseText, _headers, result422);
            }));
        } else {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let resultdefault: any = null;
                let resultDatadefault = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                resultdefault = ProblemDetails.fromJS(resultDatadefault);
                return throwException("A server side error occurred.", status, _responseText, _headers, resultdefault);
            }));
        }
    }

    externalRegistration(command: ExternalRegisterCommand): Observable<HttpResultOfString> {
        let url_ = this.baseUrl + "/api/Accounts/ExternalRegistration";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_: any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_: any) => {
            return this.processExternalRegistration(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processExternalRegistration(<any>response_);
                } catch (e) {
                    return <Observable<HttpResultOfString>><any>_observableThrow(e);
                }
            } else
                return <Observable<HttpResultOfString>><any>_observableThrow(response_);
        }));
    }

    protected processExternalRegistration(response: HttpResponseBase): Observable<HttpResultOfString> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
                (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } }
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result200: any = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = HttpResultOfString.fromJS(resultData200);
                return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result400: any = null;
                let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result400 = ProblemDetails.fromJS(resultData400);
                return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 422) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result422: any = null;
                let resultData422 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result422 = ValidationProblemDetails.fromJS(resultData422);
                return throwException("A server side error occurred.", status, _responseText, _headers, result422);
            }));
        } else {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let resultdefault: any = null;
                let resultDatadefault = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                resultdefault = ProblemDetails.fromJS(resultDatadefault);
                return throwException("A server side error occurred.", status, _responseText, _headers, resultdefault);
            }));
        }
    }

    resetPassword(command: ResetPasswordCommand): Observable<AuthResponse> {
        let url_ = this.baseUrl + "/api/Accounts/ResetPassword";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_: any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_: any) => {
            return this.processResetPassword(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processResetPassword(<any>response_);
                } catch (e) {
                    return <Observable<AuthResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<AuthResponse>><any>_observableThrow(response_);
        }));
    }

    protected processResetPassword(response: HttpResponseBase): Observable<AuthResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
                (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } }
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result200: any = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = AuthResponse.fromJS(resultData200);
                return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result404: any = null;
                let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result404 = ProblemDetails.fromJS(resultData404);
                return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result400: any = null;
                let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result400 = ProblemDetails.fromJS(resultData400);
                return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 422) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result422: any = null;
                let resultData422 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result422 = ValidationProblemDetails.fromJS(resultData422);
                return throwException("A server side error occurred.", status, _responseText, _headers, result422);
            }));
        } else {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let resultdefault: any = null;
                let resultDatadefault = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                resultdefault = ProblemDetails.fromJS(resultDatadefault);
                return throwException("A server side error occurred.", status, _responseText, _headers, resultdefault);
            }));
        }
    }

    confirmPhoneNumber(command: ConfirmPhoneNumberCommand): Observable<AuthResponse> {
        let url_ = this.baseUrl + "/api/Accounts/ConfirmPhoneNumber";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_: any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_: any) => {
            return this.processConfirmPhoneNumber(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processConfirmPhoneNumber(<any>response_);
                } catch (e) {
                    return <Observable<AuthResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<AuthResponse>><any>_observableThrow(response_);
        }));
    }

    protected processConfirmPhoneNumber(response: HttpResponseBase): Observable<AuthResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
                (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } }
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result200: any = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = AuthResponse.fromJS(resultData200);
                return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result404: any = null;
                let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result404 = ProblemDetails.fromJS(resultData404);
                return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result400: any = null;
                let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result400 = ProblemDetails.fromJS(resultData400);
                return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 422) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result422: any = null;
                let resultData422 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result422 = ValidationProblemDetails.fromJS(resultData422);
                return throwException("A server side error occurred.", status, _responseText, _headers, result422);
            }));
        } else {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let resultdefault: any = null;
                let resultDatadefault = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                resultdefault = ProblemDetails.fromJS(resultDatadefault);
                return throwException("A server side error occurred.", status, _responseText, _headers, resultdefault);
            }));
        }
    }

    confirmChangedPhoneNumber(command: ConfirmChangePhoneNumberCommand): Observable<void> {
        let url_ = this.baseUrl + "/api/Accounts/ConfirmChangedPhoneNumber";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_: any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_: any) => {
            return this.processConfirmChangedPhoneNumber(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processConfirmChangedPhoneNumber(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processConfirmChangedPhoneNumber(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
                (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } }
        if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return _observableOf<void>(<any>null);
            }));
        } else if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return _observableOf<void>(<any>null);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result404: any = null;
                let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result404 = ProblemDetails.fromJS(resultData404);
                return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result400: any = null;
                let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result400 = ProblemDetails.fromJS(resultData400);
                return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 422) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result422: any = null;
                let resultData422 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result422 = ValidationProblemDetails.fromJS(resultData422);
                return throwException("A server side error occurred.", status, _responseText, _headers, result422);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    resendConfirmationMessage(command: ResendPhoneNumberConfirmationCommand): Observable<void> {
        let url_ = this.baseUrl + "/api/Accounts/ResendConfirmationMessage";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_: any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_: any) => {
            return this.processResendConfirmationMessage(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processResendConfirmationMessage(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processResendConfirmationMessage(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
                (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } }
        if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return _observableOf<void>(<any>null);
            }));
        } else if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return _observableOf<void>(<any>null);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result404: any = null;
                let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result404 = ProblemDetails.fromJS(resultData404);
                return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result400: any = null;
                let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result400 = ProblemDetails.fromJS(resultData400);
                return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 422) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result422: any = null;
                let resultData422 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result422 = ValidationProblemDetails.fromJS(resultData422);
                return throwException("A server side error occurred.", status, _responseText, _headers, result422);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    forgetPassword(command: ForgetPasswordCommand): Observable<void> {
        let url_ = this.baseUrl + "/api/Accounts/ForgetPassword";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_: any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_: any) => {
            return this.processForgetPassword(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processForgetPassword(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processForgetPassword(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
                (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } }
        if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return _observableOf<void>(<any>null);
            }));
        } else if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return _observableOf<void>(<any>null);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result404: any = null;
                let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result404 = ProblemDetails.fromJS(resultData404);
                return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result400: any = null;
                let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result400 = ProblemDetails.fromJS(resultData400);
                return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 422) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result422: any = null;
                let resultData422 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result422 = ValidationProblemDetails.fromJS(resultData422);
                return throwException("A server side error occurred.", status, _responseText, _headers, result422);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    validateToken(command: ValidateResetPasswordToken): Observable<void> {
        let url_ = this.baseUrl + "/api/Accounts/ValidateToken";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_: any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_: any) => {
            return this.processValidateToken(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processValidateToken(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processValidateToken(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
                (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } }
        if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return _observableOf<void>(<any>null);
            }));
        } else if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return _observableOf<void>(<any>null);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result404: any = null;
                let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result404 = ProblemDetails.fromJS(resultData404);
                return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result400: any = null;
                let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result400 = ProblemDetails.fromJS(resultData400);
                return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 422) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result422: any = null;
                let resultData422 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result422 = ValidationProblemDetails.fromJS(resultData422);
                return throwException("A server side error occurred.", status, _responseText, _headers, result422);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    uploadPicture(userId: string | null | undefined, picture: FileParameter | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/Accounts/UploadPicture";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (userId !== null && userId !== undefined)
            content_.append("UserId", userId.toString());
        if (picture !== null && picture !== undefined)
            content_.append("Picture", picture.data, picture.fileName ? picture.fileName : "Picture");

        let options_: any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_: any) => {
            return this.processUploadPicture(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUploadPicture(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUploadPicture(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
                (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } }
        if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return _observableOf<void>(<any>null);
            }));
        } else if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return _observableOf<void>(<any>null);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result404: any = null;
                let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result404 = ProblemDetails.fromJS(resultData404);
                return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result400: any = null;
                let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result400 = ProblemDetails.fromJS(resultData400);
                return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 422) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result422: any = null;
                let resultData422 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result422 = ValidationProblemDetails.fromJS(resultData422);
                return throwException("A server side error occurred.", status, _responseText, _headers, result422);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    changeProfile(picture: FileParameter | null | undefined, email: string | null | undefined, fullName_FirstName: string | null | undefined, fullName_LastName: string | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/Accounts/ChangeProfile";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (picture !== null && picture !== undefined)
            content_.append("Picture", picture.data, picture.fileName ? picture.fileName : "Picture");
        if (email !== null && email !== undefined)
            content_.append("Email", email.toString());
        if (fullName_FirstName !== null && fullName_FirstName !== undefined)
            content_.append("FullName.FirstName", fullName_FirstName.toString());
        if (fullName_LastName !== null && fullName_LastName !== undefined)
            content_.append("FullName.LastName", fullName_LastName.toString());

        let options_: any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_: any) => {
            return this.processChangeProfile(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processChangeProfile(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processChangeProfile(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
                (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } }
        if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return _observableOf<void>(<any>null);
            }));
        } else if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return _observableOf<void>(<any>null);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result404: any = null;
                let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result404 = ProblemDetails.fromJS(resultData404);
                return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result400: any = null;
                let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result400 = ProblemDetails.fromJS(resultData400);
                return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 422) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result422: any = null;
                let resultData422 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result422 = ValidationProblemDetails.fromJS(resultData422);
                return throwException("A server side error occurred.", status, _responseText, _headers, result422);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    changePhoneNumber(command: ChangePhoneNumberCommand): Observable<void> {
        let url_ = this.baseUrl + "/api/Accounts/ChangePhoneNumber";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_: any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_: any) => {
            return this.processChangePhoneNumber(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processChangePhoneNumber(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processChangePhoneNumber(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
                (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } }
        if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return _observableOf<void>(<any>null);
            }));
        } else if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return _observableOf<void>(<any>null);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result404: any = null;
                let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result404 = ProblemDetails.fromJS(resultData404);
                return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result400: any = null;
                let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result400 = ProblemDetails.fromJS(resultData400);
                return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 422) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result422: any = null;
                let resultData422 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result422 = ValidationProblemDetails.fromJS(resultData422);
                return throwException("A server side error occurred.", status, _responseText, _headers, result422);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    changePassword(command: ChangePasswordCommand): Observable<void> {
        let url_ = this.baseUrl + "/api/Accounts/ChangePassword";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_: any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_: any) => {
            return this.processChangePassword(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processChangePassword(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processChangePassword(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
                (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } }
        if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return _observableOf<void>(<any>null);
            }));
        } else if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return _observableOf<void>(<any>null);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result404: any = null;
                let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result404 = ProblemDetails.fromJS(resultData404);
                return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result400: any = null;
                let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result400 = ProblemDetails.fromJS(resultData400);
                return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 422) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result422: any = null;
                let resultData422 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result422 = ValidationProblemDetails.fromJS(resultData422);
                return throwException("A server side error occurred.", status, _responseText, _headers, result422);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    changeLanguage(command: ChangeLanguageCommand): Observable<void> {
        let url_ = this.baseUrl + "/api/Accounts/ChangeLanguage";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_: any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_: any) => {
            return this.processChangeLanguage(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processChangeLanguage(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processChangeLanguage(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
                (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } }
        if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return _observableOf<void>(<any>null);
            }));
        } else if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return _observableOf<void>(<any>null);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result404: any = null;
                let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result404 = ProblemDetails.fromJS(resultData404);
                return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result400: any = null;
                let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result400 = ProblemDetails.fromJS(resultData400);
                return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 422) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result422: any = null;
                let resultData422 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result422 = ValidationProblemDetails.fromJS(resultData422);
                return throwException("A server side error occurred.", status, _responseText, _headers, result422);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    resetUserPassword(command: ResetUserPasswordCommand): Observable<void> {
        let url_ = this.baseUrl + "/api/Accounts/ResetUserPassword";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_: any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_: any) => {
            return this.processResetUserPassword(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processResetUserPassword(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processResetUserPassword(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
                (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } }
        if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return _observableOf<void>(<any>null);
            }));
        } else if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return _observableOf<void>(<any>null);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result404: any = null;
                let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result404 = ProblemDetails.fromJS(resultData404);
                return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result400: any = null;
                let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result400 = ProblemDetails.fromJS(resultData400);
                return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 422) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result422: any = null;
                let resultData422 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result422 = ValidationProblemDetails.fromJS(resultData422);
                return throwException("A server side error occurred.", status, _responseText, _headers, result422);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    endLockout(command: AccountsEndLockoutCommand): Observable<void> {
        let url_ = this.baseUrl + "/api/Accounts/EndLockout";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_: any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_: any) => {
            return this.processEndLockout(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processEndLockout(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processEndLockout(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
                (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } }
        if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return _observableOf<void>(<any>null);
            }));
        } else if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return _observableOf<void>(<any>null);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result404: any = null;
                let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result404 = ProblemDetails.fromJS(resultData404);
                return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result400: any = null;
                let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result400 = ProblemDetails.fromJS(resultData400);
                return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 422) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result422: any = null;
                let resultData422 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result422 = ValidationProblemDetails.fromJS(resultData422);
                return throwException("A server side error occurred.", status, _responseText, _headers, result422);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    ban(command: AccountsBanCommand): Observable<void> {
        let url_ = this.baseUrl + "/api/Accounts/Ban";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_: any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_: any) => {
            return this.processBan(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processBan(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processBan(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
                (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } }
        if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return _observableOf<void>(<any>null);
            }));
        } else if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return _observableOf<void>(<any>null);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result404: any = null;
                let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result404 = ProblemDetails.fromJS(resultData404);
                return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result400: any = null;
                let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result400 = ProblemDetails.fromJS(resultData400);
                return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 422) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result422: any = null;
                let resultData422 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result422 = ValidationProblemDetails.fromJS(resultData422);
                return throwException("A server side error occurred.", status, _responseText, _headers, result422);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    logout(): Observable<void> {
        let url_ = this.baseUrl + "/api/Accounts/Logout";
        url_ = url_.replace(/[?&]$/, "");

        let options_: any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_: any) => {
            return this.processLogout(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processLogout(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processLogout(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
                (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } }
        if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return _observableOf<void>(<any>null);
            }));
        } else if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return _observableOf<void>(<any>null);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result404: any = null;
                let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result404 = ProblemDetails.fromJS(resultData404);
                return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result400: any = null;
                let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result400 = ProblemDetails.fromJS(resultData400);
                return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 422) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result422: any = null;
                let resultData422 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result422 = ValidationProblemDetails.fromJS(resultData422);
                return throwException("A server side error occurred.", status, _responseText, _headers, result422);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

export interface IChatsClient {
    get(): Observable<ChatVm[]>;
    getMessages(chatId: string | undefined, offset: number | null | undefined, pageIndex: number | null | undefined, search: string | null | undefined, ascending: boolean | undefined, sortBy: string | null | undefined): Observable<PaginatedListOfMessageVm>;
    sendMessage(id: string | null | undefined, senderName: string | null | undefined, isWithSupport: boolean | undefined, receiverUsername: string | null | undefined, content: string | null | undefined, file: FileParameter | null | undefined, type: MessageType | undefined): Observable<HttpResultOfString>;
}

@Injectable({
    providedIn: 'root'
})
export class ChatsClient implements IChatsClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    get(): Observable<ChatVm[]> {
        let url_ = this.baseUrl + "/api/Chats";
        url_ = url_.replace(/[?&]$/, "");

        let options_: any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_: any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(<any>response_);
                } catch (e) {
                    return <Observable<ChatVm[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<ChatVm[]>><any>_observableThrow(response_);
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<ChatVm[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
                (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } }
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result200: any = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                if (Array.isArray(resultData200)) {
                    result200 = [] as any;
                    for (let item of resultData200)
                        result200!.push(ChatVm.fromJS(item));
                }
                else {
                    result200 = <any>null;
                }
                return _observableOf(result200);
            }));
        } else {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let resultdefault: any = null;
                let resultDatadefault = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                resultdefault = ProblemDetails.fromJS(resultDatadefault);
                return throwException("A server side error occurred.", status, _responseText, _headers, resultdefault);
            }));
        }
    }

    getMessages(chatId: string | undefined, offset: number | null | undefined, pageIndex: number | null | undefined, search: string | null | undefined, ascending: boolean | undefined, sortBy: string | null | undefined): Observable<PaginatedListOfMessageVm> {
        let url_ = this.baseUrl + "/api/Chats/GetMessages?";
        if (chatId === null)
            throw new Error("The parameter 'chatId' cannot be null.");
        else if (chatId !== undefined)
            url_ += "ChatId=" + encodeURIComponent("" + chatId) + "&";
        if (offset !== undefined && offset !== null)
            url_ += "Offset=" + encodeURIComponent("" + offset) + "&";
        if (pageIndex !== undefined && pageIndex !== null)
            url_ += "PageIndex=" + encodeURIComponent("" + pageIndex) + "&";
        if (search !== undefined && search !== null)
            url_ += "Search=" + encodeURIComponent("" + search) + "&";
        if (ascending === null)
            throw new Error("The parameter 'ascending' cannot be null.");
        else if (ascending !== undefined)
            url_ += "Ascending=" + encodeURIComponent("" + ascending) + "&";
        if (sortBy !== undefined && sortBy !== null)
            url_ += "SortBy=" + encodeURIComponent("" + sortBy) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_: any) => {
            return this.processGetMessages(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetMessages(<any>response_);
                } catch (e) {
                    return <Observable<PaginatedListOfMessageVm>><any>_observableThrow(e);
                }
            } else
                return <Observable<PaginatedListOfMessageVm>><any>_observableThrow(response_);
        }));
    }

    protected processGetMessages(response: HttpResponseBase): Observable<PaginatedListOfMessageVm> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
                (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } }
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result200: any = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = PaginatedListOfMessageVm.fromJS(resultData200);
                return _observableOf(result200);
            }));
        } else if (status === 422) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result422: any = null;
                let resultData422 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result422 = ValidationProblemDetails.fromJS(resultData422);
                return throwException("A server side error occurred.", status, _responseText, _headers, result422);
            }));
        } else {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let resultdefault: any = null;
                let resultDatadefault = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                resultdefault = ProblemDetails.fromJS(resultDatadefault);
                return throwException("A server side error occurred.", status, _responseText, _headers, resultdefault);
            }));
        }
    }

    sendMessage(id: string | null | undefined, senderName: string | null | undefined, isWithSupport: boolean | undefined, receiverUsername: string | null | undefined, content: string | null | undefined, file: FileParameter | null | undefined, type: MessageType | undefined): Observable<HttpResultOfString> {
        let url_ = this.baseUrl + "/api/Chats/SendMessage";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (id !== null && id !== undefined)
            content_.append("Id", id.toString());
        if (senderName !== null && senderName !== undefined)
            content_.append("SenderName", senderName.toString());
        if (isWithSupport === null || isWithSupport === undefined)
            throw new Error("The parameter 'isWithSupport' cannot be null.");
        else
            content_.append("IsWithSupport", isWithSupport.toString());
        if (receiverUsername !== null && receiverUsername !== undefined)
            content_.append("ReceiverUsername", receiverUsername.toString());
        if (content !== null && content !== undefined)
            content_.append("Content", content.toString());
        if (file !== null && file !== undefined)
            content_.append("File", file.data, file.fileName ? file.fileName : "File");
        if (type === null || type === undefined)
            throw new Error("The parameter 'type' cannot be null.");
        else
            content_.append("Type", type.toString());

        let options_: any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_: any) => {
            return this.processSendMessage(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSendMessage(<any>response_);
                } catch (e) {
                    return <Observable<HttpResultOfString>><any>_observableThrow(e);
                }
            } else
                return <Observable<HttpResultOfString>><any>_observableThrow(response_);
        }));
    }

    protected processSendMessage(response: HttpResponseBase): Observable<HttpResultOfString> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
                (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } }
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result200: any = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = HttpResultOfString.fromJS(resultData200);
                return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result404: any = null;
                let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result404 = ProblemDetails.fromJS(resultData404);
                return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result400: any = null;
                let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result400 = ProblemDetails.fromJS(resultData400);
                return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 422) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result422: any = null;
                let resultData422 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result422 = ValidationProblemDetails.fromJS(resultData422);
                return throwException("A server side error occurred.", status, _responseText, _headers, result422);
            }));
        } else {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let resultdefault: any = null;
                let resultDatadefault = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                resultdefault = ProblemDetails.fromJS(resultDatadefault);
                return throwException("A server side error occurred.", status, _responseText, _headers, resultdefault);
            }));
        }
    }
}

export interface ICommonQuestionsClient {
    get(id: number | undefined): Observable<CommonQuestion>;
    post(command: CommonQuestionPostCommand): Observable<HttpResultOfInteger>;
    put(command: CommonQuestionPutCommand): Observable<void>;
    delete(id: number | undefined): Observable<void>;
    getList(query: CommonQuestionGetListQuery | null | undefined): Observable<CommonQuestion[]>;
    getPage(): Observable<PaginatedListOfCommonQuestionVm>;
    putOrder(command: CommonQuestionPutOrderCommand): Observable<void>;
}

@Injectable({
    providedIn: 'root'
})
export class CommonQuestionsClient implements ICommonQuestionsClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    get(id: number | undefined): Observable<CommonQuestion> {
        let url_ = this.baseUrl + "/api/CommonQuestions?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_: any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(<any>response_);
                } catch (e) {
                    return <Observable<CommonQuestion>><any>_observableThrow(e);
                }
            } else
                return <Observable<CommonQuestion>><any>_observableThrow(response_);
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<CommonQuestion> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
                (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } }
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result200: any = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = CommonQuestion.fromJS(resultData200);
                return _observableOf(result200);
            }));
        } else if (status === 422) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result422: any = null;
                let resultData422 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result422 = ValidationProblemDetails.fromJS(resultData422);
                return throwException("A server side error occurred.", status, _responseText, _headers, result422);
            }));
        } else {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let resultdefault: any = null;
                let resultDatadefault = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                resultdefault = ProblemDetails.fromJS(resultDatadefault);
                return throwException("A server side error occurred.", status, _responseText, _headers, resultdefault);
            }));
        }
    }

    post(command: CommonQuestionPostCommand): Observable<HttpResultOfInteger> {
        let url_ = this.baseUrl + "/api/CommonQuestions";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_: any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_: any) => {
            return this.processPost(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPost(<any>response_);
                } catch (e) {
                    return <Observable<HttpResultOfInteger>><any>_observableThrow(e);
                }
            } else
                return <Observable<HttpResultOfInteger>><any>_observableThrow(response_);
        }));
    }

    protected processPost(response: HttpResponseBase): Observable<HttpResultOfInteger> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
                (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } }
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result200: any = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = HttpResultOfInteger.fromJS(resultData200);
                return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result404: any = null;
                let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result404 = ProblemDetails.fromJS(resultData404);
                return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result400: any = null;
                let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result400 = ProblemDetails.fromJS(resultData400);
                return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 422) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result422: any = null;
                let resultData422 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result422 = ValidationProblemDetails.fromJS(resultData422);
                return throwException("A server side error occurred.", status, _responseText, _headers, result422);
            }));
        } else {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let resultdefault: any = null;
                let resultDatadefault = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                resultdefault = ProblemDetails.fromJS(resultDatadefault);
                return throwException("A server side error occurred.", status, _responseText, _headers, resultdefault);
            }));
        }
    }

    put(command: CommonQuestionPutCommand): Observable<void> {
        let url_ = this.baseUrl + "/api/CommonQuestions";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_: any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_: any) => {
            return this.processPut(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPut(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processPut(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
                (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } }
        if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return _observableOf<void>(<any>null);
            }));
        } else if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return _observableOf<void>(<any>null);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result404: any = null;
                let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result404 = ProblemDetails.fromJS(resultData404);
                return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result400: any = null;
                let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result400 = ProblemDetails.fromJS(resultData400);
                return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 422) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result422: any = null;
                let resultData422 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result422 = ValidationProblemDetails.fromJS(resultData422);
                return throwException("A server side error occurred.", status, _responseText, _headers, result422);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    delete(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/CommonQuestions?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_: any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
                (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } }
        if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return _observableOf<void>(<any>null);
            }));
        } else if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return _observableOf<void>(<any>null);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result404: any = null;
                let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result404 = ProblemDetails.fromJS(resultData404);
                return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result400: any = null;
                let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result400 = ProblemDetails.fromJS(resultData400);
                return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 422) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result422: any = null;
                let resultData422 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result422 = ValidationProblemDetails.fromJS(resultData422);
                return throwException("A server side error occurred.", status, _responseText, _headers, result422);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    getList(query: CommonQuestionGetListQuery | null | undefined): Observable<CommonQuestion[]> {
        let url_ = this.baseUrl + "/api/CommonQuestions/GetList?";
        if (query !== undefined && query !== null)
            url_ += "query=" + encodeURIComponent("" + query) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_: any) => {
            return this.processGetList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetList(<any>response_);
                } catch (e) {
                    return <Observable<CommonQuestion[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<CommonQuestion[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetList(response: HttpResponseBase): Observable<CommonQuestion[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
                (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } }
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result200: any = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                if (Array.isArray(resultData200)) {
                    result200 = [] as any;
                    for (let item of resultData200)
                        result200!.push(CommonQuestion.fromJS(item));
                }
                else {
                    result200 = <any>null;
                }
                return _observableOf(result200);
            }));
        } else if (status === 422) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result422: any = null;
                let resultData422 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result422 = ValidationProblemDetails.fromJS(resultData422);
                return throwException("A server side error occurred.", status, _responseText, _headers, result422);
            }));
        } else {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let resultdefault: any = null;
                let resultDatadefault = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                resultdefault = ProblemDetails.fromJS(resultDatadefault);
                return throwException("A server side error occurred.", status, _responseText, _headers, resultdefault);
            }));
        }
    }

    getPage(): Observable<PaginatedListOfCommonQuestionVm> {
        let url_ = this.baseUrl + "/api/CommonQuestions/GetPage";
        url_ = url_.replace(/[?&]$/, "");

        let options_: any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_: any) => {
            return this.processGetPage(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPage(<any>response_);
                } catch (e) {
                    return <Observable<PaginatedListOfCommonQuestionVm>><any>_observableThrow(e);
                }
            } else
                return <Observable<PaginatedListOfCommonQuestionVm>><any>_observableThrow(response_);
        }));
    }

    protected processGetPage(response: HttpResponseBase): Observable<PaginatedListOfCommonQuestionVm> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
                (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } }
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result200: any = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = PaginatedListOfCommonQuestionVm.fromJS(resultData200);
                return _observableOf(result200);
            }));
        } else {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let resultdefault: any = null;
                let resultDatadefault = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                resultdefault = ProblemDetails.fromJS(resultDatadefault);
                return throwException("A server side error occurred.", status, _responseText, _headers, resultdefault);
            }));
        }
    }

    putOrder(command: CommonQuestionPutOrderCommand): Observable<void> {
        let url_ = this.baseUrl + "/api/CommonQuestions/PutOrder";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_: any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_: any) => {
            return this.processPutOrder(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPutOrder(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processPutOrder(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
                (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } }
        if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return _observableOf<void>(<any>null);
            }));
        } else if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return _observableOf<void>(<any>null);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result404: any = null;
                let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result404 = ProblemDetails.fromJS(resultData404);
                return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result400: any = null;
                let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result400 = ProblemDetails.fromJS(resultData400);
                return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 422) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result422: any = null;
                let resultData422 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result422 = ValidationProblemDetails.fromJS(resultData422);
                return throwException("A server side error occurred.", status, _responseText, _headers, result422);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

export interface IContentsClient {
    getTnc(): Observable<ContentVm>;
    getPnp(): Observable<ContentVm>;
    get(lang: Language | undefined, type: ContentType | undefined): Observable<ContentVm>;
    put(command: ContentsPutCommand): Observable<void>;
}

@Injectable({
    providedIn: 'root'
})
export class ContentsClient implements IContentsClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    getTnc(): Observable<ContentVm> {
        let url_ = this.baseUrl + "/api/Contents/GetTnc";
        url_ = url_.replace(/[?&]$/, "");

        let options_: any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_: any) => {
            return this.processGetTnc(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTnc(<any>response_);
                } catch (e) {
                    return <Observable<ContentVm>><any>_observableThrow(e);
                }
            } else
                return <Observable<ContentVm>><any>_observableThrow(response_);
        }));
    }

    protected processGetTnc(response: HttpResponseBase): Observable<ContentVm> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
                (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } }
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result200: any = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = ContentVm.fromJS(resultData200);
                return _observableOf(result200);
            }));
        } else {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let resultdefault: any = null;
                let resultDatadefault = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                resultdefault = ProblemDetails.fromJS(resultDatadefault);
                return throwException("A server side error occurred.", status, _responseText, _headers, resultdefault);
            }));
        }
    }

    getPnp(): Observable<ContentVm> {
        let url_ = this.baseUrl + "/api/Contents/GetPnp";
        url_ = url_.replace(/[?&]$/, "");

        let options_: any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_: any) => {
            return this.processGetPnp(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPnp(<any>response_);
                } catch (e) {
                    return <Observable<ContentVm>><any>_observableThrow(e);
                }
            } else
                return <Observable<ContentVm>><any>_observableThrow(response_);
        }));
    }

    protected processGetPnp(response: HttpResponseBase): Observable<ContentVm> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
                (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } }
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result200: any = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = ContentVm.fromJS(resultData200);
                return _observableOf(result200);
            }));
        } else {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let resultdefault: any = null;
                let resultDatadefault = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                resultdefault = ProblemDetails.fromJS(resultDatadefault);
                return throwException("A server side error occurred.", status, _responseText, _headers, resultdefault);
            }));
        }
    }

    get(lang: Language | undefined, type: ContentType | undefined): Observable<ContentVm> {
        let url_ = this.baseUrl + "/api/Contents?";
        if (lang === null)
            throw new Error("The parameter 'lang' cannot be null.");
        else if (lang !== undefined)
            url_ += "Lang=" + encodeURIComponent("" + lang) + "&";
        if (type === null)
            throw new Error("The parameter 'type' cannot be null.");
        else if (type !== undefined)
            url_ += "Type=" + encodeURIComponent("" + type) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_: any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(<any>response_);
                } catch (e) {
                    return <Observable<ContentVm>><any>_observableThrow(e);
                }
            } else
                return <Observable<ContentVm>><any>_observableThrow(response_);
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<ContentVm> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
                (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } }
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result200: any = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = ContentVm.fromJS(resultData200);
                return _observableOf(result200);
            }));
        } else if (status === 422) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result422: any = null;
                let resultData422 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result422 = ValidationProblemDetails.fromJS(resultData422);
                return throwException("A server side error occurred.", status, _responseText, _headers, result422);
            }));
        } else {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let resultdefault: any = null;
                let resultDatadefault = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                resultdefault = ProblemDetails.fromJS(resultDatadefault);
                return throwException("A server side error occurred.", status, _responseText, _headers, resultdefault);
            }));
        }
    }

    put(command: ContentsPutCommand): Observable<void> {
        let url_ = this.baseUrl + "/api/Contents/Put";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_: any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_: any) => {
            return this.processPut(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPut(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processPut(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
                (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } }
        if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return _observableOf<void>(<any>null);
            }));
        } else if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return _observableOf<void>(<any>null);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result404: any = null;
                let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result404 = ProblemDetails.fromJS(resultData404);
                return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result400: any = null;
                let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result400 = ProblemDetails.fromJS(resultData400);
                return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 422) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result422: any = null;
                let resultData422 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result422 = ValidationProblemDetails.fromJS(resultData422);
                return throwException("A server side error occurred.", status, _responseText, _headers, result422);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

export interface ICountriesClient {
    get(id: number | undefined): Observable<CountryDto>;
    post(command: CountriesPostCommand): Observable<HttpResultOfInteger>;
    put(command: CountriesPutCommand): Observable<void>;
    delete(id: number | undefined): Observable<void>;
    getPage(): Observable<CountryDto[]>;
    getList(): Observable<CountryVm[]>;
    getListAll(): Observable<FullCountryVm[]>;
    putOrder(command: CountriesPutOrderCommand): Observable<void>;
}

@Injectable({
    providedIn: 'root'
})
export class CountriesClient implements ICountriesClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    get(id: number | undefined): Observable<CountryDto> {
        let url_ = this.baseUrl + "/api/Countries?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_: any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(<any>response_);
                } catch (e) {
                    return <Observable<CountryDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<CountryDto>><any>_observableThrow(response_);
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<CountryDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
                (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } }
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result200: any = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = CountryDto.fromJS(resultData200);
                return _observableOf(result200);
            }));
        } else if (status === 422) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result422: any = null;
                let resultData422 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result422 = ValidationProblemDetails.fromJS(resultData422);
                return throwException("A server side error occurred.", status, _responseText, _headers, result422);
            }));
        } else {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let resultdefault: any = null;
                let resultDatadefault = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                resultdefault = ProblemDetails.fromJS(resultDatadefault);
                return throwException("A server side error occurred.", status, _responseText, _headers, resultdefault);
            }));
        }
    }

    post(command: CountriesPostCommand): Observable<HttpResultOfInteger> {
        let url_ = this.baseUrl + "/api/Countries";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_: any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_: any) => {
            return this.processPost(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPost(<any>response_);
                } catch (e) {
                    return <Observable<HttpResultOfInteger>><any>_observableThrow(e);
                }
            } else
                return <Observable<HttpResultOfInteger>><any>_observableThrow(response_);
        }));
    }

    protected processPost(response: HttpResponseBase): Observable<HttpResultOfInteger> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
                (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } }
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result200: any = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = HttpResultOfInteger.fromJS(resultData200);
                return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result404: any = null;
                let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result404 = ProblemDetails.fromJS(resultData404);
                return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result400: any = null;
                let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result400 = ProblemDetails.fromJS(resultData400);
                return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 422) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result422: any = null;
                let resultData422 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result422 = ValidationProblemDetails.fromJS(resultData422);
                return throwException("A server side error occurred.", status, _responseText, _headers, result422);
            }));
        } else {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let resultdefault: any = null;
                let resultDatadefault = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                resultdefault = ProblemDetails.fromJS(resultDatadefault);
                return throwException("A server side error occurred.", status, _responseText, _headers, resultdefault);
            }));
        }
    }

    put(command: CountriesPutCommand): Observable<void> {
        let url_ = this.baseUrl + "/api/Countries";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_: any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_: any) => {
            return this.processPut(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPut(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processPut(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
                (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } }
        if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return _observableOf<void>(<any>null);
            }));
        } else if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return _observableOf<void>(<any>null);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result404: any = null;
                let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result404 = ProblemDetails.fromJS(resultData404);
                return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result400: any = null;
                let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result400 = ProblemDetails.fromJS(resultData400);
                return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 422) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result422: any = null;
                let resultData422 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result422 = ValidationProblemDetails.fromJS(resultData422);
                return throwException("A server side error occurred.", status, _responseText, _headers, result422);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    delete(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/Countries?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_: any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
                (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } }
        if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return _observableOf<void>(<any>null);
            }));
        } else if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return _observableOf<void>(<any>null);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result404: any = null;
                let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result404 = ProblemDetails.fromJS(resultData404);
                return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result400: any = null;
                let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result400 = ProblemDetails.fromJS(resultData400);
                return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 422) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result422: any = null;
                let resultData422 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result422 = ValidationProblemDetails.fromJS(resultData422);
                return throwException("A server side error occurred.", status, _responseText, _headers, result422);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    getPage(): Observable<CountryDto[]> {
        let url_ = this.baseUrl + "/api/Countries/GetPage";
        url_ = url_.replace(/[?&]$/, "");

        let options_: any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_: any) => {
            return this.processGetPage(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPage(<any>response_);
                } catch (e) {
                    return <Observable<CountryDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<CountryDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetPage(response: HttpResponseBase): Observable<CountryDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
                (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } }
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result200: any = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                if (Array.isArray(resultData200)) {
                    result200 = [] as any;
                    for (let item of resultData200)
                        result200!.push(CountryDto.fromJS(item));
                }
                else {
                    result200 = <any>null;
                }
                return _observableOf(result200);
            }));
        } else {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let resultdefault: any = null;
                let resultDatadefault = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                resultdefault = ProblemDetails.fromJS(resultDatadefault);
                return throwException("A server side error occurred.", status, _responseText, _headers, resultdefault);
            }));
        }
    }

    getList(): Observable<CountryVm[]> {
        let url_ = this.baseUrl + "/api/Countries/GetList";
        url_ = url_.replace(/[?&]$/, "");

        let options_: any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_: any) => {
            return this.processGetList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetList(<any>response_);
                } catch (e) {
                    return <Observable<CountryVm[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<CountryVm[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetList(response: HttpResponseBase): Observable<CountryVm[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
                (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } }
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result200: any = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                if (Array.isArray(resultData200)) {
                    result200 = [] as any;
                    for (let item of resultData200)
                        result200!.push(CountryVm.fromJS(item));
                }
                else {
                    result200 = <any>null;
                }
                return _observableOf(result200);
            }));
        } else {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let resultdefault: any = null;
                let resultDatadefault = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                resultdefault = ProblemDetails.fromJS(resultDatadefault);
                return throwException("A server side error occurred.", status, _responseText, _headers, resultdefault);
            }));
        }
    }

    getListAll(): Observable<FullCountryVm[]> {
        let url_ = this.baseUrl + "/api/Countries/GetListAll";
        url_ = url_.replace(/[?&]$/, "");

        let options_: any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_: any) => {
            return this.processGetListAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetListAll(<any>response_);
                } catch (e) {
                    return <Observable<FullCountryVm[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<FullCountryVm[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetListAll(response: HttpResponseBase): Observable<FullCountryVm[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
                (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } }
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result200: any = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                if (Array.isArray(resultData200)) {
                    result200 = [] as any;
                    for (let item of resultData200)
                        result200!.push(FullCountryVm.fromJS(item));
                }
                else {
                    result200 = <any>null;
                }
                return _observableOf(result200);
            }));
        } else {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let resultdefault: any = null;
                let resultDatadefault = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                resultdefault = ProblemDetails.fromJS(resultDatadefault);
                return throwException("A server side error occurred.", status, _responseText, _headers, resultdefault);
            }));
        }
    }

    putOrder(command: CountriesPutOrderCommand): Observable<void> {
        let url_ = this.baseUrl + "/api/Countries/PutOrder";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_: any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_: any) => {
            return this.processPutOrder(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPutOrder(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processPutOrder(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
                (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } }
        if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return _observableOf<void>(<any>null);
            }));
        } else if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return _observableOf<void>(<any>null);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result404: any = null;
                let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result404 = ProblemDetails.fromJS(resultData404);
                return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result400: any = null;
                let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result400 = ProblemDetails.fromJS(resultData400);
                return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 422) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result422: any = null;
                let resultData422 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result422 = ValidationProblemDetails.fromJS(resultData422);
                return throwException("A server side error occurred.", status, _responseText, _headers, result422);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

export interface IFormsClient {
    get(id: number): Observable<FormDto>;
    getPage(offset: number | null | undefined, pageIndex: number | null | undefined, search: string | null | undefined, ascending: boolean | undefined, sortBy: string | null | undefined): Observable<PaginatedListOfFormVmForDashboard>;
    post(name_Ar: string | null | undefined, name_En: string | null | undefined, description_Ar: string | null | undefined, description_En: string | null | undefined, realStateId: number | undefined, type: RequestType | undefined, regionId: number | undefined, fields: DataFieldDto[] | null | undefined): Observable<HttpResultOfLong>;
    put(id: number | undefined, name_Ar: string | null | undefined, name_En: string | null | undefined, description_Ar: string | null | undefined, description_En: string | null | undefined, realStateId: number | undefined, type: RequestType | undefined, regionId: number | undefined, fields: DataFieldDto[] | null | undefined): Observable<void>;
    delete(id: number | undefined): Observable<void>;
}

@Injectable({
    providedIn: 'root'
})
export class FormsClient implements IFormsClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    get(id: number): Observable<FormDto> {
        let url_ = this.baseUrl + "/api/Forms/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_: any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(<any>response_);
                } catch (e) {
                    return <Observable<FormDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<FormDto>><any>_observableThrow(response_);
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<FormDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
                (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } }
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result200: any = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = FormDto.fromJS(resultData200);
                return _observableOf(result200);
            }));
        } else if (status === 422) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result422: any = null;
                let resultData422 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result422 = ValidationProblemDetails.fromJS(resultData422);
                return throwException("A server side error occurred.", status, _responseText, _headers, result422);
            }));
        } else {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let resultdefault: any = null;
                let resultDatadefault = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                resultdefault = ProblemDetails.fromJS(resultDatadefault);
                return throwException("A server side error occurred.", status, _responseText, _headers, resultdefault);
            }));
        }
    }

    getPage(offset: number | null | undefined, pageIndex: number | null | undefined, search: string | null | undefined, ascending: boolean | undefined, sortBy: string | null | undefined): Observable<PaginatedListOfFormVmForDashboard> {
        let url_ = this.baseUrl + "/api/Forms/GetPage?";
        if (offset !== undefined && offset !== null)
            url_ += "Offset=" + encodeURIComponent("" + offset) + "&";
        if (pageIndex !== undefined && pageIndex !== null)
            url_ += "PageIndex=" + encodeURIComponent("" + pageIndex) + "&";
        if (search !== undefined && search !== null)
            url_ += "Search=" + encodeURIComponent("" + search) + "&";
        if (ascending === null)
            throw new Error("The parameter 'ascending' cannot be null.");
        else if (ascending !== undefined)
            url_ += "Ascending=" + encodeURIComponent("" + ascending) + "&";
        if (sortBy !== undefined && sortBy !== null)
            url_ += "SortBy=" + encodeURIComponent("" + sortBy) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_: any) => {
            return this.processGetPage(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPage(<any>response_);
                } catch (e) {
                    return <Observable<PaginatedListOfFormVmForDashboard>><any>_observableThrow(e);
                }
            } else
                return <Observable<PaginatedListOfFormVmForDashboard>><any>_observableThrow(response_);
        }));
    }

    protected processGetPage(response: HttpResponseBase): Observable<PaginatedListOfFormVmForDashboard> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
                (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } }
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result200: any = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = PaginatedListOfFormVmForDashboard.fromJS(resultData200);
                return _observableOf(result200);
            }));
        } else if (status === 422) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result422: any = null;
                let resultData422 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result422 = ValidationProblemDetails.fromJS(resultData422);
                return throwException("A server side error occurred.", status, _responseText, _headers, result422);
            }));
        } else {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let resultdefault: any = null;
                let resultDatadefault = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                resultdefault = ProblemDetails.fromJS(resultDatadefault);
                return throwException("A server side error occurred.", status, _responseText, _headers, resultdefault);
            }));
        }
    }

    post(name_Ar: string | null | undefined, name_En: string | null | undefined, description_Ar: string | null | undefined, description_En: string | null | undefined, realStateId: number | undefined, type: RequestType | undefined, regionId: number | undefined, fields: DataFieldDto[] | null | undefined): Observable<HttpResultOfLong> {
        let url_ = this.baseUrl + "/api/Forms";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (name_Ar !== null && name_Ar !== undefined)
            content_.append("Name.Ar", name_Ar.toString());
        if (name_En !== null && name_En !== undefined)
            content_.append("Name.En", name_En.toString());
        if (description_Ar !== null && description_Ar !== undefined)
            content_.append("Description.Ar", description_Ar.toString());
        if (description_En !== null && description_En !== undefined)
            content_.append("Description.En", description_En.toString());
        if (realStateId === null || realStateId === undefined)
            throw new Error("The parameter 'realStateId' cannot be null.");
        else
            content_.append("RealStateId", realStateId.toString());
        if (type === null || type === undefined)
            throw new Error("The parameter 'type' cannot be null.");
        else
            content_.append("Type", type.toString());
        if (regionId === null || regionId === undefined)
            throw new Error("The parameter 'regionId' cannot be null.");
        else
            content_.append("RegionId", regionId.toString());
        if (fields !== null && fields !== undefined) {
            fields.forEach((item_, index_) => {

                if (item_.name) {
                    content_.append(`Fields[${index_}].name.ar`, item_.name.ar.toString())
                }
                if (item_.name) {
                    content_.append(`Fields[${index_}].name.en`, item_.name.en.toString())
                }
                if (item_.placeholder) {
                    content_.append(`Fields[${index_}].placeholder.ar`, item_.placeholder.ar.toString())
                }
                if (item_.placeholder) {
                    content_.append(`Fields[${index_}].placeholder.en`, item_.placeholder.en.toString())
                }

                if (item_.orders) {
                    content_.append(`Fields[${index_}].orders`, item_.orders.toString())
                }
                if (item_.code) {
                    content_.append(`Fields[${index_}].code`, item_.code.toString())
                }
                if (item_.equation) {
                    content_.append(`Fields[${index_}].equation`, item_.equation.toString())
                }
                if (item_.regex) {
                    content_.append(`Fields[${index_}].regex`, item_.regex.toString())
                }
                if (item_.isRequired) {
                    content_.append(`Fields[${index_}].isRequired`, item_.isRequired.toString())
                }
                if (item_.fieldType) {
                    content_.append(`Fields[${index_}].fieldType`, item_.fieldType.toString())
                }
                if (item_.dataValues) {
                    if(item_.dataValues !== null && item_.dataValues !== undefined && item_.fieldType ==FieldType.Radio || item_.fieldType ==FieldType.CheckBox || item_.fieldType ==FieldType.Select){
                        item_.dataValues.forEach((valueItem, index__)=>{
                            if (valueItem.value) {
                                content_.append(`Fields[${index_}].dataValues[${index__}].value.ar`, valueItem.value.ar.toString())
                            }
                            if (valueItem.value) {
                                content_.append(`Fields[${index_}].dataValues[${index__}].value.en`, valueItem.value.en.toString())
                            }
                        })
                    }
                }

            });
        }

        let options_: any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_: any) => {
            return this.processPost(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPost(<any>response_);
                } catch (e) {
                    return <Observable<HttpResultOfLong>><any>_observableThrow(e);
                }
            } else
                return <Observable<HttpResultOfLong>><any>_observableThrow(response_);
        }));
    }

    protected processPost(response: HttpResponseBase): Observable<HttpResultOfLong> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
                (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } }
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result200: any = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = HttpResultOfLong.fromJS(resultData200);
                return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result400: any = null;
                let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result400 = ProblemDetails.fromJS(resultData400);
                return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 422) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result422: any = null;
                let resultData422 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result422 = ValidationProblemDetails.fromJS(resultData422);
                return throwException("A server side error occurred.", status, _responseText, _headers, result422);
            }));
        } else {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let resultdefault: any = null;
                let resultDatadefault = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                resultdefault = ProblemDetails.fromJS(resultDatadefault);
                return throwException("A server side error occurred.", status, _responseText, _headers, resultdefault);
            }));
        }
    }

    put(id: number | undefined, name_Ar: string | null | undefined, name_En: string | null | undefined, description_Ar: string | null | undefined, description_En: string | null | undefined, realStateId: number | undefined, type: RequestType | undefined, regionId: number | undefined, fields: DataFieldDto[] | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/Forms";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (id === null || id === undefined)
            throw new Error("The parameter 'id' cannot be null.");
        else
            content_.append("Id", id.toString());
        if (name_Ar !== null && name_Ar !== undefined)
            content_.append("Name.Ar", name_Ar.toString());
        if (name_En !== null && name_En !== undefined)
            content_.append("Name.En", name_En.toString());
        if (description_Ar !== null && description_Ar !== undefined)
            content_.append("Description.Ar", description_Ar.toString());
        if (description_En !== null && description_En !== undefined)
            content_.append("Description.En", description_En.toString());
        if (realStateId === null || realStateId === undefined)
            throw new Error("The parameter 'realStateId' cannot be null.");
        else
            content_.append("RealStateId", realStateId.toString());
        if (type === null || type === undefined)
            throw new Error("The parameter 'type' cannot be null.");
        else
            content_.append("Type", type.toString());
        if (regionId === null || regionId === undefined)
            throw new Error("The parameter 'regionId' cannot be null.");
        else
            content_.append("RegionId", regionId.toString());
        if (fields !== null && fields !== undefined) {
            fields.forEach((item_, index_) => {

                if (item_.name) {
                    content_.append(`Fields[${index_}].name.ar`, item_.name.ar.toString())
                }
                if (item_.name) {
                    content_.append(`Fields[${index_}].name.en`, item_.name.en.toString())
                }
                if (item_.placeholder) {
                    content_.append(`Fields[${index_}].placeholder.ar`, item_.placeholder.ar.toString())
                }
                if (item_.placeholder) {
                    content_.append(`Fields[${index_}].placeholder.en`, item_.placeholder.en.toString())
                }

                if (item_.orders) {
                    content_.append(`Fields[${index_}].orders`, item_.orders.toString())
                }
                if (item_.code) {
                    content_.append(`Fields[${index_}].code`, item_.code.toString())
                }
                if (item_.equation) {
                    content_.append(`Fields[${index_}].equation`, item_.equation.toString())
                }
                if (item_.regex) {
                    content_.append(`Fields[${index_}].regex`, item_.regex.toString())
                }
                if (item_.isRequired) {
                    content_.append(`Fields[${index_}].isRequired`, item_.isRequired.toString())
                }
                if (item_.fieldType) {
                    content_.append(`Fields[${index_}].fieldType`, item_.fieldType.toString())
                }
                if (item_.dataValues) {
                    if(item_.dataValues !== null && item_.dataValues !== undefined && item_.fieldType ==FieldType.Radio || item_.fieldType ==FieldType.CheckBox || item_.fieldType ==FieldType.Select){
                        item_.dataValues.forEach((valueItem, index__)=>{
                            if (valueItem.value) {
                                content_.append(`Fields[${index_}].dataValues[${index__}].value.ar`, valueItem.value.ar.toString())
                            }
                            if (valueItem.value) {
                                content_.append(`Fields[${index_}].dataValues[${index__}].value.en`, valueItem.value.en.toString())
                            }
                        })
                    }
                }

            });
        }

        let options_: any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_: any) => {
            return this.processPut(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPut(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processPut(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
                (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } }
        if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return _observableOf<void>(<any>null);
            }));
        } else if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return _observableOf<void>(<any>null);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result404: any = null;
                let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result404 = ProblemDetails.fromJS(resultData404);
                return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result400: any = null;
                let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result400 = ProblemDetails.fromJS(resultData400);
                return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 422) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result422: any = null;
                let resultData422 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result422 = ValidationProblemDetails.fromJS(resultData422);
                return throwException("A server side error occurred.", status, _responseText, _headers, result422);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    delete(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/Forms?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_: any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
                (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } }
        if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return _observableOf<void>(<any>null);
            }));
        } else if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return _observableOf<void>(<any>null);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result404: any = null;
                let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result404 = ProblemDetails.fromJS(resultData404);
                return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result400: any = null;
                let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result400 = ProblemDetails.fromJS(resultData400);
                return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 422) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result422: any = null;
                let resultData422 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result422 = ValidationProblemDetails.fromJS(resultData422);
                return throwException("A server side error occurred.", status, _responseText, _headers, result422);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

export interface IPlansClient {
    getPage(offset: number | null | undefined, pageIndex: number | null | undefined, search: string | null | undefined, ascending: boolean | undefined, sortBy: string | null | undefined): Observable<PaginatedListOfPlanVmForDashborad>;
    post(command: PlansPostCommand): Observable<HttpResultOfLong>;
    put(command: PlansPutCommand): Observable<void>;
    delete(id: number | undefined): Observable<void>;
}

@Injectable({
    providedIn: 'root'
})
export class PlansClient implements IPlansClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    getPage(offset: number | null | undefined, pageIndex: number | null | undefined, search: string | null | undefined, ascending: boolean | undefined, sortBy: string | null | undefined): Observable<PaginatedListOfPlanVmForDashborad> {
        let url_ = this.baseUrl + "/api/Plans/GetPage?";
        if (offset !== undefined && offset !== null)
            url_ += "Offset=" + encodeURIComponent("" + offset) + "&";
        if (pageIndex !== undefined && pageIndex !== null)
            url_ += "PageIndex=" + encodeURIComponent("" + pageIndex) + "&";
        if (search !== undefined && search !== null)
            url_ += "Search=" + encodeURIComponent("" + search) + "&";
        if (ascending === null)
            throw new Error("The parameter 'ascending' cannot be null.");
        else if (ascending !== undefined)
            url_ += "Ascending=" + encodeURIComponent("" + ascending) + "&";
        if (sortBy !== undefined && sortBy !== null)
            url_ += "SortBy=" + encodeURIComponent("" + sortBy) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_: any) => {
            return this.processGetPage(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPage(<any>response_);
                } catch (e) {
                    return <Observable<PaginatedListOfPlanVmForDashborad>><any>_observableThrow(e);
                }
            } else
                return <Observable<PaginatedListOfPlanVmForDashborad>><any>_observableThrow(response_);
        }));
    }

    protected processGetPage(response: HttpResponseBase): Observable<PaginatedListOfPlanVmForDashborad> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
                (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } }
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result200: any = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = PaginatedListOfPlanVmForDashborad.fromJS(resultData200);
                return _observableOf(result200);
            }));
        } else if (status === 422) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result422: any = null;
                let resultData422 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result422 = ValidationProblemDetails.fromJS(resultData422);
                return throwException("A server side error occurred.", status, _responseText, _headers, result422);
            }));
        } else {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let resultdefault: any = null;
                let resultDatadefault = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                resultdefault = ProblemDetails.fromJS(resultDatadefault);
                return throwException("A server side error occurred.", status, _responseText, _headers, resultdefault);
            }));
        }
    }

    post(command: PlansPostCommand): Observable<HttpResultOfLong> {
        let url_ = this.baseUrl + "/api/Plans";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_: any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_: any) => {
            return this.processPost(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPost(<any>response_);
                } catch (e) {
                    return <Observable<HttpResultOfLong>><any>_observableThrow(e);
                }
            } else
                return <Observable<HttpResultOfLong>><any>_observableThrow(response_);
        }));
    }

    protected processPost(response: HttpResponseBase): Observable<HttpResultOfLong> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
                (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } }
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result200: any = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = HttpResultOfLong.fromJS(resultData200);
                return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result404: any = null;
                let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result404 = ProblemDetails.fromJS(resultData404);
                return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result400: any = null;
                let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result400 = ProblemDetails.fromJS(resultData400);
                return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 422) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result422: any = null;
                let resultData422 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result422 = ValidationProblemDetails.fromJS(resultData422);
                return throwException("A server side error occurred.", status, _responseText, _headers, result422);
            }));
        } else {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let resultdefault: any = null;
                let resultDatadefault = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                resultdefault = ProblemDetails.fromJS(resultDatadefault);
                return throwException("A server side error occurred.", status, _responseText, _headers, resultdefault);
            }));
        }
    }

    put(command: PlansPutCommand): Observable<void> {
        let url_ = this.baseUrl + "/api/Plans";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_: any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_: any) => {
            return this.processPut(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPut(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processPut(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
                (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } }
        if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return _observableOf<void>(<any>null);
            }));
        } else if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return _observableOf<void>(<any>null);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result404: any = null;
                let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result404 = ProblemDetails.fromJS(resultData404);
                return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result400: any = null;
                let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result400 = ProblemDetails.fromJS(resultData400);
                return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 422) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result422: any = null;
                let resultData422 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result422 = ValidationProblemDetails.fromJS(resultData422);
                return throwException("A server side error occurred.", status, _responseText, _headers, result422);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    delete(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/Plans?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_: any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
                (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } }
        if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return _observableOf<void>(<any>null);
            }));
        } else if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return _observableOf<void>(<any>null);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result404: any = null;
                let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result404 = ProblemDetails.fromJS(resultData404);
                return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result400: any = null;
                let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result400 = ProblemDetails.fromJS(resultData400);
                return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 422) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result422: any = null;
                let resultData422 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result422 = ValidationProblemDetails.fromJS(resultData422);
                return throwException("A server side error occurred.", status, _responseText, _headers, result422);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

export interface IRealStatesClient {
    get(id: number | undefined): Observable<RealStateDto>;
    post(command: RealStatesPostCommand): Observable<HttpResultOfInteger>;
    put(command: RealStatesPutCommand): Observable<void>;
    delete(id: number | undefined): Observable<void>;
    getPage(): Observable<RealStatesVmForDashboard[]>;
    getList(): Observable<RealStatesVm[]>;
    putOrder(command: RealStatesPutOrderCommand): Observable<void>;
}

@Injectable({
    providedIn: 'root'
})
export class RealStatesClient implements IRealStatesClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    get(id: number | undefined): Observable<RealStateDto> {
        let url_ = this.baseUrl + "/api/RealStates?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_: any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(<any>response_);
                } catch (e) {
                    return <Observable<RealStateDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<RealStateDto>><any>_observableThrow(response_);
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<RealStateDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
                (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } }
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result200: any = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = RealStateDto.fromJS(resultData200);
                return _observableOf(result200);
            }));
        } else if (status === 422) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result422: any = null;
                let resultData422 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result422 = ValidationProblemDetails.fromJS(resultData422);
                return throwException("A server side error occurred.", status, _responseText, _headers, result422);
            }));
        } else {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let resultdefault: any = null;
                let resultDatadefault = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                resultdefault = ProblemDetails.fromJS(resultDatadefault);
                return throwException("A server side error occurred.", status, _responseText, _headers, resultdefault);
            }));
        }
    }

    post(command: RealStatesPostCommand): Observable<HttpResultOfInteger> {
        let url_ = this.baseUrl + "/api/RealStates";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_: any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_: any) => {
            return this.processPost(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPost(<any>response_);
                } catch (e) {
                    return <Observable<HttpResultOfInteger>><any>_observableThrow(e);
                }
            } else
                return <Observable<HttpResultOfInteger>><any>_observableThrow(response_);
        }));
    }

    protected processPost(response: HttpResponseBase): Observable<HttpResultOfInteger> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
                (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } }
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result200: any = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = HttpResultOfInteger.fromJS(resultData200);
                return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result404: any = null;
                let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result404 = ProblemDetails.fromJS(resultData404);
                return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result400: any = null;
                let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result400 = ProblemDetails.fromJS(resultData400);
                return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 422) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result422: any = null;
                let resultData422 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result422 = ValidationProblemDetails.fromJS(resultData422);
                return throwException("A server side error occurred.", status, _responseText, _headers, result422);
            }));
        } else {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let resultdefault: any = null;
                let resultDatadefault = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                resultdefault = ProblemDetails.fromJS(resultDatadefault);
                return throwException("A server side error occurred.", status, _responseText, _headers, resultdefault);
            }));
        }
    }

    put(command: RealStatesPutCommand): Observable<void> {
        let url_ = this.baseUrl + "/api/RealStates";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_: any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_: any) => {
            return this.processPut(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPut(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processPut(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
                (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } }
        if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return _observableOf<void>(<any>null);
            }));
        } else if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return _observableOf<void>(<any>null);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result404: any = null;
                let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result404 = ProblemDetails.fromJS(resultData404);
                return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result400: any = null;
                let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result400 = ProblemDetails.fromJS(resultData400);
                return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 422) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result422: any = null;
                let resultData422 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result422 = ValidationProblemDetails.fromJS(resultData422);
                return throwException("A server side error occurred.", status, _responseText, _headers, result422);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    delete(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/RealStates?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_: any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
                (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } }
        if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return _observableOf<void>(<any>null);
            }));
        } else if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return _observableOf<void>(<any>null);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result404: any = null;
                let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result404 = ProblemDetails.fromJS(resultData404);
                return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result400: any = null;
                let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result400 = ProblemDetails.fromJS(resultData400);
                return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 422) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result422: any = null;
                let resultData422 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result422 = ValidationProblemDetails.fromJS(resultData422);
                return throwException("A server side error occurred.", status, _responseText, _headers, result422);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    getPage(): Observable<RealStatesVmForDashboard[]> {
        let url_ = this.baseUrl + "/api/RealStates/GetPage";
        url_ = url_.replace(/[?&]$/, "");

        let options_: any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_: any) => {
            return this.processGetPage(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPage(<any>response_);
                } catch (e) {
                    return <Observable<RealStatesVmForDashboard[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<RealStatesVmForDashboard[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetPage(response: HttpResponseBase): Observable<RealStatesVmForDashboard[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
                (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } }
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result200: any = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                if (Array.isArray(resultData200)) {
                    result200 = [] as any;
                    for (let item of resultData200)
                        result200!.push(RealStatesVmForDashboard.fromJS(item));
                }
                else {
                    result200 = <any>null;
                }
                return _observableOf(result200);
            }));
        } else {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let resultdefault: any = null;
                let resultDatadefault = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                resultdefault = ProblemDetails.fromJS(resultDatadefault);
                return throwException("A server side error occurred.", status, _responseText, _headers, resultdefault);
            }));
        }
    }

    getList(): Observable<RealStatesVm[]> {
        let url_ = this.baseUrl + "/api/RealStates/GetList";
        url_ = url_.replace(/[?&]$/, "");

        let options_: any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_: any) => {
            return this.processGetList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetList(<any>response_);
                } catch (e) {
                    return <Observable<RealStatesVm[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<RealStatesVm[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetList(response: HttpResponseBase): Observable<RealStatesVm[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
                (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } }
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result200: any = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                if (Array.isArray(resultData200)) {
                    result200 = [] as any;
                    for (let item of resultData200)
                        result200!.push(RealStatesVm.fromJS(item));
                }
                else {
                    result200 = <any>null;
                }
                return _observableOf(result200);
            }));
        } else {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let resultdefault: any = null;
                let resultDatadefault = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                resultdefault = ProblemDetails.fromJS(resultDatadefault);
                return throwException("A server side error occurred.", status, _responseText, _headers, resultdefault);
            }));
        }
    }

    putOrder(command: RealStatesPutOrderCommand): Observable<void> {
        let url_ = this.baseUrl + "/api/RealStates/PutOrder";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_: any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_: any) => {
            return this.processPutOrder(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPutOrder(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processPutOrder(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
                (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } }
        if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return _observableOf<void>(<any>null);
            }));
        } else if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return _observableOf<void>(<any>null);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result404: any = null;
                let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result404 = ProblemDetails.fromJS(resultData404);
                return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result400: any = null;
                let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result400 = ProblemDetails.fromJS(resultData400);
                return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 422) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result422: any = null;
                let resultData422 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result422 = ValidationProblemDetails.fromJS(resultData422);
                return throwException("A server side error occurred.", status, _responseText, _headers, result422);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

export interface IRegionsClient {
    get(id: number): Observable<RegionDto>;
    getPage(parentId: number | null | undefined, offset: number | null | undefined, pageIndex: number | null | undefined, search: string | null | undefined, ascending: boolean | undefined, sortBy: string | null | undefined): Observable<PaginatedListOfRegionDto>;
    getList(countryId: number | null | undefined, parentRegionId: number | null | undefined): Observable<RegionVm[]>;
    post(command: RegionsPostCommand): Observable<HttpResultOfLong>;
    put(command: RegionsPutCommand): Observable<void>;
    delete(id: number | undefined): Observable<void>;
}

@Injectable({
    providedIn: 'root'
})
export class RegionsClient implements IRegionsClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    get(id: number): Observable<RegionDto> {
        let url_ = this.baseUrl + "/api/Regions/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_: any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(<any>response_);
                } catch (e) {
                    return <Observable<RegionDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<RegionDto>><any>_observableThrow(response_);
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<RegionDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
                (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } }
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result200: any = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = RegionDto.fromJS(resultData200);
                return _observableOf(result200);
            }));
        } else if (status === 422) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result422: any = null;
                let resultData422 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result422 = ValidationProblemDetails.fromJS(resultData422);
                return throwException("A server side error occurred.", status, _responseText, _headers, result422);
            }));
        } else {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let resultdefault: any = null;
                let resultDatadefault = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                resultdefault = ProblemDetails.fromJS(resultDatadefault);
                return throwException("A server side error occurred.", status, _responseText, _headers, resultdefault);
            }));
        }
    }

    getPage(parentId: number | null | undefined, offset: number | null | undefined, pageIndex: number | null | undefined, search: string | null | undefined, ascending: boolean | undefined, sortBy: string | null | undefined): Observable<PaginatedListOfRegionDto> {
        let url_ = this.baseUrl + "/api/Regions/GetPage?";
        if (parentId !== undefined && parentId !== null)
            url_ += "ParentId=" + encodeURIComponent("" + parentId) + "&";
        if (offset !== undefined && offset !== null)
            url_ += "Offset=" + encodeURIComponent("" + offset) + "&";
        if (pageIndex !== undefined && pageIndex !== null)
            url_ += "PageIndex=" + encodeURIComponent("" + pageIndex) + "&";
        if (search !== undefined && search !== null)
            url_ += "Search=" + encodeURIComponent("" + search) + "&";
        if (ascending === null)
            throw new Error("The parameter 'ascending' cannot be null.");
        else if (ascending !== undefined)
            url_ += "Ascending=" + encodeURIComponent("" + ascending) + "&";
        if (sortBy !== undefined && sortBy !== null)
            url_ += "SortBy=" + encodeURIComponent("" + sortBy) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_: any) => {
            return this.processGetPage(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPage(<any>response_);
                } catch (e) {
                    return <Observable<PaginatedListOfRegionDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PaginatedListOfRegionDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetPage(response: HttpResponseBase): Observable<PaginatedListOfRegionDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
                (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } }
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result200: any = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = PaginatedListOfRegionDto.fromJS(resultData200);
                return _observableOf(result200);
            }));
        } else if (status === 422) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result422: any = null;
                let resultData422 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result422 = ValidationProblemDetails.fromJS(resultData422);
                return throwException("A server side error occurred.", status, _responseText, _headers, result422);
            }));
        } else {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let resultdefault: any = null;
                let resultDatadefault = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                resultdefault = ProblemDetails.fromJS(resultDatadefault);
                return throwException("A server side error occurred.", status, _responseText, _headers, resultdefault);
            }));
        }
    }

    getList(countryId: number | null | undefined, parentRegionId: number | null | undefined): Observable<RegionVm[]> {
        let url_ = this.baseUrl + "/api/Regions/GetList?";
        if (countryId !== undefined && countryId !== null)
            url_ += "CountryId=" + encodeURIComponent("" + countryId) + "&";
        if (parentRegionId !== undefined && parentRegionId !== null)
            url_ += "ParentRegionId=" + encodeURIComponent("" + parentRegionId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_: any) => {
            return this.processGetList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetList(<any>response_);
                } catch (e) {
                    return <Observable<RegionVm[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<RegionVm[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetList(response: HttpResponseBase): Observable<RegionVm[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
                (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } }
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result200: any = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                if (Array.isArray(resultData200)) {
                    result200 = [] as any;
                    for (let item of resultData200)
                        result200!.push(RegionVm.fromJS(item));
                }
                else {
                    result200 = <any>null;
                }
                return _observableOf(result200);
            }));
        } else if (status === 422) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result422: any = null;
                let resultData422 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result422 = ValidationProblemDetails.fromJS(resultData422);
                return throwException("A server side error occurred.", status, _responseText, _headers, result422);
            }));
        } else {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let resultdefault: any = null;
                let resultDatadefault = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                resultdefault = ProblemDetails.fromJS(resultDatadefault);
                return throwException("A server side error occurred.", status, _responseText, _headers, resultdefault);
            }));
        }
    }

    post(command: RegionsPostCommand): Observable<HttpResultOfLong> {
        let url_ = this.baseUrl + "/api/Regions";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_: any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_: any) => {
            return this.processPost(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPost(<any>response_);
                } catch (e) {
                    return <Observable<HttpResultOfLong>><any>_observableThrow(e);
                }
            } else
                return <Observable<HttpResultOfLong>><any>_observableThrow(response_);
        }));
    }

    protected processPost(response: HttpResponseBase): Observable<HttpResultOfLong> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
                (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } }
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result200: any = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = HttpResultOfLong.fromJS(resultData200);
                return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result404: any = null;
                let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result404 = ProblemDetails.fromJS(resultData404);
                return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result400: any = null;
                let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result400 = ProblemDetails.fromJS(resultData400);
                return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 422) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result422: any = null;
                let resultData422 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result422 = ValidationProblemDetails.fromJS(resultData422);
                return throwException("A server side error occurred.", status, _responseText, _headers, result422);
            }));
        } else {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let resultdefault: any = null;
                let resultDatadefault = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                resultdefault = ProblemDetails.fromJS(resultDatadefault);
                return throwException("A server side error occurred.", status, _responseText, _headers, resultdefault);
            }));
        }
    }

    put(command: RegionsPutCommand): Observable<void> {
        let url_ = this.baseUrl + "/api/Regions";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_: any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_: any) => {
            return this.processPut(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPut(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processPut(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
                (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } }
        if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return _observableOf<void>(<any>null);
            }));
        } else if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return _observableOf<void>(<any>null);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result404: any = null;
                let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result404 = ProblemDetails.fromJS(resultData404);
                return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result400: any = null;
                let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result400 = ProblemDetails.fromJS(resultData400);
                return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 422) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result422: any = null;
                let resultData422 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result422 = ValidationProblemDetails.fromJS(resultData422);
                return throwException("A server side error occurred.", status, _responseText, _headers, result422);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    delete(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/Regions?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_: any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
                (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } }
        if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return _observableOf<void>(<any>null);
            }));
        } else if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return _observableOf<void>(<any>null);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result404: any = null;
                let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result404 = ProblemDetails.fromJS(resultData404);
                return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result400: any = null;
                let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result400 = ProblemDetails.fromJS(resultData400);
                return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 422) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result422: any = null;
                let resultData422 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result422 = ValidationProblemDetails.fromJS(resultData422);
                return throwException("A server side error occurred.", status, _responseText, _headers, result422);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

export interface IUserRegionClient {
    get(partnerId: string | null | undefined): Observable<UserRegionDto[]>;
    post(userId: string | null | undefined, regionIds: number[] | null | undefined): Observable<void>;
}

@Injectable({
    providedIn: 'root'
})
export class UserRegionClient implements IUserRegionClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    get(partnerId: string | null | undefined): Observable<UserRegionDto[]> {
        let url_ = this.baseUrl + "/api/UserRegion?";
        if (partnerId !== undefined && partnerId !== null)
            url_ += "PartnerId=" + encodeURIComponent("" + partnerId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_: any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(<any>response_);
                } catch (e) {
                    return <Observable<UserRegionDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<UserRegionDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<UserRegionDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
                (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } }
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result200: any = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                if (Array.isArray(resultData200)) {
                    result200 = [] as any;
                    for (let item of resultData200)
                        result200!.push(UserRegionDto.fromJS(item));
                }
                else {
                    result200 = <any>null;
                }
                return _observableOf(result200);
            }));
        } else if (status === 422) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result422: any = null;
                let resultData422 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result422 = ValidationProblemDetails.fromJS(resultData422);
                return throwException("A server side error occurred.", status, _responseText, _headers, result422);
            }));
        } else {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let resultdefault: any = null;
                let resultDatadefault = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                resultdefault = ProblemDetails.fromJS(resultDatadefault);
                return throwException("A server side error occurred.", status, _responseText, _headers, resultdefault);
            }));
        }
    }

    post(userId: string | null | undefined, regionIds: number[] | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/UserRegion?";
        if (userId !== undefined && userId !== null)
            url_ += "UserId=" + encodeURIComponent("" + userId) + "&";
        if (regionIds !== undefined && regionIds !== null)
            regionIds && regionIds.forEach(item => { url_ += "RegionIds=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_: any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_: any) => {
            return this.processPost(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPost(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processPost(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
                (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } }
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return _observableOf<void>(<any>null);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result404: any = null;
                let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result404 = ProblemDetails.fromJS(resultData404);
                return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result400: any = null;
                let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result400 = ProblemDetails.fromJS(resultData400);
                return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 422) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result422: any = null;
                let resultData422 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result422 = ValidationProblemDetails.fromJS(resultData422);
                return throwException("A server side error occurred.", status, _responseText, _headers, result422);
            }));
        } else {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let resultdefault: any = null;
                let resultDatadefault = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                resultdefault = ProblemDetails.fromJS(resultDatadefault);
                return throwException("A server side error occurred.", status, _responseText, _headers, resultdefault);
            }));
        }
    }
}

export class ProblemDetails implements IProblemDetails {
    type?: string | undefined;
    title?: string | undefined;
    status?: number | undefined;
    detail?: string | undefined;
    instance?: string | undefined;
    extensions?: { [key: string]: any; } | undefined;

    constructor(data?: IProblemDetails) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.type = _data["type"];
            this.title = _data["title"];
            this.status = _data["status"];
            this.detail = _data["detail"];
            this.instance = _data["instance"];
            if (_data["extensions"]) {
                this.extensions = {} as any;
                for (let key in _data["extensions"]) {
                    if (_data["extensions"].hasOwnProperty(key))
                        (<any>this.extensions)![key] = _data["extensions"][key];
                }
            }
        }
    }

    static fromJS(data: any): ProblemDetails {
        data = typeof data === 'object' ? data : {};
        let result = new ProblemDetails();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["type"] = this.type;
        data["title"] = this.title;
        data["status"] = this.status;
        data["detail"] = this.detail;
        data["instance"] = this.instance;
        if (this.extensions) {
            data["extensions"] = {};
            for (let key in this.extensions) {
                if (this.extensions.hasOwnProperty(key))
                    (<any>data["extensions"])[key] = this.extensions[key];
            }
        }
        return data;
    }
}

export interface IProblemDetails {
    type?: string | undefined;
    title?: string | undefined;
    status?: number | undefined;
    detail?: string | undefined;
    instance?: string | undefined;
    extensions?: { [key: string]: any; } | undefined;
}

export class PaginatedListOfAccountVm implements IPaginatedListOfAccountVm {
    pageInfo?: PageInfo | undefined;
    items?: AccountVm[] | undefined;

    constructor(data?: IPaginatedListOfAccountVm) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.pageInfo = _data["pageInfo"] ? PageInfo.fromJS(_data["pageInfo"]) : <any>undefined;
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(AccountVm.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PaginatedListOfAccountVm {
        data = typeof data === 'object' ? data : {};
        let result = new PaginatedListOfAccountVm();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["pageInfo"] = this.pageInfo ? this.pageInfo.toJSON() : <any>undefined;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IPaginatedListOfAccountVm {
    pageInfo?: PageInfo | undefined;
    items?: AccountVm[] | undefined;
}

export class PageInfo implements IPageInfo {
    pageIndex?: number;
    totalPages?: number;
    totalCount?: number;

    constructor(data?: IPageInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.pageIndex = _data["pageIndex"];
            this.totalPages = _data["totalPages"];
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): PageInfo {
        data = typeof data === 'object' ? data : {};
        let result = new PageInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["pageIndex"] = this.pageIndex;
        data["totalPages"] = this.totalPages;
        data["totalCount"] = this.totalCount;
        return data;
    }
}

export interface IPageInfo {
    pageIndex?: number;
    totalPages?: number;
    totalCount?: number;
}

export class AccountVm implements IAccountVm {
    id?: string | undefined;
    username?: string | undefined;
    fullName?: string | undefined;
    pictureUrl?: string | undefined;
    phoneNumber?: string | undefined;
    status?: AccountStatus;
    createdAt?: Date;

    constructor(data?: IAccountVm) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.username = _data["username"];
            this.fullName = _data["fullName"];
            this.pictureUrl = _data["pictureUrl"];
            this.phoneNumber = _data["phoneNumber"];
            this.status = _data["status"];
            this.createdAt = _data["createdAt"] ? new Date(_data["createdAt"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): AccountVm {
        data = typeof data === 'object' ? data : {};
        let result = new AccountVm();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["username"] = this.username;
        data["fullName"] = this.fullName;
        data["pictureUrl"] = this.pictureUrl;
        data["phoneNumber"] = this.phoneNumber;
        data["status"] = this.status;
        data["createdAt"] = this.createdAt ? this.createdAt.toISOString() : <any>undefined;
        return data;
    }
}

export interface IAccountVm {
    id?: string | undefined;
    username?: string | undefined;
    fullName?: string | undefined;
    pictureUrl?: string | undefined;
    phoneNumber?: string | undefined;
    status?: AccountStatus;
    createdAt?: Date;
}

/** 0 = Live 1 = Banned 2 = Inactive */
export enum AccountStatus {
    Live = 0,
    Banned = 1,
    Inactive = 2,
}

export class ValidationProblemDetails extends ProblemDetails implements IValidationProblemDetails {
    errors?: { [key: string]: string[]; } | undefined;

    constructor(data?: IValidationProblemDetails) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            if (_data["errors"]) {
                this.errors = {} as any;
                for (let key in _data["errors"]) {
                    if (_data["errors"].hasOwnProperty(key))
                        (<any>this.errors)![key] = _data["errors"][key] !== undefined ? _data["errors"][key] : [];
                }
            }
        }
    }

    static fromJS(data: any): ValidationProblemDetails {
        data = typeof data === 'object' ? data : {};
        let result = new ValidationProblemDetails();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.errors) {
            data["errors"] = {};
            for (let key in this.errors) {
                if (this.errors.hasOwnProperty(key))
                    (<any>data["errors"])[key] = this.errors[key];
            }
        }
        super.toJSON(data);
        return data;
    }
}

export interface IValidationProblemDetails extends IProblemDetails {
    errors?: { [key: string]: string[]; } | undefined;
}

export class PaginatedListOfAdminVm implements IPaginatedListOfAdminVm {
    pageInfo?: PageInfo | undefined;
    items?: AdminVm[] | undefined;

    constructor(data?: IPaginatedListOfAdminVm) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.pageInfo = _data["pageInfo"] ? PageInfo.fromJS(_data["pageInfo"]) : <any>undefined;
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(AdminVm.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PaginatedListOfAdminVm {
        data = typeof data === 'object' ? data : {};
        let result = new PaginatedListOfAdminVm();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["pageInfo"] = this.pageInfo ? this.pageInfo.toJSON() : <any>undefined;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IPaginatedListOfAdminVm {
    pageInfo?: PageInfo | undefined;
    items?: AdminVm[] | undefined;
}

export class AdminVm implements IAdminVm {
    id?: string | undefined;
    username?: string | undefined;
    fullName?: string | undefined;
    pictureUrl?: string | undefined;
    phoneNumber?: string | undefined;
    role?: Role | undefined;
    createdAt?: Date;

    constructor(data?: IAdminVm) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.username = _data["username"];
            this.fullName = _data["fullName"];
            this.pictureUrl = _data["pictureUrl"];
            this.phoneNumber = _data["phoneNumber"];
            this.role = _data["role"];
            this.createdAt = _data["createdAt"] ? new Date(_data["createdAt"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): AdminVm {
        data = typeof data === 'object' ? data : {};
        let result = new AdminVm();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["username"] = this.username;
        data["fullName"] = this.fullName;
        data["pictureUrl"] = this.pictureUrl;
        data["phoneNumber"] = this.phoneNumber;
        data["role"] = this.role;
        data["createdAt"] = this.createdAt ? this.createdAt.toISOString() : <any>undefined;
        return data;
    }
}

export interface IAdminVm {
    id?: string | undefined;
    username?: string | undefined;
    fullName?: string | undefined;
    pictureUrl?: string | undefined;
    phoneNumber?: string | undefined;
    role?: Role | undefined;
    createdAt?: Date;
}

/** 0 = Admin 1 = Partner 2 = Viewer 3 = Evaluator 4 = Reviewer 5 = Certifire 6 = Support */
export enum Role {
    Admin = 0,
    Partner = 1,
    Viewer = 2,
    Evaluator = 3,
    Reviewer = 4,
    Certifire = 5,
    Support = 6,
}

export class AccountDashboardDto implements IAccountDashboardDto {
    email?: string | undefined;
    phoneNumber?: string | undefined;
    name?: FullNameDto | undefined;
    role?: Role | undefined;

    constructor(data?: IAccountDashboardDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.email = _data["email"];
            this.phoneNumber = _data["phoneNumber"];
            this.name = _data["name"] ? FullNameDto.fromJS(_data["name"]) : <any>undefined;
            this.role = _data["role"];
        }
    }

    static fromJS(data: any): AccountDashboardDto {
        data = typeof data === 'object' ? data : {};
        let result = new AccountDashboardDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["email"] = this.email;
        data["phoneNumber"] = this.phoneNumber;
        data["name"] = this.name ? this.name.toJSON() : <any>undefined;
        data["role"] = this.role;
        return data;
    }
}

export interface IAccountDashboardDto {
    email?: string | undefined;
    phoneNumber?: string | undefined;
    name?: FullNameDto | undefined;
    role?: Role | undefined;
}

export class FullNameDto implements IFullNameDto {
    firstName?: string | undefined;
    lastName?: string | undefined;

    constructor(data?: IFullNameDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.firstName = _data["firstName"];
            this.lastName = _data["lastName"];
        }
    }

    static fromJS(data: any): FullNameDto {
        data = typeof data === 'object' ? data : {};
        let result = new FullNameDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["firstName"] = this.firstName;
        data["lastName"] = this.lastName;
        return data;
    }
}

export interface IFullNameDto {
    firstName?: string | undefined;
    lastName?: string | undefined;
}

export class AccountDto implements IAccountDto {
    email?: string | undefined;
    phoneNumber?: string | undefined;
    name?: FullNameDto | undefined;

    constructor(data?: IAccountDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.email = _data["email"];
            this.phoneNumber = _data["phoneNumber"];
            this.name = _data["name"] ? FullNameDto.fromJS(_data["name"]) : <any>undefined;
        }
    }

    static fromJS(data: any): AccountDto {
        data = typeof data === 'object' ? data : {};
        let result = new AccountDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["email"] = this.email;
        data["phoneNumber"] = this.phoneNumber;
        data["name"] = this.name ? this.name.toJSON() : <any>undefined;
        return data;
    }
}

export interface IAccountDto {
    email?: string | undefined;
    phoneNumber?: string | undefined;
    name?: FullNameDto | undefined;
}

export class AccountResult implements IAccountResult {
    id?: string | undefined;
    username?: string | undefined;
    createdAt?: Date;

    constructor(data?: IAccountResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.username = _data["username"];
            this.createdAt = _data["createdAt"] ? new Date(_data["createdAt"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): AccountResult {
        data = typeof data === 'object' ? data : {};
        let result = new AccountResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["username"] = this.username;
        data["createdAt"] = this.createdAt ? this.createdAt.toISOString() : <any>undefined;
        return data;
    }
}

export interface IAccountResult {
    id?: string | undefined;
    username?: string | undefined;
    createdAt?: Date;
}

export class UserPostCommon implements IUserPostCommon {
    fullName?: FullNameDto | undefined;
    email?: string | undefined;
    phoneNumber?: string | undefined;

    constructor(data?: IUserPostCommon) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.fullName = _data["fullName"] ? FullNameDto.fromJS(_data["fullName"]) : <any>undefined;
            this.email = _data["email"];
            this.phoneNumber = _data["phoneNumber"];
        }
    }

    static fromJS(data: any): UserPostCommon {
        data = typeof data === 'object' ? data : {};
        let result = new UserPostCommon();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["fullName"] = this.fullName ? this.fullName.toJSON() : <any>undefined;
        data["email"] = this.email;
        data["phoneNumber"] = this.phoneNumber;
        return data;
    }
}

export interface IUserPostCommon {
    fullName?: FullNameDto | undefined;
    email?: string | undefined;
    phoneNumber?: string | undefined;
}

export class AccountsPostCommand extends UserPostCommon implements IAccountsPostCommand {
    role?: Role;
    password?: string | undefined;
    confirmPassword?: string | undefined;

    constructor(data?: IAccountsPostCommand) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.role = _data["role"];
            this.password = _data["password"];
            this.confirmPassword = _data["confirmPassword"];
        }
    }

    static fromJS(data: any): AccountsPostCommand {
        data = typeof data === 'object' ? data : {};
        let result = new AccountsPostCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["role"] = this.role;
        data["password"] = this.password;
        data["confirmPassword"] = this.confirmPassword;
        super.toJSON(data);
        return data;
    }
}

export interface IAccountsPostCommand extends IUserPostCommon {
    role?: Role;
    password?: string | undefined;
    confirmPassword?: string | undefined;
}

export class AuthResponse implements IAuthResponse {
    token?: string | undefined;
    refreshToken?: string | undefined;

    constructor(data?: IAuthResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.token = _data["token"];
            this.refreshToken = _data["refreshToken"];
        }
    }

    static fromJS(data: any): AuthResponse {
        data = typeof data === 'object' ? data : {};
        let result = new AuthResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["token"] = this.token;
        data["refreshToken"] = this.refreshToken;
        return data;
    }
}

export interface IAuthResponse {
    token?: string | undefined;
    refreshToken?: string | undefined;
}

export class RefreshTokenCommand implements IRefreshTokenCommand {
    refreshToken?: string | undefined;

    constructor(data?: IRefreshTokenCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.refreshToken = _data["refreshToken"];
        }
    }

    static fromJS(data: any): RefreshTokenCommand {
        data = typeof data === 'object' ? data : {};
        let result = new RefreshTokenCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["refreshToken"] = this.refreshToken;
        return data;
    }
}

export interface IRefreshTokenCommand {
    refreshToken?: string | undefined;
}

export class LoginCommand implements ILoginCommand {
    email?: string | undefined;
    password?: string | undefined;

    constructor(data?: ILoginCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.email = _data["email"];
            this.password = _data["password"];
        }
    }

    static fromJS(data: any): LoginCommand {
        data = typeof data === 'object' ? data : {};
        let result = new LoginCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["email"] = this.email;
        data["password"] = this.password;
        return data;
    }
}

export interface ILoginCommand {
    email?: string | undefined;
    password?: string | undefined;
}

export class HttpResultOfString implements IHttpResultOfString {
    result?: string | undefined;

    constructor(data?: IHttpResultOfString) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.result = _data["result"];
        }
    }

    static fromJS(data: any): HttpResultOfString {
        data = typeof data === 'object' ? data : {};
        let result = new HttpResultOfString();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["result"] = this.result;
        return data;
    }
}

export interface IHttpResultOfString {
    result?: string | undefined;
}

export class RegisterCommand extends UserPostCommon implements IRegisterCommand {
    password?: string | undefined;
    confirmPassword?: string | undefined;

    constructor(data?: IRegisterCommand) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.password = _data["password"];
            this.confirmPassword = _data["confirmPassword"];
        }
    }

    static fromJS(data: any): RegisterCommand {
        data = typeof data === 'object' ? data : {};
        let result = new RegisterCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["password"] = this.password;
        data["confirmPassword"] = this.confirmPassword;
        super.toJSON(data);
        return data;
    }
}

export interface IRegisterCommand extends IUserPostCommon {
    password?: string | undefined;
    confirmPassword?: string | undefined;
}

export class ExternalLoginCommand implements IExternalLoginCommand {
    provider?: string | undefined;
    token?: string | undefined;
    email?: string | undefined;

    constructor(data?: IExternalLoginCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.provider = _data["provider"];
            this.token = _data["token"];
            this.email = _data["email"];
        }
    }

    static fromJS(data: any): ExternalLoginCommand {
        data = typeof data === 'object' ? data : {};
        let result = new ExternalLoginCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["provider"] = this.provider;
        data["token"] = this.token;
        data["email"] = this.email;
        return data;
    }
}

export interface IExternalLoginCommand {
    provider?: string | undefined;
    token?: string | undefined;
    email?: string | undefined;
}

export class ExternalRegisterCommand implements IExternalRegisterCommand {
    provider?: string | undefined;
    token?: string | undefined;
    phoneNumber?: string | undefined;

    constructor(data?: IExternalRegisterCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.provider = _data["provider"];
            this.token = _data["token"];
            this.phoneNumber = _data["phoneNumber"];
        }
    }

    static fromJS(data: any): ExternalRegisterCommand {
        data = typeof data === 'object' ? data : {};
        let result = new ExternalRegisterCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["provider"] = this.provider;
        data["token"] = this.token;
        data["phoneNumber"] = this.phoneNumber;
        return data;
    }
}

export interface IExternalRegisterCommand {
    provider?: string | undefined;
    token?: string | undefined;
    phoneNumber?: string | undefined;
}

export class ResetPasswordCommand implements IResetPasswordCommand {
    email?: string | undefined;
    token?: string | undefined;
    password?: string | undefined;
    confirmPassword?: string | undefined;

    constructor(data?: IResetPasswordCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.email = _data["email"];
            this.token = _data["token"];
            this.password = _data["password"];
            this.confirmPassword = _data["confirmPassword"];
        }
    }

    static fromJS(data: any): ResetPasswordCommand {
        data = typeof data === 'object' ? data : {};
        let result = new ResetPasswordCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["email"] = this.email;
        data["token"] = this.token;
        data["password"] = this.password;
        data["confirmPassword"] = this.confirmPassword;
        return data;
    }
}

export interface IResetPasswordCommand {
    email?: string | undefined;
    token?: string | undefined;
    password?: string | undefined;
    confirmPassword?: string | undefined;
}

export class ConfirmPhoneNumberCommand implements IConfirmPhoneNumberCommand {
    email?: string | undefined;
    token?: string | undefined;

    constructor(data?: IConfirmPhoneNumberCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.email = _data["email"];
            this.token = _data["token"];
        }
    }

    static fromJS(data: any): ConfirmPhoneNumberCommand {
        data = typeof data === 'object' ? data : {};
        let result = new ConfirmPhoneNumberCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["email"] = this.email;
        data["token"] = this.token;
        return data;
    }
}

export interface IConfirmPhoneNumberCommand {
    email?: string | undefined;
    token?: string | undefined;
}

export class ConfirmChangePhoneNumberCommand implements IConfirmChangePhoneNumberCommand {
    token?: string | undefined;

    constructor(data?: IConfirmChangePhoneNumberCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.token = _data["token"];
        }
    }

    static fromJS(data: any): ConfirmChangePhoneNumberCommand {
        data = typeof data === 'object' ? data : {};
        let result = new ConfirmChangePhoneNumberCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["token"] = this.token;
        return data;
    }
}

export interface IConfirmChangePhoneNumberCommand {
    token?: string | undefined;
}

export class ResendPhoneNumberConfirmationCommand implements IResendPhoneNumberConfirmationCommand {
    email?: string | undefined;

    constructor(data?: IResendPhoneNumberConfirmationCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.email = _data["email"];
        }
    }

    static fromJS(data: any): ResendPhoneNumberConfirmationCommand {
        data = typeof data === 'object' ? data : {};
        let result = new ResendPhoneNumberConfirmationCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["email"] = this.email;
        return data;
    }
}

export interface IResendPhoneNumberConfirmationCommand {
    email?: string | undefined;
}

export class ForgetPasswordCommand implements IForgetPasswordCommand {
    email?: string | undefined;

    constructor(data?: IForgetPasswordCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.email = _data["email"];
        }
    }

    static fromJS(data: any): ForgetPasswordCommand {
        data = typeof data === 'object' ? data : {};
        let result = new ForgetPasswordCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["email"] = this.email;
        return data;
    }
}

export interface IForgetPasswordCommand {
    email?: string | undefined;
}

export class ValidateResetPasswordToken implements IValidateResetPasswordToken {
    token?: string | undefined;
    email?: string | undefined;

    constructor(data?: IValidateResetPasswordToken) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.token = _data["token"];
            this.email = _data["email"];
        }
    }

    static fromJS(data: any): ValidateResetPasswordToken {
        data = typeof data === 'object' ? data : {};
        let result = new ValidateResetPasswordToken();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["token"] = this.token;
        data["email"] = this.email;
        return data;
    }
}

export interface IValidateResetPasswordToken {
    token?: string | undefined;
    email?: string | undefined;
}

export class AccountsPutCommand extends UserPostCommon implements IAccountsPutCommand {
    userId?: string | undefined;

    constructor(data?: IAccountsPutCommand) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.userId = _data["userId"];
        }
    }

    static fromJS(data: any): AccountsPutCommand {
        data = typeof data === 'object' ? data : {};
        let result = new AccountsPutCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId;
        super.toJSON(data);
        return data;
    }
}

export interface IAccountsPutCommand extends IUserPostCommon {
    userId?: string | undefined;
}

export class ChangePhoneNumberCommand implements IChangePhoneNumberCommand {
    phoneNumber?: string | undefined;

    constructor(data?: IChangePhoneNumberCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.phoneNumber = _data["phoneNumber"];
        }
    }

    static fromJS(data: any): ChangePhoneNumberCommand {
        data = typeof data === 'object' ? data : {};
        let result = new ChangePhoneNumberCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["phoneNumber"] = this.phoneNumber;
        return data;
    }
}

export interface IChangePhoneNumberCommand {
    phoneNumber?: string | undefined;
}

export class ChangePasswordCommand implements IChangePasswordCommand {
    oldPassword?: string | undefined;
    newPassword?: string | undefined;

    constructor(data?: IChangePasswordCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.oldPassword = _data["oldPassword"];
            this.newPassword = _data["newPassword"];
        }
    }

    static fromJS(data: any): ChangePasswordCommand {
        data = typeof data === 'object' ? data : {};
        let result = new ChangePasswordCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["oldPassword"] = this.oldPassword;
        data["newPassword"] = this.newPassword;
        return data;
    }
}

export interface IChangePasswordCommand {
    oldPassword?: string | undefined;
    newPassword?: string | undefined;
}

export class ChangeLanguageCommand implements IChangeLanguageCommand {
    language?: Language;

    constructor(data?: IChangeLanguageCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.language = _data["language"];
        }
    }

    static fromJS(data: any): ChangeLanguageCommand {
        data = typeof data === 'object' ? data : {};
        let result = new ChangeLanguageCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["language"] = this.language;
        return data;
    }
}

export interface IChangeLanguageCommand {
    language?: Language;
}

/** 0 = En 1 = Ar */
export enum Language {
    En = 0,
    Ar = 1,
}

export class ResetUserPasswordCommand implements IResetUserPasswordCommand {
    accountId?: string | undefined;
    password?: string | undefined;
    confirmPassword?: string | undefined;

    constructor(data?: IResetUserPasswordCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.accountId = _data["accountId"];
            this.password = _data["password"];
            this.confirmPassword = _data["confirmPassword"];
        }
    }

    static fromJS(data: any): ResetUserPasswordCommand {
        data = typeof data === 'object' ? data : {};
        let result = new ResetUserPasswordCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["accountId"] = this.accountId;
        data["password"] = this.password;
        data["confirmPassword"] = this.confirmPassword;
        return data;
    }
}

export interface IResetUserPasswordCommand {
    accountId?: string | undefined;
    password?: string | undefined;
    confirmPassword?: string | undefined;
}

export class AccountsEndLockoutCommand implements IAccountsEndLockoutCommand {
    accountId?: string | undefined;

    constructor(data?: IAccountsEndLockoutCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.accountId = _data["accountId"];
        }
    }

    static fromJS(data: any): AccountsEndLockoutCommand {
        data = typeof data === 'object' ? data : {};
        let result = new AccountsEndLockoutCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["accountId"] = this.accountId;
        return data;
    }
}

export interface IAccountsEndLockoutCommand {
    accountId?: string | undefined;
}

export class AccountsBanCommand implements IAccountsBanCommand {
    id?: string | undefined;
    ban?: boolean;

    constructor(data?: IAccountsBanCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.ban = _data["ban"];
        }
    }

    static fromJS(data: any): AccountsBanCommand {
        data = typeof data === 'object' ? data : {};
        let result = new AccountsBanCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["ban"] = this.ban;
        return data;
    }
}

export interface IAccountsBanCommand {
    id?: string | undefined;
    ban?: boolean;
}

export class ChatVm implements IChatVm {
    chatId?: string;
    receiver?: ReceiverVm | undefined;

    constructor(data?: IChatVm) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.chatId = _data["chatId"];
            this.receiver = _data["receiver"] ? ReceiverVm.fromJS(_data["receiver"]) : <any>undefined;
        }
    }

    static fromJS(data: any): ChatVm {
        data = typeof data === 'object' ? data : {};
        let result = new ChatVm();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["chatId"] = this.chatId;
        data["receiver"] = this.receiver ? this.receiver.toJSON() : <any>undefined;
        return data;
    }
}

export interface IChatVm {
    chatId?: string;
    receiver?: ReceiverVm | undefined;
}

export class ReceiverVm implements IReceiverVm {
    username?: string | undefined;
    fullName?: string | undefined;
    picture?: string | undefined;

    constructor(data?: IReceiverVm) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.username = _data["username"];
            this.fullName = _data["fullName"];
            this.picture = _data["picture"];
        }
    }

    static fromJS(data: any): ReceiverVm {
        data = typeof data === 'object' ? data : {};
        let result = new ReceiverVm();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["username"] = this.username;
        data["fullName"] = this.fullName;
        data["picture"] = this.picture;
        return data;
    }
}

export interface IReceiverVm {
    username?: string | undefined;
    fullName?: string | undefined;
    picture?: string | undefined;
}

export class PaginatedListOfMessageVm implements IPaginatedListOfMessageVm {
    pageInfo?: PageInfo | undefined;
    items?: MessageVm[] | undefined;

    constructor(data?: IPaginatedListOfMessageVm) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.pageInfo = _data["pageInfo"] ? PageInfo.fromJS(_data["pageInfo"]) : <any>undefined;
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(MessageVm.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PaginatedListOfMessageVm {
        data = typeof data === 'object' ? data : {};
        let result = new PaginatedListOfMessageVm();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["pageInfo"] = this.pageInfo ? this.pageInfo.toJSON() : <any>undefined;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IPaginatedListOfMessageVm {
    pageInfo?: PageInfo | undefined;
    items?: MessageVm[] | undefined;
}

export class MessageVm implements IMessageVm {
    id?: string;
    content?: string | undefined;
    type?: MessageType;
    createdAt?: Date;
    readAt?: Date | undefined;
    senderUsername?: string | undefined;

    constructor(data?: IMessageVm) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.content = _data["content"];
            this.type = _data["type"];
            this.createdAt = _data["createdAt"] ? new Date(_data["createdAt"].toString()) : <any>undefined;
            this.readAt = _data["readAt"] ? new Date(_data["readAt"].toString()) : <any>undefined;
            this.senderUsername = _data["senderUsername"];
        }
    }

    static fromJS(data: any): MessageVm {
        data = typeof data === 'object' ? data : {};
        let result = new MessageVm();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["content"] = this.content;
        data["type"] = this.type;
        data["createdAt"] = this.createdAt ? this.createdAt.toISOString() : <any>undefined;
        data["readAt"] = this.readAt ? this.readAt.toISOString() : <any>undefined;
        data["senderUsername"] = this.senderUsername;
        return data;
    }
}

export interface IMessageVm {
    id?: string;
    content?: string | undefined;
    type?: MessageType;
    createdAt?: Date;
    readAt?: Date | undefined;
    senderUsername?: string | undefined;
}

/** 0 = Text 1 = Picture 2 = Voice 3 = Audio 4 = File */
export enum MessageType {
    Text = 0,
    Picture = 1,
    Voice = 2,
    Audio = 3,
    File = 4,
}

export abstract class AuditableEntity implements IAuditableEntity {
    created?: Date;
    createdBy?: string | undefined;
    lastModified?: Date | undefined;
    lastModifiedBy?: string | undefined;

    constructor(data?: IAuditableEntity) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.created = _data["created"] ? new Date(_data["created"].toString()) : <any>undefined;
            this.createdBy = _data["createdBy"];
            this.lastModified = _data["lastModified"] ? new Date(_data["lastModified"].toString()) : <any>undefined;
            this.lastModifiedBy = _data["lastModifiedBy"];
        }
    }

    static fromJS(data: any): AuditableEntity {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'AuditableEntity' cannot be instantiated.");
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["created"] = this.created ? this.created.toISOString() : <any>undefined;
        data["createdBy"] = this.createdBy;
        data["lastModified"] = this.lastModified ? this.lastModified.toISOString() : <any>undefined;
        data["lastModifiedBy"] = this.lastModifiedBy;
        return data;
    }
}

export interface IAuditableEntity {
    created?: Date;
    createdBy?: string | undefined;
    lastModified?: Date | undefined;
    lastModifiedBy?: string | undefined;
}

export class CommonQuestion extends AuditableEntity implements ICommonQuestion {
    id?: number;
    question?: LocalizedString | undefined;
    answer?: LocalizedString | undefined;
    order?: number;

    constructor(data?: ICommonQuestion) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.id = _data["id"];
            this.question = _data["question"] ? LocalizedString.fromJS(_data["question"]) : <any>undefined;
            this.answer = _data["answer"] ? LocalizedString.fromJS(_data["answer"]) : <any>undefined;
            this.order = _data["order"];
        }
    }

    static fromJS(data: any): CommonQuestion {
        data = typeof data === 'object' ? data : {};
        let result = new CommonQuestion();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["question"] = this.question ? this.question.toJSON() : <any>undefined;
        data["answer"] = this.answer ? this.answer.toJSON() : <any>undefined;
        data["order"] = this.order;
        super.toJSON(data);
        return data;
    }
}

export interface ICommonQuestion extends IAuditableEntity {
    id?: number;
    question?: LocalizedString | undefined;
    answer?: LocalizedString | undefined;
    order?: number;
}

export abstract class ValueObject implements IValueObject {

    constructor(data?: IValueObject) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
    }

    static fromJS(data: any): ValueObject {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'ValueObject' cannot be instantiated.");
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        return data;
    }
}

export interface IValueObject {
}

export class WeakLocalizedString extends ValueObject implements IWeakLocalizedString {
    ar?: string | undefined;
    en?: string | undefined;

    constructor(data?: IWeakLocalizedString) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.ar = _data["ar"];
            this.en = _data["en"];
        }
    }

    static fromJS(data: any): WeakLocalizedString {
        data = typeof data === 'object' ? data : {};
        let result = new WeakLocalizedString();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["ar"] = this.ar;
        data["en"] = this.en;
        super.toJSON(data);
        return data;
    }
}

export interface IWeakLocalizedString extends IValueObject {
    ar?: string | undefined;
    en?: string | undefined;
}

export class LocalizedString extends WeakLocalizedString implements ILocalizedString {
    ar?: string | undefined;
    en?: string | undefined;

    constructor(data?: ILocalizedString) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.ar = _data["ar"];
            this.en = _data["en"];
        }
    }

    static fromJS(data: any): LocalizedString {
        data = typeof data === 'object' ? data : {};
        let result = new LocalizedString();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["ar"] = this.ar;
        data["en"] = this.en;
        super.toJSON(data);
        return data;
    }
}

export interface ILocalizedString extends IWeakLocalizedString {
    ar?: string | undefined;
    en?: string | undefined;
}

export class CommonQuestionGetListQuery implements ICommonQuestionGetListQuery {

    constructor(data?: ICommonQuestionGetListQuery) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
    }

    static fromJS(data: any): CommonQuestionGetListQuery {
        data = typeof data === 'object' ? data : {};
        let result = new CommonQuestionGetListQuery();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        return data;
    }
}

export interface ICommonQuestionGetListQuery {
}

export class PaginatedListOfCommonQuestionVm implements IPaginatedListOfCommonQuestionVm {
    pageInfo?: PageInfo | undefined;
    items?: CommonQuestionVm[] | undefined;

    constructor(data?: IPaginatedListOfCommonQuestionVm) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.pageInfo = _data["pageInfo"] ? PageInfo.fromJS(_data["pageInfo"]) : <any>undefined;
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(CommonQuestionVm.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PaginatedListOfCommonQuestionVm {
        data = typeof data === 'object' ? data : {};
        let result = new PaginatedListOfCommonQuestionVm();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["pageInfo"] = this.pageInfo ? this.pageInfo.toJSON() : <any>undefined;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IPaginatedListOfCommonQuestionVm {
    pageInfo?: PageInfo | undefined;
    items?: CommonQuestionVm[] | undefined;
}

export class CommonQuestionVm implements ICommonQuestionVm {
    id?: number;
    question?: string | undefined;
    answer?: string | undefined;

    constructor(data?: ICommonQuestionVm) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.question = _data["question"];
            this.answer = _data["answer"];
        }
    }

    static fromJS(data: any): CommonQuestionVm {
        data = typeof data === 'object' ? data : {};
        let result = new CommonQuestionVm();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["question"] = this.question;
        data["answer"] = this.answer;
        return data;
    }
}

export interface ICommonQuestionVm {
    id?: number;
    question?: string | undefined;
    answer?: string | undefined;
}

export class HttpResultOfInteger implements IHttpResultOfInteger {
    result?: number;

    constructor(data?: IHttpResultOfInteger) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.result = _data["result"];
        }
    }

    static fromJS(data: any): HttpResultOfInteger {
        data = typeof data === 'object' ? data : {};
        let result = new HttpResultOfInteger();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["result"] = this.result;
        return data;
    }
}

export interface IHttpResultOfInteger {
    result?: number;
}

export class CommonQuestionPostPutCommon implements ICommonQuestionPostPutCommon {
    question?: LocalizedStringDto | undefined;
    answer?: LocalizedStringDto | undefined;

    constructor(data?: ICommonQuestionPostPutCommon) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.question = _data["question"] ? LocalizedStringDto.fromJS(_data["question"]) : <any>undefined;
            this.answer = _data["answer"] ? LocalizedStringDto.fromJS(_data["answer"]) : <any>undefined;
        }
    }

    static fromJS(data: any): CommonQuestionPostPutCommon {
        data = typeof data === 'object' ? data : {};
        let result = new CommonQuestionPostPutCommon();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["question"] = this.question ? this.question.toJSON() : <any>undefined;
        data["answer"] = this.answer ? this.answer.toJSON() : <any>undefined;
        return data;
    }
}

export interface ICommonQuestionPostPutCommon {
    question?: LocalizedStringDto | undefined;
    answer?: LocalizedStringDto | undefined;
}

export class CommonQuestionPostCommand extends CommonQuestionPostPutCommon implements ICommonQuestionPostCommand {

    constructor(data?: ICommonQuestionPostCommand) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
    }

    static fromJS(data: any): CommonQuestionPostCommand {
        data = typeof data === 'object' ? data : {};
        let result = new CommonQuestionPostCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface ICommonQuestionPostCommand extends ICommonQuestionPostPutCommon {
}

export class LocalizedStringDto implements ILocalizedStringDto {
    ar?: string | undefined;
    en?: string | undefined;

    constructor(data?: ILocalizedStringDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.ar = _data["ar"];
            this.en = _data["en"];
        }
    }

    static fromJS(data: any): LocalizedStringDto {
        data = typeof data === 'object' ? data : {};
        let result = new LocalizedStringDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["ar"] = this.ar;
        data["en"] = this.en;
        return data;
    }
}

export interface ILocalizedStringDto {
    ar?: string | undefined;
    en?: string | undefined;
}

export class CommonQuestionPutCommand extends CommonQuestionPostPutCommon implements ICommonQuestionPutCommand {
    id?: number;

    constructor(data?: ICommonQuestionPutCommand) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): CommonQuestionPutCommand {
        data = typeof data === 'object' ? data : {};
        let result = new CommonQuestionPutCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        super.toJSON(data);
        return data;
    }
}

export interface ICommonQuestionPutCommand extends ICommonQuestionPostPutCommon {
    id?: number;
}

export class CommonQuestionPutOrderCommand implements ICommonQuestionPutOrderCommand {
    id?: number;
    order?: number;

    constructor(data?: ICommonQuestionPutOrderCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.order = _data["order"];
        }
    }

    static fromJS(data: any): CommonQuestionPutOrderCommand {
        data = typeof data === 'object' ? data : {};
        let result = new CommonQuestionPutOrderCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["order"] = this.order;
        return data;
    }
}

export interface ICommonQuestionPutOrderCommand {
    id?: number;
    order?: number;
}

export class ContentVm implements IContentVm {
    value?: string | undefined;

    constructor(data?: IContentVm) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.value = _data["value"];
        }
    }

    static fromJS(data: any): ContentVm {
        data = typeof data === 'object' ? data : {};
        let result = new ContentVm();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["value"] = this.value;
        return data;
    }
}

export interface IContentVm {
    value?: string | undefined;
}

/** 0 = TermsAndConditions 1 = PrivacyPolicy 2 = ContactUs */
export enum ContentType {
    TermsAndConditions = 0,
    PrivacyPolicy = 1,
    ContactUs = 2,
}

export class ContentsPutCommand implements IContentsPutCommand {
    value?: string | undefined;
    lang?: Language;
    type?: ContentType;

    constructor(data?: IContentsPutCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.value = _data["value"];
            this.lang = _data["lang"];
            this.type = _data["type"];
        }
    }

    static fromJS(data: any): ContentsPutCommand {
        data = typeof data === 'object' ? data : {};
        let result = new ContentsPutCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["value"] = this.value;
        data["lang"] = this.lang;
        data["type"] = this.type;
        return data;
    }
}

export interface IContentsPutCommand {
    value?: string | undefined;
    lang?: Language;
    type?: ContentType;
}

export class CountryDto implements ICountryDto {
    id?: number;
    name?: LocalizedStringDto | undefined;
    isActive?: boolean;
    order?: number;

    constructor(data?: ICountryDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"] ? LocalizedStringDto.fromJS(_data["name"]) : <any>undefined;
            this.isActive = _data["isActive"];
            this.order = _data["order"];
        }
    }

    static fromJS(data: any): CountryDto {
        data = typeof data === 'object' ? data : {};
        let result = new CountryDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name ? this.name.toJSON() : <any>undefined;
        data["isActive"] = this.isActive;
        data["order"] = this.order;
        return data;
    }
}

export interface ICountryDto {
    id?: number;
    name?: LocalizedStringDto | undefined;
    isActive?: boolean;
    order?: number;
}

export class CountryVm implements ICountryVm {
    id?: number;
    name?: string | undefined;

    constructor(data?: ICountryVm) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): CountryVm {
        data = typeof data === 'object' ? data : {};
        let result = new CountryVm();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        return data;
    }
}

export interface ICountryVm {
    id?: number;
    name?: string | undefined;
}

export class FullCountryVm implements IFullCountryVm {
    id?: number;
    name?: string | undefined;
    regions?: RegionVmForDashboard[] | undefined;

    constructor(data?: IFullCountryVm) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            if (Array.isArray(_data["regions"])) {
                this.regions = [] as any;
                for (let item of _data["regions"])
                    this.regions!.push(RegionVmForDashboard.fromJS(item));
            }
        }
    }

    static fromJS(data: any): FullCountryVm {
        data = typeof data === 'object' ? data : {};
        let result = new FullCountryVm();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        if (Array.isArray(this.regions)) {
            data["regions"] = [];
            for (let item of this.regions)
                data["regions"].push(item.toJSON());
        }
        return data;
    }
}

export interface IFullCountryVm {
    id?: number;
    name?: string | undefined;
    regions?: RegionVmForDashboard[] | undefined;
}

export class RegionVmForDashboard implements IRegionVmForDashboard {
    id?: number;
    name?: string | undefined;
    subRegion?: RegionVm[] | undefined;

    constructor(data?: IRegionVmForDashboard) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            if (Array.isArray(_data["subRegion"])) {
                this.subRegion = [] as any;
                for (let item of _data["subRegion"])
                    this.subRegion!.push(RegionVm.fromJS(item));
            }
        }
    }

    static fromJS(data: any): RegionVmForDashboard {
        data = typeof data === 'object' ? data : {};
        let result = new RegionVmForDashboard();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        if (Array.isArray(this.subRegion)) {
            data["subRegion"] = [];
            for (let item of this.subRegion)
                data["subRegion"].push(item.toJSON());
        }
        return data;
    }
}

export interface IRegionVmForDashboard {
    id?: number;
    name?: string | undefined;
    subRegion?: RegionVm[] | undefined;
}

export class RegionVm implements IRegionVm {
    id?: number;
    name?: string | undefined;

    constructor(data?: IRegionVm) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): RegionVm {
        data = typeof data === 'object' ? data : {};
        let result = new RegionVm();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        return data;
    }
}

export interface IRegionVm {
    id?: number;
    name?: string | undefined;
}

export class CountriesPostPutCommon implements ICountriesPostPutCommon {
    name?: LocalizedStringDto | undefined;
    isActive?: boolean;

    constructor(data?: ICountriesPostPutCommon) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"] ? LocalizedStringDto.fromJS(_data["name"]) : <any>undefined;
            this.isActive = _data["isActive"];
        }
    }

    static fromJS(data: any): CountriesPostPutCommon {
        data = typeof data === 'object' ? data : {};
        let result = new CountriesPostPutCommon();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name ? this.name.toJSON() : <any>undefined;
        data["isActive"] = this.isActive;
        return data;
    }
}

export interface ICountriesPostPutCommon {
    name?: LocalizedStringDto | undefined;
    isActive?: boolean;
}

export class CountriesPostCommand extends CountriesPostPutCommon implements ICountriesPostCommand {

    constructor(data?: ICountriesPostCommand) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
    }

    static fromJS(data: any): CountriesPostCommand {
        data = typeof data === 'object' ? data : {};
        let result = new CountriesPostCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface ICountriesPostCommand extends ICountriesPostPutCommon {
}

export class CountriesPutCommand extends CountriesPostPutCommon implements ICountriesPutCommand {
    id?: number;

    constructor(data?: ICountriesPutCommand) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): CountriesPutCommand {
        data = typeof data === 'object' ? data : {};
        let result = new CountriesPutCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        super.toJSON(data);
        return data;
    }
}

export interface ICountriesPutCommand extends ICountriesPostPutCommon {
    id?: number;
}

export class CountriesPutOrderCommand implements ICountriesPutOrderCommand {
    id?: number;
    order?: number;

    constructor(data?: ICountriesPutOrderCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.order = _data["order"];
        }
    }

    static fromJS(data: any): CountriesPutOrderCommand {
        data = typeof data === 'object' ? data : {};
        let result = new CountriesPutOrderCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["order"] = this.order;
        return data;
    }
}

export interface ICountriesPutOrderCommand {
    id?: number;
    order?: number;
}

export class FormDto implements IFormDto {
    id?: number;
    name?: LocalizedStringDto | undefined;
    description?: LocalizedStringDto | undefined;
    realStateId?: number;
    countryId?: number;
    parentRegionId?: number;
    regionId?: number | undefined;
    type?: RequestType;
    fields?: DataFieldDto[] | undefined;
    values?: ValueDto[] | undefined;

    constructor(data?: IFormDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"] ? LocalizedStringDto.fromJS(_data["name"]) : <any>undefined;
            this.description = _data["description"] ? LocalizedStringDto.fromJS(_data["description"]) : <any>undefined;
            this.realStateId = _data["realStateId"];
            this.countryId = _data["countryId"];
            this.parentRegionId = _data["parentRegionId"];
            this.regionId = _data["regionId"];
            this.type = _data["type"];
            if (Array.isArray(_data["fields"])) {
                this.fields = [] as any;
                for (let item of _data["fields"])
                    this.fields!.push(DataFieldDto.fromJS(item));
            }
            if (Array.isArray(_data["values"])) {
                this.values = [] as any;
                for (let item of _data["values"])
                    this.values!.push(ValueDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): FormDto {
        data = typeof data === 'object' ? data : {};
        let result = new FormDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name ? this.name.toJSON() : <any>undefined;
        data["description"] = this.description ? this.description.toJSON() : <any>undefined;
        data["realStateId"] = this.realStateId;
        data["countryId"] = this.countryId;
        data["parentRegionId"] = this.parentRegionId;
        data["regionId"] = this.regionId;
        data["type"] = this.type;
        if (Array.isArray(this.fields)) {
            data["fields"] = [];
            for (let item of this.fields)
                data["fields"].push(item.toJSON());
        }
        if (Array.isArray(this.values)) {
            data["values"] = [];
            for (let item of this.values)
                data["values"].push(item.toJSON());
        }
        return data;
    }
}

export interface IFormDto {
    id?: number;
    name?: LocalizedStringDto | undefined;
    description?: LocalizedStringDto | undefined;
    realStateId?: number;
    countryId?: number;
    parentRegionId?: number;
    regionId?: number | undefined;
    type?: RequestType;
    fields?: DataFieldDto[] | undefined;
    values?: ValueDto[] | undefined;
}

/** 0 = Preview 1 = Evaluation */
export enum RequestType {
    Preview = 0,
    Evaluation = 1,
}

export class DataFieldDto implements IDataFieldDto {
    id?: string;
    name?: LocalizedStringDto | undefined;
    placeholder?: LocalizedStringDto | undefined;
    orders?: number;
    code?: string | undefined;
    equation?: string | undefined;
    regex?: string | undefined;
    isRequired?: boolean;
    fieldType?: FieldType;
    dataValues?: DataValueDto[] | undefined;

    constructor(data?: IDataFieldDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"] ? LocalizedStringDto.fromJS(_data["name"]) : <any>undefined;
            this.placeholder = _data["placeholder"] ? LocalizedStringDto.fromJS(_data["placeholder"]) : <any>undefined;
            this.orders = _data["orders"];
            this.code = _data["code"];
            this.equation = _data["equation"];
            this.regex = _data["regex"];
            this.isRequired = _data["isRequired"];
            this.fieldType = _data["fieldType"];
            if (Array.isArray(_data["dataValues"])) {
                this.dataValues = [] as any;
                for (let item of _data["dataValues"])
                    this.dataValues!.push(DataValueDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): DataFieldDto {
        data = typeof data === 'object' ? data : {};
        let result = new DataFieldDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name ? this.name.toJSON() : <any>undefined;
        data["placeholder"] = this.placeholder ? this.placeholder.toJSON() : <any>undefined;
        data["orders"] = this.orders;
        data["code"] = this.code;
        data["equation"] = this.equation;
        data["regex"] = this.regex;
        data["isRequired"] = this.isRequired;
        data["fieldType"] = this.fieldType;
        if (Array.isArray(this.dataValues)) {
            data["dataValues"] = [];
            for (let item of this.dataValues)
                data["dataValues"].push(item.toJSON());
        }
        return data;
    }
}

export interface IDataFieldDto {
    id?: string;
    name?: LocalizedStringDto | undefined;
    placeholder?: LocalizedStringDto | undefined;
    orders?: number;
    code?: string | undefined;
    equation?: string | undefined;
    regex?: string | undefined;
    isRequired?: boolean;
    fieldType?: FieldType;
    dataValues?: DataValueDto[] | undefined;
}

/** 0 = Text 1 = Number 2 = Date 3 = DateTime 4 = TextArea 5 = CheckBox 6 = Radio 7 = Select 8 = MultiSelect 9 = SingleImage 10 = MultiImages 11 = Pdf 12 = Result 13 = Hidden */
export enum FieldType {
    Text = 0,
    Number = 1,
    Date = 2,
    DateTime = 3,
    TextArea = 4,
    CheckBox = 5,
    Radio = 6,
    Select = 7,
    MultiSelect = 8,
    SingleImage = 9,
    MultiImages = 10,
    Pdf = 11,
    Result = 12,
    Hidden = 13,
}

export class DataValueDto implements IDataValueDto {
    id?: string;
    value?: LocalizedStringDto | undefined;

    constructor(data?: IDataValueDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.value = _data["value"] ? LocalizedStringDto.fromJS(_data["value"]) : <any>undefined;
        }
    }

    static fromJS(data: any): DataValueDto {
        data = typeof data === 'object' ? data : {};
        let result = new DataValueDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["value"] = this.value ? this.value.toJSON() : <any>undefined;
        return data;
    }
}

export interface IDataValueDto {
    id?: string;
    value?: LocalizedStringDto | undefined;
}

export class ValueDto implements IValueDto {
    isSelected?: boolean;
    saveValue?: string | undefined;
    requestId?: string;
    dataFieldId?: string;
    dataValueId?: string | undefined;

    constructor(data?: IValueDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.isSelected = _data["isSelected"];
            this.saveValue = _data["saveValue"];
            this.requestId = _data["requestId"];
            this.dataFieldId = _data["dataFieldId"];
            this.dataValueId = _data["dataValueId"];
        }
    }

    static fromJS(data: any): ValueDto {
        data = typeof data === 'object' ? data : {};
        let result = new ValueDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isSelected"] = this.isSelected;
        data["saveValue"] = this.saveValue;
        data["requestId"] = this.requestId;
        data["dataFieldId"] = this.dataFieldId;
        data["dataValueId"] = this.dataValueId;
        return data;
    }
}

export interface IValueDto {
    isSelected?: boolean;
    saveValue?: string | undefined;
    requestId?: string;
    dataFieldId?: string;
    dataValueId?: string | undefined;
}

export class PaginatedListOfFormVmForDashboard implements IPaginatedListOfFormVmForDashboard {
    pageInfo?: PageInfo | undefined;
    items?: FormVmForDashboard[] | undefined;

    constructor(data?: IPaginatedListOfFormVmForDashboard) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.pageInfo = _data["pageInfo"] ? PageInfo.fromJS(_data["pageInfo"]) : <any>undefined;
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(FormVmForDashboard.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PaginatedListOfFormVmForDashboard {
        data = typeof data === 'object' ? data : {};
        let result = new PaginatedListOfFormVmForDashboard();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["pageInfo"] = this.pageInfo ? this.pageInfo.toJSON() : <any>undefined;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IPaginatedListOfFormVmForDashboard {
    pageInfo?: PageInfo | undefined;
    items?: FormVmForDashboard[] | undefined;
}

export class FormVmForDashboard implements IFormVmForDashboard {
    id?: number;
    name?: LocalizedStringDto | undefined;
    type?: RequestType;
    realState?: string | undefined;
    requestsNumber?: number;

    constructor(data?: IFormVmForDashboard) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"] ? LocalizedStringDto.fromJS(_data["name"]) : <any>undefined;
            this.type = _data["type"];
            this.realState = _data["realState"];
            this.requestsNumber = _data["requestsNumber"];
        }
    }

    static fromJS(data: any): FormVmForDashboard {
        data = typeof data === 'object' ? data : {};
        let result = new FormVmForDashboard();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name ? this.name.toJSON() : <any>undefined;
        data["type"] = this.type;
        data["realState"] = this.realState;
        data["requestsNumber"] = this.requestsNumber;
        return data;
    }
}

export interface IFormVmForDashboard {
    id?: number;
    name?: LocalizedStringDto | undefined;
    type?: RequestType;
    realState?: string | undefined;
    requestsNumber?: number;
}

export class HttpResultOfLong implements IHttpResultOfLong {
    result?: number;

    constructor(data?: IHttpResultOfLong) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.result = _data["result"];
        }
    }

    static fromJS(data: any): HttpResultOfLong {
        data = typeof data === 'object' ? data : {};
        let result = new HttpResultOfLong();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["result"] = this.result;
        return data;
    }
}

export interface IHttpResultOfLong {
    result?: number;
}

export class PaginatedListOfPlanVmForDashborad implements IPaginatedListOfPlanVmForDashborad {
    pageInfo?: PageInfo | undefined;
    items?: PlanVmForDashborad[] | undefined;

    constructor(data?: IPaginatedListOfPlanVmForDashborad) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.pageInfo = _data["pageInfo"] ? PageInfo.fromJS(_data["pageInfo"]) : <any>undefined;
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(PlanVmForDashborad.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PaginatedListOfPlanVmForDashborad {
        data = typeof data === 'object' ? data : {};
        let result = new PaginatedListOfPlanVmForDashborad();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["pageInfo"] = this.pageInfo ? this.pageInfo.toJSON() : <any>undefined;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IPaginatedListOfPlanVmForDashborad {
    pageInfo?: PageInfo | undefined;
    items?: PlanVmForDashborad[] | undefined;
}

export class PlanVmForDashborad implements IPlanVmForDashborad {
    id?: number;
    name?: LocalizedStringDto | undefined;
    reportsNumber?: number | undefined;
    price?: number;
    usersNumber?: number | undefined;

    constructor(data?: IPlanVmForDashborad) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"] ? LocalizedStringDto.fromJS(_data["name"]) : <any>undefined;
            this.reportsNumber = _data["reportsNumber"];
            this.price = _data["price"];
            this.usersNumber = _data["usersNumber"];
        }
    }

    static fromJS(data: any): PlanVmForDashborad {
        data = typeof data === 'object' ? data : {};
        let result = new PlanVmForDashborad();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name ? this.name.toJSON() : <any>undefined;
        data["reportsNumber"] = this.reportsNumber;
        data["price"] = this.price;
        data["usersNumber"] = this.usersNumber;
        return data;
    }
}

export interface IPlanVmForDashborad {
    id?: number;
    name?: LocalizedStringDto | undefined;
    reportsNumber?: number | undefined;
    price?: number;
    usersNumber?: number | undefined;
}

export class PlanPostPutCommon implements IPlanPostPutCommon {
    name?: LocalizedStringDto | undefined;
    reportsNumber?: number | undefined;
    price?: number;
    usersNumber?: number | undefined;

    constructor(data?: IPlanPostPutCommon) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"] ? LocalizedStringDto.fromJS(_data["name"]) : <any>undefined;
            this.reportsNumber = _data["reportsNumber"];
            this.price = _data["price"];
            this.usersNumber = _data["usersNumber"];
        }
    }

    static fromJS(data: any): PlanPostPutCommon {
        data = typeof data === 'object' ? data : {};
        let result = new PlanPostPutCommon();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name ? this.name.toJSON() : <any>undefined;
        data["reportsNumber"] = this.reportsNumber;
        data["price"] = this.price;
        data["usersNumber"] = this.usersNumber;
        return data;
    }
}

export interface IPlanPostPutCommon {
    name?: LocalizedStringDto | undefined;
    reportsNumber?: number | undefined;
    price?: number;
    usersNumber?: number | undefined;
}

export class PlansPostCommand extends PlanPostPutCommon implements IPlansPostCommand {

    constructor(data?: IPlansPostCommand) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
    }

    static fromJS(data: any): PlansPostCommand {
        data = typeof data === 'object' ? data : {};
        let result = new PlansPostCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IPlansPostCommand extends IPlanPostPutCommon {
}

export class PlansPutCommand extends PlanPostPutCommon implements IPlansPutCommand {
    id?: number;

    constructor(data?: IPlansPutCommand) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): PlansPutCommand {
        data = typeof data === 'object' ? data : {};
        let result = new PlansPutCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        super.toJSON(data);
        return data;
    }
}

export interface IPlansPutCommand extends IPlanPostPutCommon {
    id?: number;
}

export class RealStateDto implements IRealStateDto {
    id?: number;
    name?: LocalizedStringDto | undefined;
    order?: number;
    isActive?: boolean;

    constructor(data?: IRealStateDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"] ? LocalizedStringDto.fromJS(_data["name"]) : <any>undefined;
            this.order = _data["order"];
            this.isActive = _data["isActive"];
        }
    }

    static fromJS(data: any): RealStateDto {
        data = typeof data === 'object' ? data : {};
        let result = new RealStateDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name ? this.name.toJSON() : <any>undefined;
        data["order"] = this.order;
        data["isActive"] = this.isActive;
        return data;
    }
}

export interface IRealStateDto {
    id?: number;
    name?: LocalizedStringDto | undefined;
    order?: number;
    isActive?: boolean;
}

export class RealStatesVmForDashboard implements IRealStatesVmForDashboard {
    id?: number;
    name?: LocalizedStringDto | undefined;
    isActive?: boolean;
    order?: number;

    constructor(data?: IRealStatesVmForDashboard) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"] ? LocalizedStringDto.fromJS(_data["name"]) : <any>undefined;
            this.isActive = _data["isActive"];
            this.order = _data["order"];
        }
    }

    static fromJS(data: any): RealStatesVmForDashboard {
        data = typeof data === 'object' ? data : {};
        let result = new RealStatesVmForDashboard();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name ? this.name.toJSON() : <any>undefined;
        data["isActive"] = this.isActive;
        data["order"] = this.order;
        return data;
    }
}

export interface IRealStatesVmForDashboard {
    id?: number;
    name?: LocalizedStringDto | undefined;
    isActive?: boolean;
    order?: number;
}

export class RealStatesVm implements IRealStatesVm {
    id?: number;
    name?: string | undefined;

    constructor(data?: IRealStatesVm) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): RealStatesVm {
        data = typeof data === 'object' ? data : {};
        let result = new RealStatesVm();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        return data;
    }
}

export interface IRealStatesVm {
    id?: number;
    name?: string | undefined;
}

export class RealStatePostPutCommon implements IRealStatePostPutCommon {
    name?: LocalizedStringDto | undefined;
    isActive?: boolean;

    constructor(data?: IRealStatePostPutCommon) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"] ? LocalizedStringDto.fromJS(_data["name"]) : <any>undefined;
            this.isActive = _data["isActive"];
        }
    }

    static fromJS(data: any): RealStatePostPutCommon {
        data = typeof data === 'object' ? data : {};
        let result = new RealStatePostPutCommon();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name ? this.name.toJSON() : <any>undefined;
        data["isActive"] = this.isActive;
        return data;
    }
}

export interface IRealStatePostPutCommon {
    name?: LocalizedStringDto | undefined;
    isActive?: boolean;
}

export class RealStatesPostCommand extends RealStatePostPutCommon implements IRealStatesPostCommand {

    constructor(data?: IRealStatesPostCommand) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
    }

    static fromJS(data: any): RealStatesPostCommand {
        data = typeof data === 'object' ? data : {};
        let result = new RealStatesPostCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IRealStatesPostCommand extends IRealStatePostPutCommon {
}

export class RealStatesPutCommand extends RealStatePostPutCommon implements IRealStatesPutCommand {
    id?: number;

    constructor(data?: IRealStatesPutCommand) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): RealStatesPutCommand {
        data = typeof data === 'object' ? data : {};
        let result = new RealStatesPutCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        super.toJSON(data);
        return data;
    }
}

export interface IRealStatesPutCommand extends IRealStatePostPutCommon {
    id?: number;
}

export class RealStatesPutOrderCommand implements IRealStatesPutOrderCommand {
    id?: number;
    order?: number;

    constructor(data?: IRealStatesPutOrderCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.order = _data["order"];
        }
    }

    static fromJS(data: any): RealStatesPutOrderCommand {
        data = typeof data === 'object' ? data : {};
        let result = new RealStatesPutOrderCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["order"] = this.order;
        return data;
    }
}

export interface IRealStatesPutOrderCommand {
    id?: number;
    order?: number;
}

export class RegionDto implements IRegionDto {
    id?: number;
    name?: LocalizedStringDto | undefined;
    isActive?: boolean;
    countryId?: number;
    countryName?: string | undefined;

    constructor(data?: IRegionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"] ? LocalizedStringDto.fromJS(_data["name"]) : <any>undefined;
            this.isActive = _data["isActive"];
            this.countryId = _data["countryId"];
            this.countryName = _data["countryName"];
        }
    }

    static fromJS(data: any): RegionDto {
        data = typeof data === 'object' ? data : {};
        let result = new RegionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name ? this.name.toJSON() : <any>undefined;
        data["isActive"] = this.isActive;
        data["countryId"] = this.countryId;
        data["countryName"] = this.countryName;
        return data;
    }
}

export interface IRegionDto {
    id?: number;
    name?: LocalizedStringDto | undefined;
    isActive?: boolean;
    countryId?: number;
    countryName?: string | undefined;
}

export class PaginatedListOfRegionDto implements IPaginatedListOfRegionDto {
    pageInfo?: PageInfo | undefined;
    items?: RegionDto[] | undefined;

    constructor(data?: IPaginatedListOfRegionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.pageInfo = _data["pageInfo"] ? PageInfo.fromJS(_data["pageInfo"]) : <any>undefined;
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(RegionDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PaginatedListOfRegionDto {
        data = typeof data === 'object' ? data : {};
        let result = new PaginatedListOfRegionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["pageInfo"] = this.pageInfo ? this.pageInfo.toJSON() : <any>undefined;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IPaginatedListOfRegionDto {
    pageInfo?: PageInfo | undefined;
    items?: RegionDto[] | undefined;
}

export class RegionsPostPutCommon implements IRegionsPostPutCommon {
    name?: LocalizedStringDto | undefined;
    isActive?: boolean;
    parentRegionId?: number | undefined;
    countryId?: number | undefined;

    constructor(data?: IRegionsPostPutCommon) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"] ? LocalizedStringDto.fromJS(_data["name"]) : <any>undefined;
            this.isActive = _data["isActive"];
            this.parentRegionId = _data["parentRegionId"];
            this.countryId = _data["countryId"];
        }
    }

    static fromJS(data: any): RegionsPostPutCommon {
        data = typeof data === 'object' ? data : {};
        let result = new RegionsPostPutCommon();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name ? this.name.toJSON() : <any>undefined;
        data["isActive"] = this.isActive;
        data["parentRegionId"] = this.parentRegionId;
        data["countryId"] = this.countryId;
        return data;
    }
}

export interface IRegionsPostPutCommon {
    name?: LocalizedStringDto | undefined;
    isActive?: boolean;
    parentRegionId?: number | undefined;
    countryId?: number | undefined;
}

export class RegionsPostCommand extends RegionsPostPutCommon implements IRegionsPostCommand {

    constructor(data?: IRegionsPostCommand) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
    }

    static fromJS(data: any): RegionsPostCommand {
        data = typeof data === 'object' ? data : {};
        let result = new RegionsPostCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IRegionsPostCommand extends IRegionsPostPutCommon {
}

export class RegionsPutCommand extends RegionsPostPutCommon implements IRegionsPutCommand {
    id?: number;

    constructor(data?: IRegionsPutCommand) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): RegionsPutCommand {
        data = typeof data === 'object' ? data : {};
        let result = new RegionsPutCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        super.toJSON(data);
        return data;
    }
}

export interface IRegionsPutCommand extends IRegionsPostPutCommon {
    id?: number;
}

export class UserRegionDto implements IUserRegionDto {
    regionId?: number;
    name?: string | undefined;

    constructor(data?: IUserRegionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.regionId = _data["regionId"];
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): UserRegionDto {
        data = typeof data === 'object' ? data : {};
        let result = new UserRegionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["regionId"] = this.regionId;
        data["name"] = this.name;
        return data;
    }
}

export interface IUserRegionDto {
    regionId?: number;
    name?: string | undefined;
}

export interface FileParameter {
    data: any;
    fileName: string;
}

export class ApiException extends Error {
    message: string;
    status: number;
    response: string;
    headers: { [key: string]: any; };
    result: any;

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isApiException = true;

    static isApiException(obj: any): obj is ApiException {
        return obj.isApiException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): Observable<any> {
    if (result !== null && result !== undefined)
        return _observableThrow(result);
    else
        return _observableThrow(new ApiException(message, status, response, headers, null));
}

function blobToText(blob: any): Observable<string> {
    return new Observable<string>((observer: any) => {
        if (!blob) {
            observer.next("");
            observer.complete();
        } else {
            let reader = new FileReader();
            reader.onload = event => {
                observer.next((<any>event.target).result);
                observer.complete();
            };
            reader.readAsText(blob);
        }
    });
}